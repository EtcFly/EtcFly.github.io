<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="EtcFly"><meta name="keywords" content=""><meta name="description" content="版权归作者所有, 转载请保留该部分声明。本文作者：EtcFly原文地址：https:&#x2F;&#x2F;etcfly.top              简介   相信大家应该都听过对称加密(如AES, DES等), 以及非对称加密(RSA等), 对称加密和非对称加密(又叫公钥加密)是常用的两种密码算法, 他们各有优点。    加密类型 优点 缺点     对称加密 1、加解密速度快 2、"><meta property="og:type" content="article"><meta property="og:title" content="对称加密和非对称加密"><meta property="og:url" content="http://example.com/2023/06/18/chipher/aes/rsa/204920/"><meta property="og:site_name" content="仗剑走天涯"><meta property="og:description" content="版权归作者所有, 转载请保留该部分声明。本文作者：EtcFly原文地址：https:&#x2F;&#x2F;etcfly.top              简介   相信大家应该都听过对称加密(如AES, DES等), 以及非对称加密(RSA等), 对称加密和非对称加密(又叫公钥加密)是常用的两种密码算法, 他们各有优点。    加密类型 优点 缺点     对称加密 1、加解密速度快 2、"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/chipher.png"><meta property="article:published_time" content="2023-06-18T20:49:20.000Z"><meta property="article:modified_time" content="2024-03-05T03:41:03.000Z"><meta property="article:author" content="EtcFly"><meta property="article:tag" content="原创"><meta property="article:tag" content="AES - RSA"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/img/chipher.png"><title>对称加密和非对称加密 仗剑走天涯</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/fluid-extention.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:4},web_analytics:{enable:!0,follow_dnt:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"3AEufnWAJdp8cFODp1DXvrQU-MdYXbMMI",app_key:"mGJiL6xVvYv21ygqfynJoCyO",server_url:null,path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Strive For Dream</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="对称加密和非对称加密"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-06-18 20:49" pubdate>2023年6月18日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 8.2k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 69 分钟 </span><span id="vvdpost_container_page_pvuv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="vvdpost_value_page_pv">0</span> 次&nbsp&nbsp <i class="iconfont icon-users" aria-hidden="true"></i> <span id="vvdpost_value_page_uv">0</span> 人</span><script>console.log(window.location.pathname);var httpRequest=new XMLHttpRequest;httpRequest.open("POST","https://etcfly.top:14200/poststats",!0),httpRequest.setRequestHeader("Content-type","application/json"),httpRequest.send(JSON.stringify(window.location.pathname)),httpRequest.onreadystatechange=function(){if(4==httpRequest.readyState&&200==httpRequest.status){var e=httpRequest.responseText,t=JSON.parse(e);console.log(t.pv);var o=document.querySelector("#vvdpost_container_page_pvuv");if(console.log(o),o){var n=document.querySelector("#vvdpost_value_page_pv");console.log(n);var s=document.querySelector("#vvdpost_value_page_uv");console.log(s),s&&s&&(n.innerText=t.pv,s.innerText=t.uv,o.style.display="inline")}}}</script></div></div></div></div></div></div><script async src="https://etcfly.top:14100/script.js" data-website-id="1a5c096d-21e5-4556-99b0-28c810c9c868"></script></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">对称加密和非对称加密</h1><p class="note note-info">本文最后更新于：2024年3月5日 凌晨</p><div class="markdown-body"><div class="note note-success"><p>版权归作者所有, 转载请保留该部分声明。<br>本文作者：EtcFly<br>原文地址：<a target="_blank" rel="noopener" href="https://etcfly.top">https://etcfly.top</a></p></div><hr><h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3><p>  相信大家应该都听过对称加密(如<code>AES</code>, <code>DES</code>等), 以及非对称加密(<code>RSA</code>等), 对称加密和非对称加密(又叫<strong>公钥加密</strong>)是常用的两种密码算法, 他们各有优点。</p><table><thead><tr><th style="text-align:left"><strong>加密类型</strong></th><th style="text-align:left"><strong>优点</strong></th><th style="text-align:left"><strong>缺点</strong></th></tr></thead><tbody><tr><td style="text-align:left">对称加密</td><td style="text-align:left">1、加解密速度快 2、密钥简单, 只需要一个密钥 3、加密强度大</td><td style="text-align:left">加密双方密钥同步困难</td></tr><tr><td style="text-align:left">非对称加密</td><td style="text-align:left">1、密钥同步简单 2、加密强度大</td><td style="text-align:left">加解密速度慢, 只有对称加密的几百分之一</td></tr></tbody></table><p>衡量一个算法的性能可以从几个方面入手</p><ul><li>加解密速度</li><li>密钥同步是否方便</li><li>加密强度(密钥空间是否足够大, 密钥空间太小很容易暴力破解)</li></ul><p>接下来我们将详细的介绍这两类加密方式。</p><hr><h3 id="对称加密"><a class="markdownIt-Anchor" href="#对称加密"></a> 对称加密</h3><p>  对称加密算法有很多, 如上世纪的<code>DES</code>以及后来的<code>3DES</code>, 再到后来者<code>AES</code>, 每一次新的算法加入都伴随着上一个密码算法的攻破, 早期 <code>DES</code>算法使用<code>64bits</code>(实际是<code>56bits</code>)的密钥, 对于<code>1977</code>年代的算力, 这个算法密钥足够大, 随着算力的发展, 该算法<code>90</code>年代已经被攻破, 于是为了加强<code>DES</code>算法强度, 人们发明了<code>3DES</code>算法, <code>3DES</code>使用重复三次<code>DES</code>得到的一种密码算法，<code>3DES</code>将原来<code>DES</code>密钥空间从<code>56bits</code>扩展到了<code>168bits</code>, 但是处理速度不快, 目前<code>3DES</code>除了比较传统保守的行业还在使用, , 很少用在新的用途。<code>AES</code>作为当前对称加密的新生代被大量使用。</p><hr><h4 id="des"><a class="markdownIt-Anchor" href="#des"></a> DES</h4><p>  <code>DES</code>是一种分组加密算法(又称为分组密码), 即将一个分组(<code>64Bits</code>)通过加密转换成另一个分组, 如果密码长度很长, 则需要进行迭代来完成长明文序列的加密。</p><p><img src="/2023/06/18/chipher/aes/rsa/204920/DES%E5%8A%A0%E8%A7%A3%E5%AF%86%E6%A1%86%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="DES加解密框图.png"></p><p>图上之所以显示密钥是<code>56bits</code>是因为<code>DES</code>密钥每隔<code>7bits</code>会设置一个错误校验位。<code>64bits</code>有<code>8bits</code>是校验位。</p><hr><h4 id="des结构"><a class="markdownIt-Anchor" href="#des结构"></a> DES结构</h4><p>  <code>DES</code>结构是被称为<code>feistel</code>的网络结构。如下图</p><p><img src="/2023/06/18/chipher/aes/rsa/204920/DES%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt="feistel网络结构.png"></p><p>从上图可知, 右侧<code>32bits</code>作为轮函数的输入,轮函数的输出和左侧<code>32bits</code>进行<code>XOR</code>运算并输出加密结果, 但是输入端右侧<code>32bits</code>并未进行加密, 属于明文， 因此是无法做到机密性的。 历史上<code>DES</code>算法是利用多重<code>feistel</code>网络结构来构成, 如下:</p><p><img src="/2023/06/18/chipher/aes/rsa/204920/DES%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt="DES网络结构.png"></p><p>经过三轮交换顺序后, 即可以对右侧<code>32bits</code>进行加密。当然解密也就是相当于其的逆运算, 这里不做讲解。</p><hr><h4 id="3des"><a class="markdownIt-Anchor" href="#3des"></a> 3DES</h4><p>  <code>3DES</code>是基于<code>DES</code>密钥空间太小被破解后, 为了增强<code>DES</code>的密钥强度, 再次基础上将<code>DES</code>重复3次所得到的一种密码算法。其密钥空间也有原先的<code>56bits</code>扩展到<code>168bits</code>, 不过现在虽然还在使用，但是已经应用很少。</p><p><img src="/2023/06/18/chipher/aes/rsa/204920/3DES%E7%AE%97%E6%B3%95%E6%A1%86%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="3DES算法框图.png"></p><p>  <code>3DES</code>设计是对下兼容的, 也就是说, <code>3DES</code>是可以兼容<code>DES</code>加密的, 如上图, 如果<code>DES</code>密钥全部使用同一个密钥, 其效果就相当于<code>DES</code>加密。由此可知, <code>3DES</code>从<code>DES</code>上重复扩展了密钥强度, 但是这也让算法变得更加低效。</p><hr><h4 id="aes"><a class="markdownIt-Anchor" href="#aes"></a> AES</h4><p>  由于<code>DES</code>不安全, 以及<code>3DES</code>算法很低效等各类原因, 安全界急需一个更加高效安全的算法, <code>AES</code>作为对称加密界的新秀由此诞生。</p><p>如下是<code>AES</code>算法的原理:</p><p><img src="https://etcfly.top/Images/picture/crypt/AES/AES%E5%8A%A0%E5%AF%86%E5%8A%A8%E7%94%BB.gif" srcset="/img/loading.gif" lazyload alt="AES加密动画.gif"></p><ul><li><a target="_blank" rel="noopener" href="https://formaestudio.com/portfolio/aes-animation/">Rijndael (AES) Animation</a></li></ul><p>密码算法分为<strong>分组密码</strong>和<strong>流密码</strong>:</p><ul><li>分组密码: 将数据分为一组一组并分别加密。(并发性处理更快)</li><li>流密码: 对数据流进行连续处理的一类算法。</li></ul><p>这里<code>AES</code>属于分组密码一类, 分组密码又分为很多模式, 主要分为如下5类:</p><ul><li><code>ECB</code>模式(电子密码本模式)</li><li><code>CBC</code>模式(密码分组链接模式)</li><li><code>CFB</code>模式(密文反馈模式)</li><li><code>OFB</code>模式(计数器模式)</li></ul><p>如下将分别讲解这五种模式。</p><hr><h5 id="ecb模式"><a class="markdownIt-Anchor" href="#ecb模式"></a> ECB模式</h5><p>  <code>ECB</code>模式加密是分组加密模型中最简单的一种, 其数据并发加密速度最快, 但是由于其没有隐藏密文和明文的对应关系(相同的明文其输出的密文相同), 攻击者可以对密文的分组顺序进行调换而不会出错， 因此其存在一定的风险。<code>ECB</code>模式的加解密模型如下:</p><p><img src="/2023/06/18/chipher/aes/rsa/204920/ECB%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" lazyload alt="ECB加密模型.png"></p><hr><h5 id="cbc模式"><a class="markdownIt-Anchor" href="#cbc模式"></a> CBC模式</h5><p>  <code>CBC</code>模式与<code>ECB</code>模式不同, 其前一个分组的密文参与后续分组的加密处理, 因此相对<code>ECB</code>模式而言, 其不存在调换密文顺序而无法发现的问题, 任意的密文改动都会影响最终的输出, 正因为前一个密文会参与后一个分组的加密, 因此其具有如下两个特点:</p><ul><li>与<code>ECB</code>相比, 加密速度较慢, 无法并发处理</li><li>不能作为流密码(因为单个分组错误会影响后续分组的加密)</li></ul><p>如下是CBC加密的模型:</p><p><img src="/2023/06/18/chipher/aes/rsa/204920/CBC%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" lazyload alt="CBC加密模型.png"></p><p>针对<code>CBC</code>的攻击也有很多, 最直观的莫过于首个明文分组对应比特反转, 如果密文对应位进行相同反转并不影响密文的结果，其实内容已经改变而无法发现。其次通常初始化的向量需要使用真随机数来初始化, 计算机上一般无法获取真随机数, 所以大多数使用密码上安全的伪随机数来替代(不可预测性)。</p><hr><h5 id="cfb模式"><a class="markdownIt-Anchor" href="#cfb模式"></a> CFB模式</h5><p>  <code>CFB</code>和<code>OFB</code>属于流密码一类, 一般用于数据流的加密, 如视频流等等, 这类数据的特点是偶尔会掉帧, 加密和解密不应该过度依赖前一次的状态, 否则某一帧数据的错乱或者丢失将导致整个流数据无法解密。</p><p>如下是<code>CFB</code>模式的模型:</p><p><img src="/2023/06/18/chipher/aes/rsa/204920/CFB%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" lazyload alt="CFB加密模型.png"></p><p>如上图, <code>CFB</code>模型克服了<code>CBC</code>模型的如下几个缺点:</p><ul><li>明文分组和初始化向量同样<code>bit</code>翻转而无法感知的问题</li><li>前面分组密文的错乱不影响后续密文的解密</li><li>虽然无法支持并行加密, 但是可以支持并行解密, 而<code>CBC</code>模式是无法做到的。</li></ul><p>同样<code>CFB</code>模式也引入新的问题, 攻击者可以在输出密文中插入特定的密文分组但是接受者无法感知是分组传输错误还是被攻击, 而导致一些攻击性数据被接收处理。</p><hr><h5 id="ofb模式"><a class="markdownIt-Anchor" href="#ofb模式"></a> OFB模式</h5><p>  前面介绍的这些模式, 除了<code>ECB</code>模式外, 都无法进行并行加密, 而<code>OFB</code>模式可以进行并行加解密, 并且兼顾了<code>OFB</code>模式前面密文错误不影响后续密文解密的优点。</p><p><img src="/2023/06/18/chipher/aes/rsa/204920/OFB%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" lazyload alt="OFB加密模型.png"></p><p><code>OFB</code>模式虽然解决了某些方面<code>CFB</code>无法并发的问题, 但是却引入了一个新的问题。假设初始化向量通过加密输出的结果和输入前恰好相等, 那么后续所有加密的密钥将全部相同, 这就等价使用了<code>ECB</code>模式。</p><hr><h5 id="ctr模式"><a class="markdownIt-Anchor" href="#ctr模式"></a> CTR模式</h5><p>  为了解决<code>OFB</code>模式密钥加密后相等的问题, 后续又引入了<code>CTR</code>模式, <code>CTR</code>模式每一个分组对应一个逐次累加的计数器, 因此密钥都不一样。如下图:</p><p><img src="/2023/06/18/chipher/aes/rsa/204920/CTR%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" lazyload alt="CTR加密模型.png"></p><p>除了上述解决<code>OFB</code>模式密钥加密后相等的问题, <code>CTR</code>模式同时解决了<code>CFB</code>模式攻击者可以插入密文的问题, 这里这个问题在<code>OFB</code>和<code>CTR</code>中同样被解决。</p><hr><h5 id="gcm-模式"><a class="markdownIt-Anchor" href="#gcm-模式"></a> GCM 模式</h5><p>  <code>GCM</code>与之前的模式不同, 前面的几种模式仅实现了加密, 那么如何确定加密过的消息是完整的呢？<code>GCM</code>通过<code>CTR</code>改进而来, 并通过一个叫<code>GMAC</code>的方法实现了消息完整性的检测。具体原理图如下:</p><p><img src="https://etcfly.top/Images/picture/crypt/AES/GCM%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E6%A1%86%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="GCM加密原理框图.png"></p><ul><li><code>Ek</code>: 使用秘钥<code>k</code>对输入做对称加密运算</li><li><code>XOR</code>: 异或运算</li><li><code>Mh</code>: 将输入与秘钥<code>h</code>在有限域<code>GF(2^128)</code>上做乘法。</li></ul><p>关于<code>GMAC</code>( <code>Galois message authentication code mode</code>, 伽罗瓦消息验证码), <code>GMAC</code>就是利用伽罗华域(<code>Galois Field</code>，<code>GF</code>，有限域)乘法运算来计算消息的<code>MAC</code>值。假设秘钥长度为<code>128bits</code>, 当密文大于<code>128bits</code>时，需要将密文按<code>128bits</code>进行分组。应用流程如下图：</p><p><img src="https://etcfly.top/Images/picture/crypt/AES/GMAC%E6%A1%86%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="GMAC框图.png"></p><hr><h5 id="ccm-模式"><a class="markdownIt-Anchor" href="#ccm-模式"></a> CCM 模式</h5><p>  <code>CCM</code>和<code>GCM</code>类似, 也是结合了认证和加密双重功能的加密算法, 并且二者都是基于<code>CTR</code>加密改进发展而来, 只不过认证方面<code>GCM</code>采用的<code>GMAC</code>, 而<code>CCM</code>采用的<code>CMAC(CBC-MAC)</code>, 具体看如下图:</p><p><img src="https://etcfly.top/Images/picture/crypt/AES/CCM%E5%8A%A0%E5%AF%86%E6%A1%86%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="CCM加密框图.png"></p><p>同理, 解密框图如下:</p><p><img src="https://etcfly.top/Images/picture/crypt/AES/CCM%E8%A7%A3%E5%AF%86%E6%A1%86%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="CCM解密框图.png"></p><p><img src="https://etcfly.top/Images/picture/crypt/AES/CCM_B0%E6%9E%84%E9%80%A0%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="CCM B0构造图.png"></p><hr><h5 id="各模式对照表"><a class="markdownIt-Anchor" href="#各模式对照表"></a> 各模式对照表</h5><p><img src="/2023/06/18/chipher/aes/rsa/204920/%E5%90%84%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="各加密模式对比表.png"></p><hr><h3 id="非对称加密"><a class="markdownIt-Anchor" href="#非对称加密"></a> 非对称加密</h3><p>  通过对对称加密的学习, 我们知道对称加密可以很好对明文数据进行加密, 但是却存在一个问题, 发送者和接收者如何同步加解密的密钥, 对称加密的特点是发送和接收共用一个公共密钥, 为了保证信息的机密性, 这个密钥是不允许被第三者知道的, 那密钥如何通过网络进行安全配送呢？正常情况如果通过网络传输, 是存在风险, 如下:</p><p><img src="/2023/06/18/chipher/aes/rsa/204920/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%AF%86%E9%92%A5%E7%9B%91%E5%90%AC%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt="对称加密密钥监听结构.png"></p><p>那有什么方法能够在只有通信双方知道的情况下共享密钥吗？有, 目前主流的两个方法:</p><ul><li>采用公钥加密来传输</li><li>采用 <code>Diffie-Hellman</code> 双方共同来生成</li></ul><h4 id="rsa公钥加密"><a class="markdownIt-Anchor" href="#rsa公钥加密"></a> RSA公钥加密</h4><p>这里我们先从公钥加密说起, 公钥加密又称为(非对称加密), 这是由于加密的双方采用不同的密钥结构, 整个加密结构看起来是不对称的。</p><p>公钥加密具有几个重要的性质这里需要先明确一下</p><ul><li>私钥加密的消息只有公钥可以解密</li><li>公钥加密的消息只有私钥可以解密</li><li>公钥加密的消息公钥无法解密</li><li>私钥加密的消息私钥无法解密</li></ul><p>  因此, 我们可以创建出这样一种模型, 假设<code>Alice</code>和<code>Bob</code>需要通信, <code>Bob</code>和<code>Alice</code>需要进行密钥同步, 那么<code>Bob</code>或者<code>Alice</code>一方可以先生成一个密钥对, 将私钥保存起来, 将公钥分享出去, 这样使用公钥加密的消息只有持有私钥的人才可以解密, 第三方监听是无法解密的, 从而保证消息的机密性。</p><p><img src="/2023/06/18/chipher/aes/rsa/204920/%E5%8F%8C%E6%96%B9%E5%88%A9%E7%94%A8%E5%85%AC%E9%92%A5%E4%BA%A4%E6%8D%A2%E6%95%B0%E6%8D%AE.png" srcset="/img/loading.gif" lazyload alt="双方利用公钥交换数据.png"></p><p>由此可知, 公钥密码算法解决了密钥配送的问题, 但是又引入了一个新的问题, 那就是如何确定公钥确实来自通信的另一方而不是第三者冒充。(第三者冒充的方式又称为中间人攻击), 如下图:</p><p><img src="/2023/06/18/chipher/aes/rsa/204920/%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.png" srcset="/img/loading.gif" lazyload alt="公钥加密的中间人攻击.png"></p><p>中间人攻击很多时候是无法避免的, 这就涉及到公钥认证的问题，我们后续再说。上文我们提到对称加密, 那对称加密和非对称加密的密码强度如何呢？这里做一个对比, 数据来源权威机构数据:</p><table><thead><tr><th style="text-align:left">对称加密AES</th><th style="text-align:left">公钥密码RSA</th></tr></thead><tbody><tr><td style="text-align:left"><code>128bits</code></td><td style="text-align:left"><code>3072bits</code></td></tr><tr><td style="text-align:left"><code>192bits</code></td><td style="text-align:left"><code>7680bits</code></td></tr><tr><td style="text-align:left"><code>256bits</code></td><td style="text-align:left"><code>15360bits</code></td></tr></tbody></table><p>表格可知, 同样位数的加密, <code>AES</code>加密的强度是高于<code>RSA</code>的。与此同时, 对称加密具备的并行加密以及解密使得其处理速度要高于非对称加密, 因此在实际通信加密中, 一般采用非对称加密来协商公共密钥, 避免密钥被泄漏， 采用对称加密来加密通信的方式。</p><hr><p>  <code>RSA</code>加密的原理可以用如下公式表示:</p><ul><li>加密: <code>$C = M^E \bmod N$</code></li><li>解密: <code>$M = C^D \bmod N$</code></li></ul><blockquote><ul><li><code>$M$</code>: 明文消息</li><li><code>$C$</code>: 密文</li><li><code>$(E, N)$</code>: 组成公钥</li><li><code>$(D, N)$</code>: 组成私钥</li></ul></blockquote><p>具体如何求解和生成公钥和私钥, 请参考<code>openssl</code>或相关密码书籍。通过上面展示的是最原始的<code>RSA</code>密码模型, 但是其存在几个问题。</p><ul><li>加密公式中, 由于消息(<code>M</code>)是作为幂运算的底数, 因此, 如果<code>M</code>值较小, 导致<code>M^E</code> &lt; <code>N</code>, 加密过程将变成<code>C = M^E</code>, 由于<code>E</code>作为公钥的一部分被公开, 那么借助工具很容易破解密文并获取明文<code>M</code>, 因此<code>RSA</code>加密短小消息是不安全的。需要进行填充。</li><li>经典<code>RSA</code>模型每一个输入对应一个输出, 也就是说相同的输入会对应相同的输出, 如果输入样本较少, 也可以根据对应关系找到密文。因此需要解决, 短明文也可以获取高强度的密码安全性。</li></ul><p>基于上面的两个缺点, 密码学家获得如下启发:</p><ul><li>对短的明文消息进行填充, 使得明文消息<code>M</code>具备一定的长度(足够大)</li><li>为了避免短小的明文加密, 攻击者通过收集对应关系找到明文, 在明文中加入随机数, 保证即使相同的明文, 对应的密文也不一样。</li></ul><p>通过这两点, 密码学家在<code>PKCS#1</code>(公钥加密标准)的<code>V1.5</code>和<code>v2.1</code>中分别引入了不同的填充方式。在<code>v1.5</code>中填充方式被成为<code>PKCS#1 V15</code>填充, <code>v2.1</code>中填充方式采用<code>oeap</code>填充。目前已知<code>PKCS#1 V15</code>容易被<a target="_blank" rel="noopener" href="https://asecuritysite.com/encryption/c_c3"> Bleichenbacher</a> 方法攻击, 因此推荐使用<code>OEAP</code>方式来填充明文。</p><p><strong>参考资料</strong></p><ul><li><a target="_blank" rel="noopener" href="https://security.stackexchange.com/questions/183179/what-is-rsa-oaep-rsa-pss-in-simple-terms/183330#183330?newreg=61750f13f33d4bbfbda457972ac18945">What is RSA OAEP &amp; RSA PSS in simple terms</a></li><li><a target="_blank" rel="noopener" href="https://medium.com/asecuritysite-when-bob-met-alice/whats-so-special-about-pkcs-1-v1-5-and-the-attack-that-just-won-t-go-away-51ccf35d65b7">What’s So Special About PKCS#1 v1.5? And The Attack That Just Won’t Go Away!</a></li><li><a target="_blank" rel="noopener" href="https://archiv.infsec.ethz.ch/education/fs08/secsem/Bleichenbacher98.pdf">Bleichenbacher’s attack</a></li></ul><hr><h4 id="diffie-hellman"><a class="markdownIt-Anchor" href="#diffie-hellman"></a> Diffie-Hellman</h4><p>  <code>Diffie-Hellman</code>是现阶段一种常用的密钥共享方法, 现在很多主流<code>TLS</code>都是使用(<code>Diffie-Hellman</code>或者<code>RSA</code>交换密钥), 使用这种算法， 通信双方仅通过交换一些可以公开的信息就能够生成出共享的秘密数字， 而这一秘密数字就可以被用作对称密码的密钥。其共享原理如下:</p><p><img src="https://etcfly.top/Images/picture/crypt/RSA/Diffle-Hellman%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" lazyload alt="Diffle-Hellman密钥交换模型.png"></p><p>主要步骤:</p><ul><li><code>Alice</code>和<code>Bob</code>公开分享<code>G、P</code>参数。</li><li><code>Alice</code>生成随机数<code>A</code>, 并通过<code>$G^A \bmod P$</code>公式计算出结果共享给<code>Bob</code></li><li><code>Bob</code>通过同样的方式生成随机数<code>B</code>, 并通过公式算出结果, 并共享结果。</li><li>双方生成共享密钥。</li></ul><p>需要注意的是, <code>Diffle-Hellman</code>算法一般<code>G</code>和<code>P</code>是固定的, <code>G</code>和<code>P</code>生成效率较低。一般采用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl dhparam 2048 -2<br></code></pre></td></tr></table></figure><p>根据私钥生成的方式, <code>DH</code>算法分为两种实现:</p><ul><li><code>static DH</code> 算法，这个是已经被废弃了</li><li><code>DHE</code> 算法，现在常用的</li></ul><p>一般 <code>static DH</code> 算法一方的私钥是静态的，也就说每次密钥协商的时候有一方私钥都是一样的(一般是服务器方固定，即 <code>a</code> 不变) 客户端的私钥则是随机生成的。</p><p>于是，<code>DH</code> 交换密钥时就只有客户端的公钥是变化，而服务端公钥是不变的，那么随着时间延长，黑客就会截获海量的密钥协商过程的数据，因为密钥协商的过程有些数据是公开的，黑客就可以依据这些数据暴力破解出服务器的私钥，然后就可以计算出会话密钥了，于是之前截获的加密数据会被破解，所以 <code>static DH</code> 算法不具备前向安全性。</p><p>既然固定一方的私钥有被破解的风险，那么干脆就让双方的私钥在每次密钥交换通信时，都是随机生成的、临时的，这个方式也就是 <code>DHE</code> 算法，<code>E</code> 全称是 <code>ephemeral</code>（临时性的）。</p><p>所以，即使有个牛逼的黑客破解了某一次通信过程的私钥，其他通信过程的私钥仍然是安全的，因为每个通信过程的私钥都是没有任何关系的，都是独立的，这样就保证了「<strong>前向安全</strong>」。</p><p>根据上面基于密钥我们可以将算法进行一个分类:</p><ul><li>静态<code>DH</code>算法</li><li><code>DHE</code>算法(提供向前安全)</li></ul><p>我们还可以按照计算方式进行分类:</p><ul><li>模指数<code>DH</code>算法</li><li>椭圆曲线<code>DH</code>算法(<code>ECDH</code>算法)</li></ul><p>模指数是指：指数运算+取模运算, 前面介绍的<code>Diffle-Hellman</code>算法就是模指数算法, 而<code>SSL/TLS</code>采用的通常是椭圆曲线<code>DH</code>算法(<code>ECDH</code>算法), 我们继续讲述。</p><hr><h4 id="ecdhe"><a class="markdownIt-Anchor" href="#ecdhe"></a> ECDHE</h4><p>  <code>DHE</code> 算法由于计算性能不佳，因为需要做大量的乘法，为了提升 <code>DHE</code> 算法的性能，所以就出现了现在广泛用于密钥交换算法 —— <code>ECDHE</code> 算法。</p><p><code>ECDHE</code> 算法是在 <code>DHE</code> 算法的基础上利用了 <code>ECC</code> 椭圆曲线特性，可以用更少的计算量计算出公钥，以及最终的会话密钥。</p><p>小红和小明使用 <code>ECDHE</code> 密钥交换算法的过程：</p><ul><li><p>双方事先确定好使用哪种椭圆曲线，和曲线上的基点 <code>$G$</code>，这两个参数都是公开的；</p></li><li><p>双方各自随机生成一个随机数作为私钥<code>$d$</code>，并与基点 <code>$G$</code>相乘得到公钥<code>$Q$</code>（<code>$Q = dG$</code>），此时小红的公私钥为 <code>$Q_1$</code> 和 <code>$d_1$</code>，小明的公私钥为 <code>$Q_2$</code> 和 <code>$d_2$</code>；</p></li><li><p>双方交换各自的公钥，最后小红计算点<code>$(x_1，y_1) = d_1 * Q_2$</code>，小明计算点<code>$(x2，y2) = d_2 * Q_1$</code>，由于椭圆曲线上是可以满足乘法交换和结合律，所以 <code>$d_1 * Q_2 = d_1 * d_2 * G = d_2 * d_1 * G = d_2 * Q_1$</code> ，因此双方的 <code>$x$</code> 坐标是一样的，所以它是共享密钥，也就是会话密钥。</p></li></ul><p>这个过程中，双方的私钥都是随机、临时生成的，都是不公开的，即使根据公开的信息（椭圆曲线、公钥、基点 <code>$G$</code>）也是很难计算出椭圆曲线上的离散对数（私钥）。</p><p><strong>不同算法对比</strong>:<br><img src="https://etcfly.top/Images/picture/crypt/ECDH/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94.png" srcset="/img/loading.gif" lazyload alt></p><ul><li><strong><u>根据相关数据表明, <code>ECDH</code>椭圆曲线比<code>DH</code>密钥交互要快<code>10</code>倍</u></strong></li></ul><p>如上表，椭圆曲线可以用于 <code>3</code> 个方面：</p><ul><li>基于椭圆曲线的公钥密码</li><li>基于椭圆曲线的数字签名</li><li>基于椭圆曲线的密钥交换</li></ul><p><strong>参考链接</strong>:</p><ul><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaolincoding/p/14318338.html">图解 ECDHE 密钥交换算法</a></li><li><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/1171611">【密码学】非对称加密算法 - ECDH</a></li><li><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_13291771/3984396">SSL/TLS中的DH算法、DHE算法、 ECDHE算法介绍</a></li></ul><hr><h4 id="ecdsa"><a class="markdownIt-Anchor" href="#ecdsa"></a> ECDSA</h4><p>  椭圆曲线密码学（<code>ECC，Elliptic Curve Cryptogphay</code>）是一种流行的非对称加密算法, 在将 <code>ECC</code> 作为双钥系统使用时，针对不同的应用场景，会涉及到不同的算法, 常见的有:</p><ul><li>在加密和解密时使用的椭圆曲线集成加密框架（<code>ECIES，Elliptic Curve Integrated Encryption Schema</code>）</li><li>用于协商和交换公共密钥的椭圆曲线 <code>Diffie-Hellman</code> 密钥交换算法（<code>ECDH，Elliptic Curve Diffie-Hellman Key Exchange</code>）</li><li>用于生成和验证数字签名的椭圆曲线数字签名算法（<code>ECDSA，Elliptic Curve Digital Signature Algorithm</code>）</li></ul><p><strong>签名</strong>:</p><p>用私钥 <code>$a$</code> 对消息 <code>$m$</code> 签名，得到的结果是两个整数 <code>$(r,s)$</code>，计算过程如下:</p><ul><li>随机生成临时私钥 <code>k</code>，并计算其对应的公钥<code>$K = k * G = (x_&#123;k&#125;, y_&#123;k&#125;)$</code></li><li>计算 <code>$r=x_&#123;K&#125; \bmod n$</code>，若 <code>$r$</code> 为 0，则回到第一步</li><li>计算消息 <code>$m$</code> 的哈希 <code>$e=hash(m)$</code>，并将 <code>$e$</code> 的二进制序列转成一个整数</li><li>计算 <code>$s=k^&#123;−1&#125;(e + r * a) \bmod n$</code>，若 <code>$s$</code> 为 <code>0</code>，则回到第一步</li><li>得到签名 <code>$(r,s)$</code></li></ul><p>如果每次签名都使用相同的 <code>$k$</code>，当知道了消息 <code>$e_1$</code>,<code>$e_2$</code>和签名<code>$(r_1, s_1)$</code>、<code>$(r_2, s_2)$</code>时, 有:</p><ul><li><code>$r_1=r_2$</code>, 因为<code>$k$</code>相等</li><li>根据 <code>$s$</code> 的定义，有 <code>$s_1 − s_2 = k^&#123;−1&#125; (e_1 − e_2) \bmod n$</code></li><li>将上式两边同时乘以 <code>$k$</code> 再除以 <code>$(s_1 − s_2)$</code>，有 <code>$k=(s_1 − s_2)^&#123;−1&#125; (e_1 − e_2) \bmod n$</code></li></ul><p>这样就得到了 <code>$k$</code>，再根据 <code>$s=k^&#123;−1&#125; (e + r * a) \bmod n$</code>，从而反推出<code>$a=r^&#123;−1&#125; (s * k − e) \bmod n$</code><br>。类似的攻击方法在 <code>$k$</code> 值可预测时也能使用。所以请务必注意，每次签名时使用的 <code>$k$</code>，都需要保证绝对私密且生成时足够随机，以保证私钥 <code>$a$</code> 的安全。</p><p><strong>验签</strong>：</p><p>用公钥 <code>$A$</code> 和消息 <code>$m$</code> 验证签名 <code>$(r,s)$</code>，过程如下。</p><ul><li>计算消息 <code>$m$</code> 的哈希 <code>$e=hash(m)$</code>，并将 <code>$e$</code> 的二进制序列转成一个整数</li><li>计算整数 <code>$u_1 = s^&#123;−1&#125; * e \bmod n$</code></li><li>计算整数 <code>$u_2 = s^&#123;−1&#125; * r \bmod n$</code></li><li>计算点 <code>$P=u_1 * G + u_2 * A =(x_&#123;P&#125;, y_&#123;P&#125;)$</code></li><li>当且仅当 <code>$r = x_&#123;P&#125; \bmod n$</code> 时，验签成功</li></ul><p><strong>参考资料</strong></p><ul><li><a target="_blank" rel="noopener" href="https://aaron67.cc/2020/09/30/ecdsa/">椭圆曲线数字签名算法</a></li><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/HachikoT/p/15991277.html">ECDSA 算法</a></li><li><a target="_blank" rel="noopener" href="https://andrea.corbellini.name/2015/05/30/elliptic-curve-cryptography-ecdh-and-ecdsa/">Elliptic Curve Cryptography: ECDH and ECDSA</a></li></ul><hr><h3 id="pkcs"><a class="markdownIt-Anchor" href="#pkcs"></a> PKCS</h3><p>  <code>PKCS</code>为公钥加密标准(<code>Public Key Cryptography Standards</code>), 这一组公钥加密标准从20世纪90年代开始设计并发布。常用标准如下:</p><table><thead><tr><th style="text-align:left">标准</th><th style="text-align:center">说明</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left"><code>PKCS#1</code></td><td style="text-align:center"><code>RSA</code>密码标准</td><td style="text-align:left">定义 <code>RSA</code> 公钥和私钥（以明文形式编码的<code>ASN.1</code> ）的数学属性和格式，以及用于执行 <code>RSA</code> 加密、解密以及生成和验证签名的 基本算法和编码/填充方案。</td></tr><tr><td style="text-align:left"><code>PKCS #3</code></td><td style="text-align:center"><code>Diffie-Hellman</code> 密钥协议标准</td><td style="text-align:left">一种加密协议，允许互不了解的两方通过不安全的通信通道共同建立共享密钥</td></tr><tr><td style="text-align:left"><code>PKCS#5</code></td><td style="text-align:center">基于口令的加密标准</td><td style="text-align:left">描述了使用由口令生成的密钥来加密8位位组串并产生一个加密的8位位组串的方法。<code>PKCS#5</code> 可以用于加密私钥，以便于密钥的安全传输</td></tr><tr><td style="text-align:left"><code>PKCS#7</code></td><td style="text-align:center">密码消息语法标准</td><td style="text-align:left">使用密码算法的数据规定了通用语法，比如数字签名和数字信封。<code>PKCS#7</code>提供了许多格式选项，包括未加密或签名的格式化消息、已封装（加密）消息、已签名消息和既经过签名又经过加密的消息。</td></tr><tr><td style="text-align:left"><code>PKCS#8</code></td><td style="text-align:center">私钥信息语法标准</td><td style="text-align:left">定义了私钥信息语法和加密私钥语法</td></tr><tr><td style="text-align:left"><code>PKCS#9</code></td><td style="text-align:center">可选属性类型</td><td style="text-align:left"><code>PKCS#9</code>定义了<code>PKCS#6</code>扩展证书、<code>PKCS#7</code>数字签名消息、<code>PKCS#8</code>私钥信息和<code>PKCS#10</code>证书签名请求中要用到的可选属性类型。已定义的证书属性包括<code>E-mail</code>地址、无格式姓名、内容类型、消息摘要、签名时间、签名副本（<code>counter signature</code>）、质询口令字和扩展证书属性</td></tr><tr><td style="text-align:left"><code>PKCS#10</code></td><td style="text-align:center">证书请求语法标准</td><td style="text-align:left">定义了证书请求的语法。证书请求包含了一个唯一识别名、公钥和可选的一组属性，它们一起被请求证书的实体签名</td></tr><tr><td style="text-align:left"><code>PCKS#11</code></td><td style="text-align:center">密码令牌接口标准</td><td style="text-align:left">定义加密令牌通用接口的<code>API</code>,通常用于单点登录、公钥加密和磁盘加密系统</td></tr><tr><td style="text-align:left"><code>PCKS#12</code></td><td style="text-align:center">个人信息交换语法标准</td><td style="text-align:left">定义了个人身份信息（包括私钥、证书、各种秘密和扩展字段）的格式</td></tr></tbody></table><p><code>X.509</code>作为现在流行的公钥加密证书被广泛使用, 其采用的就是<code>ASN.1</code>定义的<code>DER</code>编码标准, 常见的证书编码格式有:</p><ul><li><code>DER</code></li><li><code>PEM</code></li></ul><p>具体其他可参考 “证书的类型和格式” 一节, 关于如何进行证书的签名, 以及如何生成<code>RSA</code>密钥对等可参考 “<code>openssl</code>基础” 一节。关于对称加密和非对称加密相关内容就讲到这里, 后续如果有其他扩展在进行补充。</p><hr><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><ul><li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/26822106/">图解密码技术</a></li><li><a target="_blank" rel="noopener" href="https://freecomputerbooks.com/Practical-Cryptography-for-Developers.html">实用密码学</a></li><li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7227821347715809317">RSA及Openssl</a></li><li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/PKCS">PKCS</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/KXue0703/article/details/130437942">CCM浅析</a></li><li><a target="_blank" rel="noopener" href="https://www.e-learn.cn/topic/3757576">AES中的ECB、CTR、MAC、GMAC、GCM</a></li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" class="category-chain-item">密码学</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%8E%9F%E5%88%9B/">#原创</a> <a href="/tags/AES-RSA/">#AES - RSA</a></div></div><div class="license-box my-3"><div class="license-title"><div>对称加密和非对称加密</div><div>http://example.com/2023/06/18/chipher/aes/rsa/204920/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>EtcFly</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年6月18日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2024年3月5日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2023/06/18/chipher/md5-sha/205443/" title="消息摘要和消息认证方法"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">消息摘要和消息认证方法</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2023/06/18/chipher/wireshake-tls/204135/" title="使用wireshake抓取tls交互"><span class="hidden-mobile">使用wireshake抓取tls交互</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="waline"></div><script type="text/javascript">Fluid.utils.loadComments("#waline",(function(){Fluid.utils.createCssLink("https://lib.baomitu.com/waline/2.14.1/waline.min.css"),Fluid.utils.createScript("https://lib.baomitu.com/waline/2.14.1/waline.min.js",(function(){var i=Object.assign({serverURL:"https://etcfly.top:14000/",path:"window.location.pathname",meta:["nick","mail","link"],requiredMeta:["nick"],lang:"zh-CN",emoji:["https://unpkg.com/@waline/emojis@1.1.0/qq"],dark:'html[data-user-color-scheme="dark"]',wordLimit:0,pageSize:10},{el:"#waline",path:window.location.pathname});Waline.init(i),Fluid.utils.waitElementVisible("#waline .vcontent",()=>{var i="#waline .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://github.com/EtcFly" target="_blank" rel="nofollow noopener"><span>Copyright</span></a> <i class="iconfont icon-copyright"></i> <a href="https://etcfly.top:14100/share/yqTLFDlP/%E4%BB%97%E5%89%91%E8%B5%B0%E5%A4%A9%E6%B6%AF" target="_blank" rel="nofollow noopener"><span>2018-2024 EtcFly</span></a><div style="font-size:.85rem"><span>总访问量 <span style="color:#000" id="PVstatic">0</span> 次&nbsp</span> <span>总访客数 <span style="color:#000" id="UVstatic">0</span> 人&nbsp</span> <span>当前在线 <span style="color:#000" id="ACTstatic">0</span> 人&nbsp</span><script src="https://etcfly.top:14200/statistics" defer></script></div><div style="font-size:.85rem"><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="js/duration.js"></script></div></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener"></a> </span><span><a href="http://beian.miit.gov.cn/2023000858" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" alt="police-icon"> <span>浙ICP备2023000858号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/jquery.min.js"></script><script src="/live2d-widget/autoload.js"></script><script src="/js/star.js"></script><script src="/js/ribbon.min.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>