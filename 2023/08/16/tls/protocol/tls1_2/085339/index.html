<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="EtcFly"><meta name="keywords" content=""><meta name="description" content="版权归作者所有, 转载请保留该部分声明。本文作者：EtcFly原文地址：https:&#x2F;&#x2F;etcfly.top              简介   由于HTTP等应用层协议传输数据采用明文形式, 数据内容很容易被窃听和篡改, 对于一些私密性数据产生严重的安全威胁, 这里主要有几个问题:  无法判断通讯双方的身份信息 数据传输明文很容易被窃听 数据传输过程中是否完整(有没有被"><meta property="og:type" content="article"><meta property="og:title" content="tls1.2协议原理"><meta property="og:url" content="http://example.com/2023/08/16/tls/protocol/tls1_2/085339/"><meta property="og:site_name" content="仗剑走天涯"><meta property="og:description" content="版权归作者所有, 转载请保留该部分声明。本文作者：EtcFly原文地址：https:&#x2F;&#x2F;etcfly.top              简介   由于HTTP等应用层协议传输数据采用明文形式, 数据内容很容易被窃听和篡改, 对于一些私密性数据产生严重的安全威胁, 这里主要有几个问题:  无法判断通讯双方的身份信息 数据传输明文很容易被窃听 数据传输过程中是否完整(有没有被"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/chipher.png"><meta property="article:published_time" content="2023-08-16T08:53:39.000Z"><meta property="article:modified_time" content="2024-03-05T03:41:03.000Z"><meta property="article:author" content="EtcFly"><meta property="article:tag" content="原创"><meta property="article:tag" content="TLS1.2"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/img/chipher.png"><title>tls1.2协议原理 仗剑走天涯</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/fluid-extention.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:4},web_analytics:{enable:!0,follow_dnt:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"3AEufnWAJdp8cFODp1DXvrQU-MdYXbMMI",app_key:"mGJiL6xVvYv21ygqfynJoCyO",server_url:null,path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Strive For Dream</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="tls1.2协议原理"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-08-16 08:53" pubdate>2023年8月16日 早上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 24k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 202 分钟 </span><span id="vvdpost_container_page_pvuv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="vvdpost_value_page_pv">0</span> 次&nbsp&nbsp <i class="iconfont icon-users" aria-hidden="true"></i> <span id="vvdpost_value_page_uv">0</span> 人</span><script>console.log(window.location.pathname);var httpRequest=new XMLHttpRequest;httpRequest.open("POST","https://etcfly.top:14200/poststats",!0),httpRequest.setRequestHeader("Content-type","application/json"),httpRequest.send(JSON.stringify(window.location.pathname)),httpRequest.onreadystatechange=function(){if(4==httpRequest.readyState&&200==httpRequest.status){var e=httpRequest.responseText,t=JSON.parse(e);console.log(t.pv);var o=document.querySelector("#vvdpost_container_page_pvuv");if(console.log(o),o){var n=document.querySelector("#vvdpost_value_page_pv");console.log(n);var s=document.querySelector("#vvdpost_value_page_uv");console.log(s),s&&s&&(n.innerText=t.pv,s.innerText=t.uv,o.style.display="inline")}}}</script></div></div></div></div></div></div><script async src="https://etcfly.top:14100/script.js" data-website-id="1a5c096d-21e5-4556-99b0-28c810c9c868"></script></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">tls1.2协议原理</h1><p class="note note-info">本文最后更新于：2024年3月5日 凌晨</p><div class="markdown-body"><div class="note note-success"><p>版权归作者所有, 转载请保留该部分声明。<br>本文作者：EtcFly<br>原文地址：<a target="_blank" rel="noopener" href="https://etcfly.top">https://etcfly.top</a></p></div><hr><h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3><p>  由于<code>HTTP</code>等应用层协议传输数据采用明文形式, 数据内容很容易被窃听和篡改, 对于一些私密性数据产生严重的安全威胁, 这里主要有几个问题:</p><ul><li>无法判断通讯双方的身份信息</li><li>数据传输明文很容易被窃听</li><li>数据传输过程中是否完整(有没有被篡改)</li></ul><p><code>TLS</code>协议通过在应用层协议和<code>TCP</code>数据层引入一个<code>TLS</code>安全层, 保证了数据安全。</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/TLS%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" lazyload alt="TLS分层模型.png"></p><p><code>TLS</code>前身是大名鼎鼎的<code>SSL</code>, 起初由网景公司开发, 最初<code>SSL</code>主要版本有(<code>SSL1.0</code>, <code>SSL2.0</code>, <code>SS3.0</code>), 后面<code>TLS</code>为了避免与<code>SSL</code>的版权纠纷, 将协议更名为<code>TLS</code>, 主要版本有(<code>TLS1.0</code>, <code>TLS1.1</code>, <code>TLS1.2</code>, <code>TLS1.3</code>)</p><ul><li><code>SSL1.0</code>存在严重的安全问题并没有正式发布</li><li><code>SSL2.0</code>在<code>1995.02</code>正式发布, <code>2011</code>年在<code>RFC 6176</code>被废弃</li><li><code>SSL3.0</code>在<code>1996</code>正式发布, 被广泛使用, 在<code>2015</code> <code>RFC 7568</code>标准中废弃。</li></ul><p>以上三个版本是网景公司维护, 此后<code>SSL</code>被更名为<code>TLS</code>, 由<code>IETF</code>将其标准化(<code>RFC 2246</code>)</p><ul><li><code>TLS1.0</code>基于<code>SSL3.0</code>进行简单升级, 标准化的第一个版本</li><li><code>TLS1.1</code>在<code>RFC 4346</code>中进行标准化发布, 它是<code>TLS1.0</code>的更新, <code>2021.03</code> <code>RFC 8996</code>标准废弃了<code>TLS1.0</code>和<code>TLS1.1</code></li><li><code>TLS1.2</code> 在<code>RFC 5246</code>中定义, <code>2008.08</code>正式发布, 其基于早前的<code>TLS1.1</code>版本， 其是目前广泛使用的<code>TLS</code>版本</li><li><code>TLS1.3</code>在<code>RFC 8446</code>中<code>2018.08</code>正式发布, 属于目前最新的安全协议版本。</li></ul><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/tls%E5%90%84%E5%8D%8F%E8%AE%AE%E7%89%88%E6%9C%AC%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E5%92%8C%E8%AE%A4%E8%AF%81%E6%94%AF%E6%8C%81.png" srcset="/img/loading.gif" lazyload alt="tls各协议版本密钥交换和认证支持.png"></p><p>目前各版本协议的支持情况统计:</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/%E5%90%84TLS%E7%89%88%E6%9C%AC%E6%94%AF%E6%8C%81%E6%83%85%E5%86%B5.png" srcset="/img/loading.gif" lazyload alt="各TLS版本支持情况.png"></p><p>可见虽然<code>TLS 1.3</code>版本标准化已经几年, 但是市面上<code>TLS1.2</code>版本任然是占据主流, 因此学习<code>tls1.2</code>不仅对了解<code>TLS</code>的发展史, 对维护当前项目或者学习新的<code>TLS1.3</code>协议也很有帮助, 现在让我们一起来学习<code>TLS1.2</code>吧！</p><hr><h3 id="tls"><a class="markdownIt-Anchor" href="#tls"></a> TLS</h3><p>  <code>TLS</code>是一个分层协议, 主要由四种协议组成:</p><ul><li>握手协议: <code>handshake protocol</code></li><li>警告协议: <code>alert procotol</code></li><li>密码更改协议: <code>change cipher spec protocol</code></li><li>应用数据协议: <code>application data procotol</code></li></ul><p>对于这个分层不同的人有不同划分, 有的人认为<code>application data procotol</code>协议应该在其他协议之上的上层协议。</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/TLS%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt="TLS协议分层结构.png"></p><p>  我们可以站在应用层的角度来看数据包的状态, 如下, 应用层数据首先通过分包变成两个<code>DATA</code>数据包(<code>TLS</code>对单个数据包长度有限制, 超过单个最大长度会被分包), 分包后的数据首先进行压缩(通常不使用, 一方面由于压缩算法的产权纠纷, 另一方面使用压缩算法会产生安全分险, <code>TLS1.3</code>已经彻底废弃使用压缩, <code>TLS1.2</code>还可以使用), 压缩后的数据计算<code>HMAC</code>并附在原始数据的尾部, 然后进行数据加密, 最后添加记录层的头部。</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/TLS%E5%8D%8F%E8%AE%AE%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt="TLS协议结构.png"></p><p>  具体的协议内容我们接下来一一讲解。为了在保证<code>TLS</code>协议主体不改变的情况下提供足够的灵活性来应对各类新的需求和安全威胁, 在<code>TLS</code>中引入扩展的概念。扩展数据依附在原协议数据的后面, 通过检测扩展长度判断是否存在附加的记录内容, 记录协议支持附加的记录内容类型, 新的记录类型值由<code>IANA</code>在<code>TLD</code>内容类型仓库(<code>section 12</code>)中指定。除非通过某种扩展协商，在实现中不得发送未定义的记录类型,如果<code>TLS</code>实现收到意外记录类型, 它必须发送一个以外消息警报。</p><p>  特别需要注意的是, 记录的类型和长度不受加密保护, 如果此信息本身是敏感的, 应用程序设计者可能希望采取措施(填充、覆盖流量)来最小化信息泄漏。</p><p>接下来我们首先开始记录协议的学习。</p><hr><h3 id="record-layer"><a class="markdownIt-Anchor" href="#record-layer"></a> Record Layer</h3><p>  记录层协议是一个分层协议, 在每一层消息可能包含长度、描述和内容字段, 记录协议接收要传输的数据, 进行可选的数据压缩、追加<code>MAC</code>, 加密并传输, 当接收到数据, 进行解密、校验、解压、重组并交付给更高层客户。</p><p>记录协议维护了一套安全参数, 如下:</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/SecurityParameter%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt="SecurityParameter结构.png"></p><p>通过这些参数, 记录协议将产生如下六个项目:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">client write MAC key<br>server write MAC key<br>client write encryption key<br>server write encryption key<br>client write IV<br>server write IV<br></code></pre></td></tr></table></figure><p>这些项目将在后续数据的加密、完整性校验等方面其作用。</p><hr><h4 id="fragmentation"><a class="markdownIt-Anchor" href="#fragmentation"></a> Fragmentation</h4><p>  记录层将消息块分割成<code>2^14 Bytes</code>或者更少记录数据到<code>TLSPlaintext</code>中, 客户端在记录层不保留消息边界, 多个客户端消息可以被合并到一个<code>TLSPlaintext</code>记录中。</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/tls_header%E6%8F%8F%E8%BF%B0.png" srcset="/img/loading.gif" lazyload alt="tls_header描述.png"></p><ul><li><code>Type</code>: 指示处理<code>fragment</code>的高层协议</li><li><code>version</code>: 协议使用版本<ul><li><code>&#123;3, 4&#125;</code>: <code>TLS 1.3</code></li><li><code>&#123;3, 3&#125;</code>: <code>TLS 1.2</code></li><li><code>&#123;3, 2&#125;</code>: <code>TLS 1.1</code></li><li><code>&#123;3, 1&#125;</code>: <code>TLS 1.0</code></li><li><code>&#123;3, 0&#125;</code>: <code>SSL 3.0</code></li></ul></li><li><code>Length</code>: <code>fragment</code>的长度(单位<code>byte</code>), 不能超过<code>2^14 Byte</code></li><li><code>fragment</code>: 应用层数据, 由<code>type</code>指定的高层协议独立处理。</li></ul><p>需要注意:</p><ul><li>不能发送零长度的<code>handshake</code>、<code>alert</code>、<code>ChangeCipherSpec</code>的内容类型</li><li>可以发送零长度的<code>Application data</code></li></ul><hr><h4 id="record-compression-and-decompression"><a class="markdownIt-Anchor" href="#record-compression-and-decompression"></a> Record Compression and Decompression</h4><p>  所有的记录都使用当前会话状态中定义的压缩算法压缩，通常这里总是存在一个有效压缩算法, 然而, 最初它被定义为<code>null</code>, 压缩算法将<code>TLSplaintext</code>结构转换为<code>TLSCompressed</code>结构。需要注意的是:</p><ul><li>压缩算法必须是无损压缩, 并且增加内容长度不得超过<code>1024 Bytes</code></li><li>如果解压超过<code>2^14</code>字节长度, 它必须报告致命的解压失败错误。</li></ul><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/TLSCompressed%E6%8F%8F%E8%BF%B0.png" srcset="/img/loading.gif" lazyload alt="TLSCompressed描述.png"></p><ul><li><p><code>length</code>: <code>TLSCompressed.fragment</code>长度(单位:字节), 长度不能超过<code>2^14 + 1024</code>, 一般我们不希望<code>length</code>过长，因为解密方需要收完整个<code>record</code>，才能解密，length过长会导致解密方需要等待更多的<code>rtt</code>，增大<code>latency</code>，破坏用户体验。</p></li><li><p><code>fragment</code>: <code>TLSPlaintext.fragment</code>的压缩内容</p></li></ul><p><strong>Note</strong>:</p><ul><li>如果不支持压缩, 压缩字段需要设置为<code>CompressionMethod.null</code>, 没有这个字段将产生警告。</li></ul><hr><h4 id="record-payload-protection"><a class="markdownIt-Anchor" href="#record-payload-protection"></a> Record Payload Protection</h4><p>  加密算法和<code>MAC</code>函数转换<code>TLSCompress</code>结构为<code>TLSCiphertext</code>, 解密函数执行相反过程。记录<code>MAC</code>还包含一个序列号(类似<code>TCPIP</code>的<code>Seq</code>), 以便丢失片段或者重复的信息被检测出来。加密算法主要有三个:</p><ul><li><code>stream</code>加密(存在安全漏洞, 被<code>TLS 1.3</code>废弃)</li><li><code>block</code>加密(存在安全漏洞, 被<code>TLS 1.3</code>废弃)</li><li><code>aead</code>加密(唯一被<code>TLS1.3</code>支持的加密方式)</li></ul><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/TLSCiphertext%E6%8F%8F%E8%BF%B0.png" srcset="/img/loading.gif" lazyload alt="TLSCiphertext描述.png"></p><ul><li><code>type</code>: 同<code>TLSCompressed.type</code></li><li><code>version</code>: 同<code>TLSCompressed.version</code></li><li><code>length</code>: <code>TLSCiphertext.fragment</code>的长度, 单位是字节, 长度不能超过<code>2^14 + 2048 Bytes</code></li><li><code>fragment</code>: <code>TLSCompressed.fragment</code>的加密形式, 带<code>MAC</code></li></ul><hr><h5 id="null-or-standard-stream-cipher"><a class="markdownIt-Anchor" href="#null-or-standard-stream-cipher"></a> Null or Standard Stream Cipher</h5><p>  流加密(包括<code>BulkCipherAlgorithm.null</code>; <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc5246#appendix-A.6">参考</a>), 就是将<code>TLSCompressed.fragment</code>结构转换为<code>TLSCiphertext.fragment</code>结构。</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/GenericStreamCipher%E6%8F%8F%E8%BF%B0.png" srcset="/img/loading.gif" lazyload alt="GenericStreamCipher描述.png"></p><p>其中<code>MAC</code>计算:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">MAC(MAC_write_key, seq_num +<br>                    TLSCompressed.type +<br>                    TLSCompressed.version +<br>                    TLSCompressed.length +<br>                    TLSCompressed.fragment);<br></code></pre></td></tr></table></figure><ul><li><code>+</code>表示串联。</li><li><code>seq_num</code>: 该记录的序列号</li></ul><blockquote><p><code>seq_num</code>是当前<code>record</code>的 <code>sequence number</code>，每条<code>record</code>都会<code>++</code>， 可以看到把 <code>seq_num</code>以及<code>record header</code>里面的几个字段也算进来了，这样解决了防重放问题，并且保证<code>record</code>的任何字段都不能被篡改。</p></blockquote><ul><li><code>MAC</code>: <code>SecurityParameters.mac_algorithm</code>指定的<code>MAC</code>算法</li></ul><blockquote><p>请注意: <code>MAC</code>是在加密之前计算的, 流密码加密整个块, 包括<code>MAC</code>, 对于流密码而言不使用同步向量(如<code>RC4</code>), 上一个记录的流加密状态简单的用于下一个包的加密。</p></blockquote><hr><h5 id="cbc-block-cipher"><a class="markdownIt-Anchor" href="#cbc-block-cipher"></a> CBC Block Cipher</h5><p>  对于分组加密(如<code>3DES</code>或<code>AES</code>), 是将<code>TLSCompressed.fragment</code>结构转换为<code>TLSCiphertext.fragment</code>结构。</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/GenericBlockCipher%E6%8F%8F%E8%BF%B0.png" srcset="/img/loading.gif" lazyload alt="GenericBlockCipher描述.png"></p><ul><li><code>MAC</code>生成同上面<code>GenericStreamCipher</code>描述</li><li><code>IV</code>: 初始化向量(<code>IV</code>)应该随机选择, 并且必须是不可预测的, 需要注意, 在<code>TLS 1.1</code>之前版本, 没有<code>IV</code>字段, 并且最后一个加密块的前一个记录是被用来作为<code>IV</code>, 对于块加密, <code>IV</code>长度是<code>SecurityParameters.record_iv_length</code>, 等于<code>SecurityParameters.block_size</code>。</li></ul><blockquote><p>注意：<code>TLS</code> 在 <code>1.1</code>版本之前，没有这个<code>IV</code>字段，前一个<code>record</code>的最后一个<code>block</code>被当成下一个<code>record</code>的<code>IV</code>来用，然后粗大事了，这导致了 <a target="_blank" rel="noopener" href="http://www.openssl.org/~bodo/tls-cbc.txt">【BEAST】</a> 攻击。 所以，<code>TLS1.2</code>改成了这样。 (还在使用<code>CBC</code>的各位，建议关注一下自己的<code>IV</code>字段是怎么生成出来的。如果要用，做好和<code>TLS1.2</code>的做法保持一致)</p></blockquote><ul><li><code>padding</code>: 添加填充以强制明文长度为分组密码长度的整数倍, 这个填充可以最多<code>255</code>字节, 只要<code>TLSCiphertext.length</code>是块长度的整数倍即可， 比需要的长度更长的长度可以有效挫败对于协议分析类攻击。填充数据中的每个<code>uint8</code>向量必须填充相应的长度值, 接受者必须检查此填充, 并且必须使用<code>bad_record_mac</code>警报来指示填充错误。</li><li><code>padding_length</code>: 填充长度必须使得<code>GenericBlockCipher</code>结构总长度是密码块的倍数, 合法范围为(0到255), 这个<code>length</code>指示填充字段的长度, 不包括<code>padding_length</code>字段本身。</li></ul><p>示例:</p><blockquote><p>假设加密块长度为<code>8</code>, <code>TLSCompressed.length</code>长度为<code>61Bytes</code>, <code>MAC</code>长度为<code>20Bytes</code>, 那么填充前长度为<code>82Bytes</code>(不包括<code>IV</code>), 因此填充长度必须等于<code>6Bytes</code>以便总长度为<code>8</code>的整数倍, 填充长度可以是<code>6、14、22</code>等直到<code>254</code>，如果填充长度是最小长度, 填充将为<code>6</code>字节, 每个包含值为<code>6</code>, 因此最后<code>8Bytes</code>块加密前为<code>xx 06 06 06 06 06 06</code>, 其中<code>xx</code>是<code>MAC</code>的最后一个字节。</p></blockquote><p>两大陷阱:</p><ul><li>实现的代码必须在收到全部明文之后才能传输密文，否则可能会有<code>BEAST</code>攻击</li><li>实现上，根据<code>MAC</code>计算的时间，可能进行时间侧通道攻击，因此必须确保–运行时间和<code>padding</code>是否正确无关。</li></ul><hr><h5 id="aead-ciphers"><a class="markdownIt-Anchor" href="#aead-ciphers"></a> AEAD Ciphers</h5><p>  对于<code>AEAD</code>加密, 例如<code>CCM</code>或者<code>GCM</code>, <code>AEAD</code>函数将<code>TLSCompressed.fragment</code>结构与<code>AEAD</code> <code>TLSCiphertext.fragment</code>结构。</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/GenericAEADCipher%E6%8F%8F%E8%BF%B0.png" srcset="/img/loading.gif" lazyload alt="GenericAEADCipher描述.png"></p><p><code>AEAD</code>将单个密钥、随机数、明文作为输入, 并且将附加数据包含到身份验证中, 这单个密钥是<code>client_write_key</code>和<code>server_write_key</code>二选一， 不适用<code>MAC Key</code>。</p><p>每一个<code>AEAD</code>密码套件必须提供<code>AEAD</code>操作如何构造<code>nonce</code>, 以及<code>GenericAEADCipher.nonce_explicit</code>的长度部分, 在大多数情况下, 它适合使用所描述的隐式随机技术。</p><p>对于<code>TLSCompressed.fragment</code>的明文, 附加认证数据定义为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tls">additional_data = seq_num + TLSCompressed.type +<br>                  TLSCompressed.version + TLSCompressed.length;<br></code></pre></td></tr></table></figure><ul><li><code>+</code>表示串联</li></ul><p><strong>加密</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tls">AEADEncrypted = AEAD-Encrypt(write_key, nonce, plaintext,<br>                                   additional_data)<br></code></pre></td></tr></table></figure><p>为了解密和验证, 密码将<code>key</code>, <code>nonce</code>, <code>additional_data</code>以及<code>AEADEncrypted</code>数据作为输入, 输出原始的<code>plaintext</code>值。如果解密失败, 需要产生一个<code>bad_record_mac</code>警告。</p><p><strong>解密</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tls">TLSCompressed.fragment = AEAD-Decrypt(write_key, nonce,<br>                                            AEADEncrypted,<br>                                            additional_data)<br><br></code></pre></td></tr></table></figure><hr><h4 id="key-calculation"><a class="markdownIt-Anchor" href="#key-calculation"></a> Key Calculation</h4><p>  记录协议要求通过握手协议中提供的安全参数, 通过一种算法产生当前连接状态需要的<code>keys</code>, 主密钥被扩展为一个安全字节序列, 被分割为<code>Client write MAC Key</code>, <code>server write MAC key</code>, <code>client write encryption key</code>, <code>server write encryption key</code>, 每一个<code>key</code>都是由这些字节序产生, 未使用的值将为空。</p><p>当<code>keys</code>和<code>MAC keys</code>生成时,<code>master secret</code>将被用作熵源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tls">key_block = PRF(SecurityParameters.master_secret,<br>                      &quot;key expansion&quot;,<br>                      SecurityParameters.server_random +<br>                      SecurityParameters.client_random);<br></code></pre></td></tr></table></figure><p>通过以上计算, 直到产生足够的输出, 然后<code>key_block</code>将作为如下内容的值:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tls">client_write_MAC_key[SecurityParameters.mac_key_length]<br>server_write_MAC_key[SecurityParameters.mac_key_length]<br>client_write_key[SecurityParameters.enc_key_length]<br>server_write_key[SecurityParameters.enc_key_length]<br>client_write_IV[SecurityParameters.fixed_iv_length]<br>server_write_IV[SecurityParameters.fixed_iv_length]<br></code></pre></td></tr></table></figure><p>要注意的是，<code>TLS 1.3</code> 里面已经废弃了这种方式，改为使用更靠谱的 <code>HKDF</code>，<code>HKDF</code> 也是<code>html5</code>的<code>WebCryptoAPI</code>的标准算法之一。</p><p>如下是主密钥的计算过程:</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/key%E8%AE%A1%E7%AE%97.png" srcset="/img/loading.gif" lazyload alt="key计算.png"></p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/%E5%85%B6%E4%BB%96key%E7%9A%84%E8%AE%A1%E7%AE%97.png" srcset="/img/loading.gif" lazyload alt="其他key的计算.png"></p><p>根据要求，有4个密钥用于加密和验证每个消息的完整性，他们是：</p><blockquote><ul><li><code>client_write_key</code>：客户端用来加密数据，服务器用来解密数据。</li><li><code>server_write_key</code>：服务器用来加密数据，客户端用来解密数据。</li><li><code>client_write_MAC_key</code>：客户端用来创建<code>MAC</code>，服务器用来验证<code>MAC</code>。</li><li><code>server_write_MAC_key</code>：服务器用来创建<code>MAC</code>，客户端用来验证<code>MAC</code>。</li></ul></blockquote><p>此处有几个问题值得思考：</p><ul><li>为什么<code>MAC key</code> , <code>encryption key</code>, <code>IV</code> 要分别不同？</li></ul><blockquote><p>在密码学中，对称加密算法一般需要<code>encryption key</code>，<code>IV</code>两个参数，<code>MAC</code>算法需要<code>MAC key</code>参数，因此这<code>3</code>个<code>key</code>用于不同的用途。 当然，不是所有的算法都一定会用到这<code>3</code>个参数，例如新的<code>aead</code>型算法，就不需要<code>MAC key</code>。</p></blockquote><ul><li>为什么<code>client</code>和<code>server</code>要使用不同的<code>key</code>?</li></ul><blockquote><p>如果<code>TLS</code>的双方使用相同的<code>key</code>，那么当使用<code>stream cipher</code>加密应用数据的时候，<code>stream cipher</code>的字节流在两个方向是一样的，如果攻击者知道<code>TLS</code>数据流一个方向的部分明文（比如协议里面的固定值），那么对<code>2</code>个方向的密文做一下<code>xor</code>，就能得到另一个方向对应部分的明文了。</p><p>还有，当使用 <code>aead</code> 比如 <code>aes-gcm</code>做加密的时候，<code>aead</code> 标准严格要求，绝对不能用相同的 <code>key+nonce</code> 加密不同的明文，故如果<code>TLS</code>双方使用相同的<code>key</code>，又从相同的数字开始给<code>nonce</code>递增，那就不符合规定，会直接导致 <code>aes-gcm</code> 被攻破。</p></blockquote><hr><h3 id="handshake"><a class="markdownIt-Anchor" href="#handshake"></a> handshake</h3><p>  记录协议有三个子协议用于记录层对端协商安全参数, 分别是认证身份、协商安全参数、报告错误条件。其中握手协议负责协商和建立一个会话供应用层使用, 协商的会话由如下组成:</p><ul><li><code>session identifier</code>: 会话标识, 服务器选择的任意字节序列，用于标识一个活动或可恢复的会话状态。</li><li><code>peer certificate</code>: 有的状态可能不存在</li><li><code>compression method</code>: 用于加密之前的压缩算法</li><li><code>cipher spec</code>: 指定用于生成密钥的随机函数的参数内容, 块加密算法, <code>MAC</code>算法</li><li><code>master secret</code>: 客户端和服务端间<code>48Bytes</code>共享密钥</li><li><code>is resumable</code>: 用于指示会话是否可以初始化为一个新会话的标识。</li></ul><p>这里对一些概念进行一个描述:<br>  握手协议使用 非对称加密/密钥协商/数字签名 <code>3</code>类算法， 因此要求读者对这3类算法概念清晰，能准确区分。 在此澄清一下, 非对称的算法分为3类:</p><ul><li>非对称加密，有：<code>RSAES-PKCS1-v1_5</code>，<code>RSAES-OAEP</code> ,<code>Rabin-Williams-OAEP</code>, <code>Rabin-Williams-PKCS1-v1_5</code>等</li><li>非对称密钥协商，有：<code>DH</code>，<code>DHE</code>，<code>ECDH</code>，<code>ECDHE</code> 等</li><li>非对称数字签名：<code>RSASSA-PKCS1-v1_5</code>，<code>RSASSA-PSS</code>，<code>ECDSA</code>，<code>DSA</code>，<code>ED25519</code> 等</li></ul><p>另外，非对称加密算法，可以当作密钥协商算法来用，所以 <code>RSAES-PKCS1-v1_5</code>，<code>RSAES-OAEP</code> 也可以当作密钥协商算法来用。</p><p>对于<code>RSA</code>, <code>RSA</code> 的实际工程应用，要遵循 <code>PKCS#1</code> 标准。 其中的 <code>RSAES-PKCS1-v1_5</code> 和 <code>RSASSA-PKCS1-v1_5</code> 是使用 <code>RSA</code> 算法的两种不同 <code>scheme</code>（方案）。 <code>RSAES</code> 表示 <code>RSA Encryption schemes</code>，即非对称加密， <code>RSAES</code>分为两种,</p><ul><li><code>RSAES-OAEP</code></li><li><code>RSAES-PKCS1-v1_5</code></li></ul><p>其中<code>RSAES-OAEP</code>更新更安全</p><p><code>RSASSA</code> 表示 <code>Signature schemes with appendix</code>，即<code>appendix</code>模式(<code>appendix</code>和<code>recovery</code>的区别请参看密码学教材)的非对称数字签名算法。 <code>RSASSA</code>也有两种:</p><ul><li><code>RSASSA-PSS</code></li><li><code>RSASSA-PKCS1-v1_5</code></li></ul><p>其中<code>RSASSA-PSS</code>更新更安全</p><p><code>RSA</code>还有一个缺陷，就是很容易被时间侧通道攻击，所以现在的<code>RSA</code>实现都要加 <code>blinding</code>. 可以看到，<code>RSA</code>是一种很特殊的算法，既可以当非对称加密算法使用，又可以当非对称数字签名使用。这一点很有迷惑性，其实很多用<code>RSA</code>的人都分不清自己用的是<code>RSA</code>的哪种模式。相比之下，<code>ECC</code>(椭圆曲线)这一块的算法就很清晰，<code>ECDSA</code>只能用作数字签名，<code>ECDH</code>只能用作密钥交换。</p><p>原则就是: <strong>一对密钥只做一个用途，要么用作非对称加解密，要么用作签名验证，别混着用！</strong>, 这个要求决定了一个协议的<code>PFS</code>(前向安全性)。<code>PFS</code>反映到密钥协商过程中，就是：</p><ul><li>不要使用<code>RSA</code>做密钥协商，一定只用<code>RSA</code>做数字签名。</li><li>不要把<code>ECDH</code>的公钥固定内置在客户端做密钥协商</li></ul><p>以上是一些安全设计原则, 另一方面, <code>TLS</code>握手涉及到进行<code>RSA/ECDH/ECDSA</code>等非对称计算，非对称计算是很慢的, 关于非对称的性能： 例如在<code>2015</code>年的服务器<code>cpu</code>： <code>Intel(R) Xeon(R) CPU E3-1230 V2 @ 3.30GHz</code> 上， 使用如下命令测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl speed rsa2048<br>openssl speed ecdsap256<br>openssl speed ecdhp256<br>openssl speed aes-128-cbc<br>openssl speed -evp aes-128-cbc<br></code></pre></td></tr></table></figure><p>结果如下:</p><table><thead><tr><th style="text-align:left">算法</th><th style="text-align:left">性能</th><th style="text-align:left">性能</th></tr></thead><tbody><tr><td style="text-align:left"><code>RSA-2048</code></td><td style="text-align:left">私钥运算 <code>723.7</code> 次/秒</td><td style="text-align:left">公钥运算 <code>23505.8</code> 次/秒</td></tr><tr><td style="text-align:left"><code>256 bit ecdsa</code> (<code>nistp256</code>)</td><td style="text-align:left">签名 <code>8628.4</code> 次/秒</td><td style="text-align:left">验证 <code>2217.0</code> 次/秒</td></tr><tr><td style="text-align:left"><code>256 bit ecdh</code> (<code>nistp256</code>)</td><td style="text-align:left"><code>ECDH</code>协商 <code>2807.8</code> 次/秒</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>aes-128-cbc</code></td><td style="text-align:left">加密 <code>121531.39</code> <code>K</code>/秒</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>aes-128-cbc</code> 使用<code>aesni</code>硬件加速</td><td style="text-align:left">加密 <code>683682.13</code> <code>K</code>/秒</td><td style="text-align:left"></td></tr></tbody></table><p>鉴于非对称运算性能数据惨不忍睹， 可以利用<code>cache</code>机制来缓存数据, 有2种<code>cache</code>手段：<code>session id</code>，和<code>session ticket</code>。把握手的结果直接<code>cache</code>起来，绕过握手运算。这个后面再说。</p><hr><h4 id="change-cipher-spec-protocol"><a class="markdownIt-Anchor" href="#change-cipher-spec-protocol"></a> Change Cipher Spec Protocol</h4><p>  更改密码协议是为了改变当前密码策略, 这个协议由单个消息组成, 如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> change_cipher_spec(<span class="hljs-number">1</span>), (<span class="hljs-number">255</span>) &#125; type;<br>&#125; ChangeCipherSpec;<br></code></pre></td></tr></table></figure><p><code>ChangeCipherSpec</code>消息由客户端或者服务端发送通知接收端后续数据将使用新的密码规范和密钥保护。这个消息在安全参数协商后、但是在校验完成消息发送前发送。</p><p>  编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送（<code>ChangeCipherSpec</code>是一个独立的协议，体现在数据包中就是一个字节的数据，用于告知服务端，客户端已经切换到之前协商好的加密套件（<code>Cipher Suite</code>）的状态，准备使用之前协商好的加密套件加密数据并传输了）。</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/ClientChangeCipher.png" srcset="/img/loading.gif" lazyload alt="ClientChangeCipher.png"></p><hr><h4 id="alert-protocol"><a class="markdownIt-Anchor" href="#alert-protocol"></a> Alert Protocol</h4><p>  警报协议根据消息严重程度分为(<code>warning</code>和<code>fatal</code>), <code>fatal</code>警告将立即终止连接, 在这种情况下, 相应的其他连接会话可以继续, 但是会话标识符必须无效, 防止失败的会话被用来建立新的会话连接, 与其他消息一样, 警报消息也是加密和压缩的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> warning(<span class="hljs-number">1</span>), fatal(<span class="hljs-number">2</span>), (<span class="hljs-number">255</span>) &#125; AlertLevel;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    close_notify(<span class="hljs-number">0</span>),<br>    unexpected_message(<span class="hljs-number">10</span>),<br>    bad_record_mac(<span class="hljs-number">20</span>),<br>    decryption_failed_RESERVED(<span class="hljs-number">21</span>),<br>    record_overflow(<span class="hljs-number">22</span>),<br>    decompression_failure(<span class="hljs-number">30</span>),<br>    handshake_failure(<span class="hljs-number">40</span>),<br>    no_certificate_RESERVED(<span class="hljs-number">41</span>),<br>    bad_certificate(<span class="hljs-number">42</span>),<br>    unsupported_certificate(<span class="hljs-number">43</span>),<br>    certificate_revoked(<span class="hljs-number">44</span>),<br>    certificate_expired(<span class="hljs-number">45</span>),<br>    certificate_unknown(<span class="hljs-number">46</span>),<br>    illegal_parameter(<span class="hljs-number">47</span>),<br>    unknown_ca(<span class="hljs-number">48</span>),<br>    access_denied(<span class="hljs-number">49</span>),<br>    decode_error(<span class="hljs-number">50</span>),<br>    decrypt_error(<span class="hljs-number">51</span>),<br>    export_restriction_RESERVED(<span class="hljs-number">60</span>),<br>    protocol_version(<span class="hljs-number">70</span>),<br>    insufficient_security(<span class="hljs-number">71</span>),<br>    internal_error(<span class="hljs-number">80</span>),<br>    user_canceled(<span class="hljs-number">90</span>),<br>    no_renegotiation(<span class="hljs-number">100</span>),<br>    unsupported_extension(<span class="hljs-number">110</span>),<br>    (<span class="hljs-number">255</span>)<br>&#125; AlertDescription;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    AlertLevel level;<br>    AlertDescription description;<br>&#125; Alert;<br></code></pre></td></tr></table></figure><p>关于每一项的具体含义请参考文章末尾的参考资料<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc5246">【RFC 5246】</a></p><p>抓包内容如下:</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/Alert.png" srcset="/img/loading.gif" lazyload alt="Alert.png"></p><hr><h4 id="handshake-protocol"><a class="markdownIt-Anchor" href="#handshake-protocol"></a> Handshake Protocol</h4><p>  会话密码参数通过握手协议产生, 当<code>TLS</code>客户端和服务端首次开始通讯, 它们协商协议版本, 选择密码算法, 双方都可选的身份认证 以及 使用公钥加密技术产生共享密钥。<code>TLS</code>握手协议主要包含如下步骤:</p><ul><li>交换<code>hello</code>消息来协商算法, 交换随机数, 检查会话是否可恢复</li><li>交换必要的密码参数来允许客户端和服务端协商<code>premaster secret</code></li><li>交换证书和密码信息来允许客户端和服务端认证身份</li><li>为记录层提供安全参数</li><li>允许客户端和服务端校验对端是否有相同的安全参数, 以及确保握手期间没有黑客干预。</li></ul><p>实际密钥交换最多使用4种消息:</p><ul><li><code>the server Certificate</code></li><li><code>the ServerKeyExchange</code></li><li><code>the client Certificate</code></li><li><code>the ClientKeyExchange</code></li></ul><p>新的密钥交换方法可以通过这些消息的特殊格式来创建, 并且通过指定这些消息来允许客户端和服务端协商出一个共享密钥, 这个密钥必须足够长, 当前定义密钥交换算法交换密钥长度在<code>46Bytes</code>以上。</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/tls%E6%8F%A1%E6%89%8B%E6%97%B6%E5%BA%8F%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="tls握手时序图.png"></p><p>如上是一个全流程的消息流握手过程, 包括了一些可选的握手包，当客户端和服务端实行快速恢复时，流程如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">Client                                              Server<br><br>ClientHello                   --------&gt;<br>                                               ServerHello<br>                                        [ChangeCipherSpec]<br>                            &lt;--------             Finished<br>[ChangeCipherSpec]<br>Finished                      --------&gt;<br>Application Data              &lt;-------&gt;     Application Data<br></code></pre></td></tr></table></figure><ul><li>首先客户端发送<code>ClientHello</code>消息, 里面包含了需要恢复会话的<code>SessionID</code>。</li><li>服务端接收后检查本地<code>Session</code>缓存看是否存在匹配, 如果匹配服务器将恢复<code>SessionID</code>连接的会话状态, 服务端将在<code>serverHello</code>消息中发送相同的<code>SessionId</code></li><li>接下来服务端和客户端必须发送<code>ChangeCipherSpec</code>消息和<code>Finish</code>消息。至此快速恢复完成, 应用层可以交换数据。</li><li>如果服务端未查询到<code>ClientHello</code>中包含的<code>SessionID</code>, 或者会话已经过期, 服务端将产生一个新的<code>SessionId</code>, 开启一个新的会话协商。</li></ul><p>  <code>TLS Handshake Protocol</code>协议定义为高层次客户端<code>TLS</code>记录层协议, 这个协议用于协商安全的会话属性, 由<code>TLS</code>记录层提供。被封装在<code>TLSPlaintext</code>结构中。</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/Handshake%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0.png" srcset="/img/loading.gif" lazyload alt="Handshake结构描述.png"></p><p>这里需要注意, 握手协议消息必须按照顺序发送, 以意想不到的的顺序发送握手消息将导致致命的错误, 当然, 不需要的握手消息可以省略, 不过这里有一个特例, <code>HelloRequest</code>消息可以在任何时候发送。</p><hr><h5 id="hello-messages"><a class="markdownIt-Anchor" href="#hello-messages"></a> Hello Messages</h5><p>  <code>Hello</code>阶段是为了客户端和服务端之间交换安全增强能力, 当一个新的会话开始, 记录层连接状态:加密、<code>hash</code>、压缩算法都被初始化为<code>null</code>(当前连接状态是为了密钥协商)</p><h6 id="hello-request"><a class="markdownIt-Anchor" href="#hello-request"></a> Hello Request</h6><p>  服务器可能在任意时间发送<code>Hellorequest</code>消息, <code>HelloRequest</code>是一个简单通知客户端应该开始协商进程的消息, 作为响应, 客户端应该在方便时发送<code>ClientHello</code>, 这个消息不是为了指示哪一方是客户端, 仅仅是为了初始化一个新的协商过程, 当客户端已经是初始化状态时, 服务端不应该发送<code>HelloRequest</code>, 因为此时客户端的工作就是发送<code>ClientHello</code>消息。</p><p>  当客户端已经在协商一个会话将忽略该消息, 与此同时, 当客户端不想协商一个会话时也将忽略该消息, 如果是这种情况, 客户端将回复<code>no_renegotiation</code>的警报。因为握手时消息优先于应用数据传输, 因此期望在协商之前客户端将不会收到更多记录, 如果服务端发送<code>Hellorequest</code>但是没有接收到<code>ClientHello</code>回复, 服务端将发送<code>fatal</code>警报关闭连接。发送<code>HelloRequest</code>后, 服务端不应该重复请求, 直到后续协商完成。</p><p><code>HelloRequest</code> 结构如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>&#125; HelloRequest;<br></code></pre></td></tr></table></figure><p>此消息绝对不能包含在消息散列中, 消息在整个握手过程中维持，并在<code>Finished</code>消息和证书校验中使用。</p><hr><h6 id="clienthello"><a class="markdownIt-Anchor" href="#clienthello"></a> ClientHello</h6><p>  当客户端第一次连接到服务器时需要发送<code>ClientHello</code>消息作为它的第一条消息, 客户端也可以主动发送一个<code>ClientHello</code>作为<code>HelloRequest</code>的响应。</p><p><code>ClientHello</code>是<code>TLS</code>握手的第一阶段:</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.png" srcset="/img/loading.gif" lazyload alt="第一阶段.png"></p><p>如下是<code>ClientHello</code>的结构， 由客户端发送。</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/CLientHello%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0.png" srcset="/img/loading.gif" lazyload alt="CLientHello结构描述.png"></p><p>这里分别解释下各项内容:</p><ul><li><code>client_version</code>: 客户端支持的最高协议版本, <code>TLS1.2</code>是<code>0303</code></li><li><code>random</code>, 客户端提供的随机数, 内容分两部分</li></ul><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">&gt;<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>   uint32 gmt_unix_time;<br>   opaque random_bytes[<span class="hljs-number">28</span>];<br>&gt;&#125; Random;<br></code></pre></td></tr></table></figure><ul><li><code>gmt_unix_time</code>: 是<code>unix</code>格式时间, 从<code>1970-01-01</code>到现在的秒数</li><li><code>random_bytes</code>: <code>28Bytes</code>的安全随机数</li></ul><blockquote><p>密码学安全的随机数生成，这是个很大的话题，也是一个大陷阱，目前最好的做法就是用 <code>/dev/urandom</code>，或者<code>openssl</code>库的 <code>RAND_bytes()</code>。</p><p>历史上，恰好就在<code>SSL</code>的<code>random_bytes</code>这个字段，<code>NetScape</code>浏览器早期版本被爆出过随机数生成器漏洞。 被爆菊的随机数生成器使用 <code>pid</code> + 时间戳 来初始化一个<code>seed</code>，并用<code>MD5(seed)</code>得出结果</p></blockquote></blockquote><ul><li><code>SessionID</code>: 会话<code>ID</code>, 传输过程中不加密, 可用于会话恢复， 长度为<code>32Bytes</code></li></ul><blockquote><p>如果客户端第一次连接到服务器，那么这个字段就会保持为空, 如果该字段不为空，说明以前是与服务器有连接的，在此期间，服务器将使用<code>Session ID</code>映射对称密钥, 并将<code>Session ID</code>存储在客户端本地, 为映射设置一个时间限。如果客户端将来连接到同一台服务器（在时间到期之前），它将发送<code>Session ID</code>，服务器将对映射的<code>Session ID</code>进行验证，并使用以前用过的对称密钥来恢复<code>Session</code>，这种情况下不需要完全握手。也叫作<code>SSL</code>会话恢复。</p></blockquote><ul><li><code>CipherSuite</code>: 两字节加密套件, 可参考 <a target="_blank" rel="noopener" href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4">【Transport Layer Security (TLS) Parameters】</a></li></ul><blockquote><p><code>ClientHello.cipher_suites</code>字段，包含了客户端支持的<code>CipherSuite</code>的列表，按照客户端希望的优先级排序，每个<code>CipherSuite</code>有2个字节，每个<code>CipherSuite</code>由：一个密钥交换算法，一个大量数据加密算法(需要制定<code>key length</code>参数)，一个<code>MAC</code>算法，一个<code>PRF</code> 构成。服务器会从客户端发过来的列表中选择一个；如果没有可以接受的选择，就返回一个 <code>handshake failure</code> 的 <code>alert</code>，并关闭连接。如果列表包含服务器不认识，不支持，或者禁用的<code>CipherSuite</code>，服务器必须忽略。 如果<code>SessionID</code>不为空，则<code>cipher_suites</code>里面起码要包含客户端<code>cache</code>的<code>session</code>里面的那个<code>CipherSuite</code></p></blockquote><ul><li><code>CompressionMethod</code>: 加密方法, 定义如下:</li></ul><blockquote><p><code>enum &#123; null(0), (255) &#125; CompressionMethod;</code></p><p>类似地，<code>ClientHello</code>里面包含压缩算法的列表，按照客户端优先级排序。</p></blockquote><p>由于压缩引入的安全风险, <code>TLS1.3</code>已经废弃使用压缩。</p><ul><li><code>Extension</code>: 为了保证主协议不变更的情况下, 增强<code>TLS</code>的兼容性和能力, 引入扩展, 这个在后续逐步讲解。<code>ClientHello</code>中携带扩展主要是向服务端提供客户端支持的扩展能力, 后续交互中, 交互的扩展必须是这个扩展的子集。</li></ul><p>客户端<code>ClientHello</code>, 客户端等待 服务端<code>ServerHello</code>回复, 除<code>HelloRequest</code>消息外, 服务器返回的其他任何握手消息都将引发<code>fatal alert</code></p><p>抓包如下:</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/ClientHello.png" srcset="/img/loading.gif" lazyload alt="ClientHello.png"></p><hr><h6 id="server-hello"><a class="markdownIt-Anchor" href="#server-hello"></a> Server Hello</h6><p>  客户端<code>ClientHello</code>会列出所有客户端支持的密码套件, 并按照偏好从上而下, 当服务器接受到客户端发送的<code>ClientHello</code>, 并且能够从密码套件列表中找到一组服务器支持的密码套件时, 将发送<code>ServerHello</code>回复<code>ClientHello</code>消息，如果找不到这样的匹配, 将以<code>handshake failure alert</code>结束。</p><p><code>ServerHello</code>消息格式定义如下:</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/ServerHello%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0.png" srcset="/img/loading.gif" lazyload alt="ServerHello结构描述.png"></p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/TLS_ExtensionType%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0.png" srcset="/img/loading.gif" lazyload alt="TLS_ExtensionType结构描述.png"></p><p><strong>Note</strong>:</p><ul><li>是否存在扩展可以通过<code>ServerHello</code>消息中<code>compression_method</code>字段后面是否还存在字节来判断。</li></ul><ul><li><code>server_version</code>: 客户端和服务端支持的最低<code>TLS</code>版本</li><li><code>random</code>: 服务端产生的随机数(独立于<code>ClientHello.random</code>)</li><li><code>session_id</code>: 会话连接对应的标识<ul><li>如果<code>ClientHello.Session_id</code>非空, 则服务端将查找其会话缓存中是否存在匹配的会话, 如果匹配, 服务器将响应与客户端<code>ClientHello.session_id</code>相同值, 这表示双方将执行快速会话恢复。</li><li>如果<code>ClientHello.Session_id</code>为空或者服务端缓存没有匹配的会话, 服务端将返回一个新的<code>Session_id</code></li></ul></li></ul><blockquote><p>  在涉及亚马逊和谷歌等流量巨大的应用程序时，这种方法存在缺点。每天都有数百万人连接到服务器，服务器必须使用<code>Session</code>密钥保留所有<code>Session</code>参数的<code>TLS</code>缓存。这是一个巨大的开销。</p><p>  为了解决这个问题，<code>RFC</code>定义了<code>sessionTickets</code>机制, 通过在扩展包里加入了<code>Session Tickets</code>来将相关会话恢复信息存储在客户端来缓解服务端压力, 在这里，客户端可以在<code>client hello</code>中指定它是否支持<code>Session Ticket</code>。然后，服务器将创建一个新的会话票证(<code>Session Ticket</code>)，并使用只有服务器知道的经过私钥加密的<code>Session</code>参数。它将存储在客户端上，因此所有<code>Session</code>数据仅存储在客户端计算机上，但<code>Ticket</code>仍然是安全的，因为该密钥只有服务器知道。<br>  此数据可以作为名为<code>Session Ticket</code>的扩展包含在<code>Client Hello</code>中。</p><p>  另一方面, 在实践中，<code>session cache</code>在服务器端要求<code>key-value</code>形式的存储，如果<code>tls</code>服务器不止一台的话，就有一个存储怎么共享的问题，要么存储同步到所有TLS服务器的内存里，要么专门搞服务来支持存储，并使用<code>rpc</code>访问， 无论如何，都是很麻烦的事情，相比之下，<code>session ticket</code>就简单多了，所以一般优先使用<code>session ticket</code>。</p></blockquote><ul><li><p><code>cipher_suite</code>: 服务端从客户端<code>ClientHello.cipher_suite</code>中选中的单个加密套件, 规定服务端应该选择其支持且存在于客户端支持列表中的最安全的密码套件。</p></li><li><p><code>compression_method</code>: 服务端从客户端<code>ClientHello.compression_methods</code>列表选中的单个压缩算法, 如果是执行快速恢复, 该值应该来自恢复会话状态中的压缩算法类型。</p></li><li><p><code>extensions</code>: 来自客户端<code>ClientHello.extension</code>中服务端支持的扩展列表。其应该是<code>ClientHello.extension</code>的子集。</p></li></ul><p><strong>Note</strong>:</p><ul><li>如果客户端接受到来自服务端的扩展属性, 但是<code>ClientHello.extension</code>中并不存在该属性，客户端必须发送<code>unsupported_extension</code>警报终止握手。</li><li>在<code>TLS</code>握手框架中, 为了应对未来可能的新增扩展, 规定客户端发送<code>ClientHello</code>消息时首先包含新扩展并包含空的<code>extension_data</code>来指示其支持该扩展类型, 在这种情况下, 客户端提供理解该扩展类型的能力, 服务端可以和客户端通过其提供的能力来交互。</li><li>扩展中不允许出现相同扩展类型</li></ul><p>抓包结果如下:</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/ServerHello.png" srcset="/img/loading.gif" lazyload alt="ServerHello.png"></p><hr><h6 id="server-certificate"><a class="markdownIt-Anchor" href="#server-certificate"></a> Server Certificate</h6><p>  无论何时使用证书认证身份来协商密钥交换方法都需要发送<code>Certificate</code>消息, 这个消息意味着:</p><ul><li>此消息将服务器的证书链发送给客户端</li><li>证书必须适用协商后的密码套件的密钥交换算法以及任何协商的扩展</li></ul><p><code>Certificate</code>是<code>TLS</code>握手的第二阶段, 第二阶段涉及数据包如下:</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5.png" srcset="/img/loading.gif" lazyload alt="第二阶段.png"></p><p>消息的结构如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">opaque ASN<span class="hljs-number">.1</span>Cert&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">24</span><span class="hljs-number">-1</span>&gt;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ASN<span class="hljs-number">.1</span>Cert certificate_list&lt;<span class="hljs-number">0.</span><span class="hljs-number">.2</span>^<span class="hljs-number">24</span><span class="hljs-number">-1</span>&gt;;<br>&#125; Certificate;<br></code></pre></td></tr></table></figure><ul><li><code>certificate_list</code>: 证书序列(证书链), 发送者的证书必须是证书链的第一个(也就是越高级的<code>CA</code>应该越在证书链的后面), 每一个后一级证书必须直接证明前一级证书。根证书可以省略</li></ul><p>相同的结构可能被用于客户端回复服务端的证书请求， 这时候如果客户端没有合适的证书可能在回复服务端身份认证请求(<code>authentication request</code>)消息中不包含证书。服务端发送的证书需要遵循如下规则:</p><ul><li>证书类型必须是<code>X.509v3</code>, 除非明确协商存在其他类型。</li><li>终端实体证书的公钥必须兼容选定密钥交换算法。</li></ul><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/TLS%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E5%A5%97%E4%BB%B6.png" srcset="/img/loading.gif" lazyload alt="TLS密钥交换套件.png"></p><p>需要注意的是，<code>ECDH</code> 和 <code>ECDSA</code> 公钥的数据结构是一样的。所以，<code>CA</code> 在签署一个证书的时候，可能要使用 <code>X.509 v3</code> 的 <code>keyUsage</code> 和 <code>extendedKeyUsage</code> 扩展来限定<code>ECC</code>公钥的使用方式。<code>ServerKeyExchange</code> 传递足够的信息给客户端，来让客户端交换 <code>premaster secret</code>。一般要传递的是：一个 <code>Diffie-Hellman</code> 公钥，或者一个其他算法(例如<code>RSA</code>)的公钥。在<code>TLS</code>实际部署中，我们一般只使用这4种：<code>ECDHE_RSA</code>, <code>DHE_RSA</code>, <code>ECDHE_ECDSA</code>，<code>RSA</code></p><p><strong>Note</strong>:</p><ul><li><code>server_name</code>和<code>trusted_ca_keys</code>扩展被用于指示证书的选择。</li><li>如果客户端提供一个签名算法(<code>signature_algorithms</code>)扩展, 接下来所有服务端提供的证书必须被扩展中出现的<code>hash/signature</code>算法签名, 这意味着包含一个密钥的证书可以使用不同的签名算法签名(如<code>RSA</code>密钥签名一个<code>DSA</code>密钥)。</li></ul><p>相关抓包:</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/Certificate.png" srcset="/img/loading.gif" lazyload alt="Certificate.png"></p><hr><h6 id="server-key-exchange-message"><a class="markdownIt-Anchor" href="#server-key-exchange-message"></a> Server Key Exchange Message</h6><p>  在服务器证书发送后(或者在匿名协商的情况下发送<code>ServerHello</code>之后), 这个消息将立即发送, 服务器仅在服务器证书消息不足以包含足够数据来允许客户端交换<code>premaster secret</code>时才发送<code>ServerKeyExchange</code>消息, 该消息发送将在如下密钥交换算法中发生:</p><ul><li><code>DHE_DSS</code></li><li><code>DHE_RSA</code></li><li><code>DH_anon</code></li></ul><p>如果交换算法时如下, <code>Server Key Exchange Message</code>消息将是非法的</p><ul><li><code>RSA</code></li><li><code>DH_DSS</code></li><li><code>DH_RSA</code></li></ul><p>其他密钥交换算法, 定义在<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc5246#ref-TLSECC">TLSECC</a>, 必须指定是否发送<code>ServerKeyExchange</code>消息, 如果包含了该消息, 消息的内容如下:</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/ServerDHParams%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0.png" srcset="/img/loading.gif" lazyload alt="ServerDHParams结构描述.png"></p><p>此消息传递加密相关信息以允许客户端来协商<code>premaster secret</code>, 客户端可以通过<code>Diffie-Hellman</code>公钥或者其他算法公钥来完成密钥交换(结果为<code>premaster secret</code>)。</p><ul><li><code>dh_p</code>: <code>Diffie-Hellman</code>算法的素数模</li><li><code>dh_g</code>: <code>Diffie-Hellman</code>算法的底数</li><li><code>dh_Ys</code>: 服务端<code>Diffie-Hellman</code>公钥(<code>g^X mod p</code>)</li></ul><p>关于<code>ServerKeyExchange</code>结构描述如下:</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/ServerKeyExchange%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0.png" srcset="/img/loading.gif" lazyload alt="ServerKeyExchange结构描述.png"></p><ul><li><code>params</code>: 服务端密钥交换的参数</li><li><code>signed_params</code>: 对于非匿名密钥交换，服务器对服务端密钥交换参数的签名。</li></ul><p>该报文仅在使用<code>DH</code>相关算法才会发送, <code>RSA</code>类公钥交换算法不需要发送, 抓包如下:</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/ServerKeyExchange.png" srcset="/img/loading.gif" lazyload alt="ServerKeyExchange.png"></p><p>一般现在支持的椭圆曲线有:</p><ul><li><code>SECP521R1</code></li><li><code>SECP256R1</code></li><li><code>SECP384R1</code></li></ul><p>  其中目前用的最广的是 <code>secp256r1</code> （还被称为 <code>P256</code>，或 <code>prime256v1</code>）, 椭圆曲线在<code>ClientHello</code>中通过<code>supported_groups</code>扩展列表向服务端表明其支持的椭圆曲线类型。</p><p>  需要注意, 如果客户端提供了 “<code>signature_algorithms</code>” 扩展， 则签名算法和<code>hash</code>算法必须是列在扩展中的算法。 要注意的是，这个地方可能有不一致，例如客户端可能提供了 <code>DHE_DSS</code> 密钥交换，但是 “<code>signature_algorithms</code>&quot;扩展中没有<code>DSA</code>算法，在这类情况下，为了正确地协商，服务器必须确保满足自己选择的<code>CipherSuite</code>满足 “<code>signature_algorithms</code>” 的限制。这不优雅，但是是为了把对原来的<code>CipherSuite</code>协商的设计的改动减到最小，而做的妥协。</p><hr><h6 id="certificate-request"><a class="markdownIt-Anchor" href="#certificate-request"></a> Certificate Request</h6><p>  如果所选的密码套件适当, 非匿名服务可以从客户端可选的请求一个证书, 如果这个消息发送, 将立即跟随<code>ServerKeyExchange</code>消息(如果这个消息发送的话, 否则跟随在服务端证书消息后发送)。</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/CertificateRequest%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0.png" srcset="/img/loading.gif" lazyload alt="CertificateRequest结构描述.png"></p><ul><li><code>certificate_types</code>: 客户端可以提供的证书类型列表<ul><li><code>rsa_sign</code>: 证书包含<code>RSA</code>密钥</li><li><code>dss_sign</code>: 证书包含<code>DSA</code>密钥</li><li><code>rsa_fixed_dh</code>: 证书包含一个静态<code>DH</code>密钥</li><li><code>dss_fixed_dh</code>: 证书包含一个静态<code>DH</code>密钥</li></ul></li><li><code>supported_signature_algorithms</code>: 服务端支持校验的<code>hash/signature</code>算法对列表, 按照偏好降序排列。</li><li><code>certificate_authorities</code>: 支持认证的<code>CA</code>列表, 需要是<code>DER</code>编码格式。</li></ul><p>这些 <code>distinguished names</code> 可能为<code>root CA</code>或者次级<code>CA</code>指定了想要的 <code>distinguished name</code> ，因此，这个消息可以用来描述已知的<code>root</code>，或者希望的授权空间。 如果 <code>certificate_authorities</code> 列表是空的，那么客户端可以发送任何适当的 <code>ClientCertificateType</code> 类型的证书，如果没有别的限制的话。</p><p><code>certificate_types</code> 和 <code>supported_signature_algorithms</code> 字段的交叉选择很复杂。 <code>certificate_types</code> 这个字段从<code>SSLv3</code>时代就定义了，但是一直都没有详细定义，其大多数功能都被 <code>supported_signature_algorithms</code> 代替了。 有如下规则：</p><ul><li>客户端提供的任何证书，必须用一个supported_signature_algorithms 中出现过的 hash/signature 算法对 签名.</li><li>客户端提供的末端证书必须提供一个和 <code>certificate_types</code> 兼容的<code>key</code>。 如果这个<code>key</code>是一个签名<code>key</code>，那必须能和 <code>supported_signature_algorithms</code> 中提供的某个 <code>hash/signature</code> 算法对配合使用。</li><li>由于历史原因，某些客户端证书类型的名字，包含了证书的签名算法，例如，早期版本的<code>TLS</code>中， <code>rsa_fixed_dh</code> 意思是一个被<code>RSA</code>算法签署，并且包含一个固定<code>DH</code>密钥的证书。在<code>TLS1.2</code>中，这个功能被 <code>supported_signature_algorithms</code> 淘汰，并且证书类型不再限制用来签署证书的算法。例如，如果服务器发送了 <code>dss_fixed_dh</code> 证书类型，和 <code>&#123; &#123;sha1, dsa&#125;, &#123;sha1,rsa&#125; &#125;</code> 签名类型，客户端可以回复一个 包含静态<code>DH</code>密钥，用<code>RSA-sha1</code>签署的证书。</li><li>如果协商出来的是匿名<code>CipherSuite</code>，服务器不能要求客户端认证。</li></ul><hr><h6 id="server-hello-done"><a class="markdownIt-Anchor" href="#server-hello-done"></a> Server Hello Done</h6><p>  服务端发送<code>ServerDone</code>指示<code>ServerHello</code>消息及其关联消息结束, 消息发送完后, 服务端将等待客户端回复。这个消息意味着服务端已经完成发送支持密钥交换相关步骤, 客户端可以继续进行它的密钥交换过程。接收到服务端<code>ServerHelloDone</code>消息后, 如果需要客户端应该校验服务端提供的有效证书并且检查服务端<code>hello</code>阶段参数是否可接收。</p><p>这个消息比较简单, 如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> &#125; ServerHelloDone;<br></code></pre></td></tr></table></figure><p>相关抓包:</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/ServerHelloDone.png" srcset="/img/loading.gif" lazyload alt="ServerHelloDone.png"></p><hr><h6 id="client-certificate"><a class="markdownIt-Anchor" href="#client-certificate"></a> Client Certificate</h6><p>  这是客户端在接受到服务端<code>ServerHelloDone</code>消息后可以发送的第一个消息, 这个消息仅在服务端请求客户端证书时才被发送, 如果没有合适的证书套件, 客户端必须发送一个不包含证书的<code>Client Certificate</code>消息, 这种情况下证书列表结构为0个长度。如果客户端不发送任何证书, 服务端可以自行决定是否在没有客户端身份认证情况下继续握手或者回复一个<code>handshake_failure</code>警报, 此外, 如果证书链某些方面是不可接收的(例如不是一个已知授信<code>CA</code>签署), 服务端可以自行决定是否继续握手(考虑到客户端未经身份认证)或发送<code>fatal</code>警报。</p><p>  此消息将客户端证书链发送给服务端, 服务端将验证证书相关信息(当客户端身份认证基于签名时)或计算<code>premaster secert</code>(对于非临时<code>Diffie-Hellman</code>), 该证书必须适用于协商密码套件的密钥交换算法和协商的扩展。</p><p>当数据包交换到这个, 已经处于<code>TLS</code>握手第三个阶段:</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5.png" srcset="/img/loading.gif" lazyload alt="第三阶段.png"></p><p>注意:</p><ul><li>证书必须是<code>X.509v3</code>格式, 除了其他自行协商的</li><li>终端实体证书公钥(以及关联相关限制)需要兼容<code>CertificateRequest</code>中证书类型列表</li></ul><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%81%E4%B9%A6%E7%B1%BB%E5%9E%8B%E5%A5%97%E4%BB%B6.png" srcset="/img/loading.gif" lazyload alt="客户端证书类型套件.png"></p><ul><li>如果<code>CertificateRequest.certificate_authorities</code>列表非空, 证书链中证书需要有其列出的<code>ca</code>之一颁发。</li><li>证书必须适用可接收的<code>hash/signature</code>算法对签名.</li></ul><hr><h6 id="client-key-exchange-message"><a class="markdownIt-Anchor" href="#client-key-exchange-message"></a> Client Key Exchange Message</h6><p>  客户端总是会发送这个消息, 它必须紧跟<code>client certificate</code>消息后面(如果该消息发送的话), 否则, 当前消息必须是接收到<code>ServerHelloDone</code>消息后客户端发送的第一个消息。</p><p>  通过该消息, <code>premaster secret</code>已经被确定, 可以通过<code>RSA</code>加密密钥传输或者传输<code>Diffie-Hellman</code>参数(这允许各方协商出一个相同的<code>premaster secert</code>), 当客户端使用临时<code>DH</code>指数时, 这个消息包含客户端<code>Diffie-Hellman</code>公开值, 如果客户端发送包含一个静态<code>DH</code>指数的证书时(如使用<code>fixed_dh</code>进行客户端认证), 这个消息必须发送但是必须为空。</p><p>相关的数据结构如下:</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/ClientKeyExchange%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0.png" srcset="/img/loading.gif" lazyload alt="ClientKeyExchange结构描述.png"></p><p>具体选中什么样的信息取决于所选择的密钥交换方法, 具体密钥交换方法可参考<code>ServerKeyExchange</code>一节。</p><ul><li><code>RSA-Encrypted Premaster Secret Message</code><br>  如果使用<code>RSA</code>来进行密钥协商和身份认证, 客户端产生一个<code>48 Bytes</code>预主密钥(<code>premaster secert</code>), 使用服务器证书中公钥加密它并发送加密后的<code>premaster secert</code>消息。如下结构是<code>ClientKeyExchange</code>消息的变体而不是消息本身。</li></ul><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/EncryptedPreMasterSecert%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3.png" srcset="/img/loading.gif" lazyload alt="EncryptedPreMasterSecert结构详解.png"></p><blockquote><ul><li><code>pre_master_secret</code>: 客户端产生的随机值(<code>48Bytes</code>)来用于产生主密钥。</li></ul></blockquote><p><strong>注意:</strong><br>  <code>PreMasterSecert</code>结构中的版本是由客户端<code>ClientHello.client_version</code>提供, 而不是连接协商的版本, 它的特点是防止回滚攻击, 不幸的是, 一些老的实现还是用的协商版本来代替, 因此一些检查版本号可能会让一些非正确实现的客户端协商失败。</p><p>  客户端实现必须总是在<code>preMasterSecert</code>中发送正确的版本号, 如果<code>ClientHello.client_version</code>的版本是<code>TLS 1.1</code>或者更高, 服务端实现必须按照如下检查版本号, 如果版本是<code>TLS 1.0</code>或者之前, 服务器实现应该检查版本号, 但是可能存在一个配置选项去失能这个检查, 如果检查失败, <code>PreMasterSecert</code>应该按照如下所述随机化。</p><p><strong>注意</strong>:<br>  一些人发现, 可以通过攻击<code>TLS</code>服务器, 查看解密后是否存在特定的信息, 如正确的<code>PKCS#1</code>格式, 包含有效的<code>PreMasterSecert</code>结构, 或者是否存在正确的版本号等, 这些缺陷可以通过一些手段避免(如处理不正确格式消息块 或者 对于不匹配的版本号以一种正确的方式格式化<code>RSA</code>块)。</p><ol><li>产生一个<code>46 Bytes</code>字节的字符串<code>R</code></li><li>解码该消息来恢复明文<code>M</code></li><li>步骤如下</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (PKCS#<span class="hljs-number">1</span> 填充不正确, 或者消息M长度不足 <span class="hljs-number">48</span> Bytes)<br>    pre_master_secret = ClientHello.client_version || R<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ClientHello.client_version &lt;= TLS <span class="hljs-number">1.0</span> 或者 版本号检查被明确失能)<br>    pre_master_secret = M<br><span class="hljs-keyword">else</span><br>    pre_master_secret = ClientHello.client_version || M[<span class="hljs-number">2.</span><span class="hljs-number">.47</span>]<br></code></pre></td></tr></table></figure><p>目前还没有明确的针对这种方式的攻击, 因此该种构造方式被推荐。</p><p>抓包记录:</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/ClientKeyExchange.png" srcset="/img/loading.gif" lazyload alt="ClientKeyExchange.png"></p><hr><ul><li><code>Client Diffie-Hellman Public Value</code><br>  如果还没有包含客户端证书, 这个结构传达了客户端<code>Diffie-Hellman</code>公钥值(<code>Yc</code>), 使用枚举<code>PublicValueEncoding</code>来决定<code>Yc</code>的编码值，这个结构是客户端密钥交换消息的变体而不是本身。</li></ul><p>消息结构如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> implicit, explicit &#125; PublicValueEncoding;<br></code></pre></td></tr></table></figure><blockquote><ul><li><code>implicit</code>: 如果客户端发送了一个包含合适<code>Diffie-Hellman</code>密钥的证书(用于<code>fixed_dh</code>客户端认证), 接下来<code>Yc</code>变成隐式的并且不在需要再次发送, 在这种情况下, 客户端密钥交换消息将被发送但是必须为空。</li><li><code>explicit</code>: <code>Yc</code>需要发送</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    select (PublicValueEncoding) &#123;<br>        <span class="hljs-keyword">case</span> implicit: <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> &#125;;<br>        <span class="hljs-keyword">case</span> explicit: opaque dh_Yc&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>    &#125; dh_public;<br>&#125; ClientDiffieHellmanPublic;<br></code></pre></td></tr></table></figure><blockquote><ul><li><code>dh_Yc</code>: 客户端<code>Diffie-Hellman</code>公钥值(<code>Yc</code>)</li></ul></blockquote><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/ClientKeyExchange_DH.png" srcset="/img/loading.gif" lazyload alt="ClientKeyExchange.png"></p><hr><h6 id="certificate-verify"><a class="markdownIt-Anchor" href="#certificate-verify"></a> Certificate Verify</h6><p>  当需要做客户端认证时，客户端发送<code>CertificateVerify</code>消息，来证明自己确实拥有客户端证书的私钥, 这个消息提供客户端证书明确的校验, 这个消息仅在客户端证书(具备签名能力)后发送(如包含除了固定<code>Diffie-Hellman</code>参数以外的所有证书), 当发送时它必须立即跟随在客户端密钥交换消息后面。</p><p>消息结构如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    digitally-<span class="hljs-type">signed</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        opaque handshake_messages[handshake_messages_length];<br>    &#125;<br>&#125; CertificateVerify;<br><br></code></pre></td></tr></table></figure><p>  这里<code>handshake_messages</code>参考了所有发送和接收的握手消息, 从客户端<code>ClientHello</code>开始直到但是不包括本消息, 包括消息的类型以及长度字段, 这是包含了所有早期握手消息的结构, 注意这要求双方缓存之前所有消息或在接受消息时使用<code>hash</code>算法计算相关消息的散列值直到接受<code>CertificateVerify</code>消息, 服务端可以在<code>CertificateRequest</code>消息中提供一个有线的摘要算法集来最小化计算开销。</p><p>  签名中使用的哈希和签名算法必须在<code>CertificateRequest</code>消息的<code>supported_signature_algorithms</code>字段展示, 此外, <code>hash</code>和签名算法必须兼容客户端实体证书中的密钥<code>key</code>, 如果可以的话， <code>RSA</code>密钥可以被用于任意允许的<code>HASH</code>算法, 证书中的受限主题。</p><p>  因为<code>DSA</code>签名不包含任何安全<code>hash</code>算法指示, 如果多次<code>hash</code>可以和任意密钥一起使用, 这存在<code>hash</code>替换的风险, 当前, <code>DSA[DSS]</code>可能只是使用<code>SHA-1</code>, 未来<code>DSS[DSS-3]</code>的修订版本将允许在<code>DSA</code>使用其他数字摘要算法, 以及应该使用那些摘要算法以及每个密钥的大小, 此外, 未来修订版本将指示那些数字摘要算法和<code>DSA</code>一起使用。</p><hr><h6 id="finished"><a class="markdownIt-Anchor" href="#finished"></a> Finished</h6><p>  当数据包接收到<code>change Cipher spec</code>数据包, 密钥交换和身份认证已经完成了, 由于<code>Change Cipher Spec</code>已经属于<code>changeCipherspec</code>协议而不属于<code>handshake</code>的一部分, 因此第四部分握手报文写在这里。</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5.png" srcset="/img/loading.gif" lazyload alt="第四阶段.png"></p><p>  由于<code>Finish</code>报文总是使用新协商的密钥发送, 因此如果报文没有解密是无法看到的。</p><p>  一条<code>Finish</code>消息总是在<code>change cipher spec</code>消息之后立即发出，以验证密钥交换和身份认证过程是否成功, 必要的时<code>change cipher spec</code>消息一般在其他握手消息和<code>Finish</code>消息之间。</p><p>  这个<code>Finshed</code>消息是第一个被协商算法、密钥和密码保护，<code>Finshed</code>消息的接收人必须校验内容的正确性, 一旦发送了<code>Finshed</code>消息或者从对端接受到一个合法的<code>Finshed</code>, 它可以通过该连接发送和接受应用层数据。</p><p>消息结构如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    opaque verify_data[verify_data_length];<br>&#125; Finished;<br></code></pre></td></tr></table></figure><ul><li><code>verify_data</code>: 计算公式如下</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">PRF(master_secret, finished_label, Hash(handshake_messages))<br>            [<span class="hljs-number">0.</span>.verify_data_length<span class="hljs-number">-1</span>];<br></code></pre></td></tr></table></figure><ul><li><code>finished_label</code>: 对于客户端发送的<code>Finshed</code>消息, 字符串是<code>client finished</code>, 对于服务端发送的<code>Finished</code>消息, 这个字符串是<code>server finished</code>。</li></ul><p><code>Hash</code>表示<code>handshake</code>消息的<code>Hash</code>值, 对于<code>PRF</code>定义在 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc5246#section-5">【section 5】</a>, 对于<code>PRF</code> <code>Hash</code>必须是作为基础<code>Hash</code>, 任何定义不同<code>PRF</code>的密码套件必须也要定义<code>Finshed</code>计算使用的<code>Hash</code>。</p><p>  在之前的<code>TLS</code>版本, <code>verify_data</code>总是<code>12 Bytes</code>长, 在当前<code>TLS 1.2</code>版本中, 它依赖于使用的密码套件, 任何没有明确指定的密码套件<code>verify_data</code>长度有一个<code>verify_data_length</code>值为<code>12</code>, 这包括了所有已经存在的密码套件, 这表示于之前的版本具有相同的编码, 未来密码套件可能规定其他长度但是必须至少<code>12 Btes</code>。</p><ul><li><code>handshake_messages</code>: 这是握手过程中所有的消息数据(不包括任何<code>HelloRequest</code>消息), 但是不包括本消息, 这仅包括握手层可见的数据且不包括记录层头部, 这包括所有定义在<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc5246#section-7.4">【section 7.4】</a> 中的握手结构(截至目前为止交换的握手消息结构)。</li></ul><p>如果在<code>Finshed</code>消息之前握手流程中没有收到<code>ChangeCipherSpec</code>消息, 将导致一个<code>fatal</code>警报。</p><p><code>handshake_messages</code>包含所有<code>clientHello</code>开始到<code>Finished</code>握手过程(不包括<code>Finshed</code>消息)中的消息, 这可能与 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc5246#section-7.4.8">【7,4,8】</a>中的<code>handshake_messages</code>不同, 因为它包括<code>CertificateVerify</code>消息(如果发送), 此外, 客户端发送的<code>Finished</code>消息的<code>handshake_messages</code>将与服务端发送的<code>Finished</code>消息不同, 因为第二个发送会包括前一个包。</p><p><strong>注意</strong>:</p><ul><li><code>ChangeCipherSpec</code>消息、<code>alerts</code>和其他齐鲁类型不是握手消息, 也不包括在<code>hash</code>计算中, 同时, <code>Hellorequest</code>消息也从<code>handshake</code>的<code>hash</code>计算中省略。</li></ul><h6 id="交互流程"><a class="markdownIt-Anchor" href="#交互流程"></a> 交互流程</h6><p>至此<code>TLS</code>交互过程中所有的数据包都已经讲解过了, 接下来从整体交互流程来看一下交互过程。<br>如下是简述交互流程:</p><ul><li><p>通过<code>RSA</code>交互<br><img src="/2023/08/16/tls/protocol/tls1_2/085339/handshake%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt="handshake交互过程.png"></p></li><li><p>通过<code>DH</code>交互<br><img src="/2023/08/16/tls/protocol/tls1_2/085339/handshake%E9%80%9A%E8%BF%87DH%E4%BA%A4%E6%8D%A2%E5%AF%86%E9%92%A5%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt="handshake通过DH交换密钥流程.png"></p></li></ul><p>以上两种都是完整的会话握手过程, 那假设会话之前已经握手过并交换了参数, 服务端和客户端需要进行快速握手恢复, 而快速握手又分为两种, 基于<code>SessionId</code>的恢复和基于<code>SessionTicket</code>。</p><ul><li>基于<code>SessionId</code>流程如下:</li></ul><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/%E4%BC%9A%E8%AF%9D%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt="会话恢复流程.png"></p><ul><li>基于<code>SessionTicket</code>流程如下:</li></ul><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/%E5%9F%BA%E4%BA%8EsessionTicket%E7%9A%84%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D.png" srcset="/img/loading.gif" lazyload alt="基于sessionTicket的快速恢复.png"></p><hr><h4 id="cryptographic-computations"><a class="markdownIt-Anchor" href="#cryptographic-computations"></a> Cryptographic Computations</h4><p>  为了开始连接保护, <code>TLS</code>记录协议需要一套算法规范, 一个主密钥, 以及客户端和服务端随机值, 认证、加密以及<code>mac</code>算法 由服务端通过密钥套件决定, 并在<code>ServerHello</code>中显示, 压缩算法也在<code>hello</code>消息中协商, 随机数值在<code>hello</code>中交换, 剩下的就是计算主密钥。</p><h5 id="cryptographic-computations-2"><a class="markdownIt-Anchor" href="#cryptographic-computations-2"></a> Cryptographic Computations</h5><p>  对于所有密钥交换方法, 都使用相同算法将<code>pre_master_secert</code>转换为<code>master_secert</code>, 一旦<code>master_secert</code>已经计算应该删除内存中<code>pre_master_secert</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">master_secret = PRF(pre_master_secret, <span class="hljs-string">&quot;master secret&quot;</span>,<br>                      ClientHello.random + ServerHello.random)<br>                      [<span class="hljs-number">0.</span><span class="hljs-number">.47</span>];<br></code></pre></td></tr></table></figure><p>主密钥长度总是刚好<code>48Bytes</code>, 预主密钥的长度将根据密钥交换方法而不同。</p><hr><h6 id="rsa"><a class="markdownIt-Anchor" href="#rsa"></a> RSA</h6><p>  当使用<code>RSA</code>进行服务器身份认证和密钥交换, <code>48 Bytes</code>预主密钥由客户端产生, 通过服务端公钥加密并发送给服务端, 服务端使用私钥进行解密得到预主密钥, 双方按照指示将预主密钥转换为主密钥完成密钥交换。</p><h6 id="diffie-hellman"><a class="markdownIt-Anchor" href="#diffie-hellman"></a> Diffie-Hellman</h6><p>  进行常规<code>Diffie-Hellman</code>计算, 得到的协商密钥(<code>Z</code>)被用于预主密钥, 并转换为主密钥, 如上所述, <code>Z</code>包含了所有前导零字节并用在预主密钥。</p><p><strong>注意</strong>:</p><ul><li><code>Diffie-Hellman</code>参数由服务端指定, 要么是临时参数要么是包含在服务器证书中。</li></ul><h4 id="mandatory-cipher-suites"><a class="markdownIt-Anchor" href="#mandatory-cipher-suites"></a> Mandatory Cipher Suites</h4><p>  当应用程序没有指定的情况下, 一个兼容的<code>TLS</code>程序必须实现<code>TLS_RSA_WITH_AES_128_CBC_SHA</code>密码套件。</p><h4 id="application-data-protocol"><a class="markdownIt-Anchor" href="#application-data-protocol"></a> Application Data Protocol</h4><p>  应用层数据由记录层携带, 并基于当前连接状态进行分段、压缩、加密, 消息相对于记录层相当于透传。</p><hr><h4 id="新增密码套件"><a class="markdownIt-Anchor" href="#新增密码套件"></a> 新增密码套件</h4><p>  <code>TLS</code>协议定义了大量的加密套件, 这些加密套件指定了密钥交换、加密、认证、完整性校验等一系列算法, 密码套件命名如下:</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/TLS%E5%AF%86%E9%92%A5%E5%A5%97%E4%BB%B6%E5%91%BD%E5%90%8D.png" srcset="/img/loading.gif" lazyload alt="TLS密钥套件命名.png"></p><p><code>TLS1.2</code>在之前的版本支持的密码套件意外, 基于<code>hmac-sha256</code>新增了如下几个密码套件。</p><ul><li><code>CipherSuite TLS_NULL_WITH_NULL_NULL</code></li></ul><p>//服务器提供<code>RSA</code>证书</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/TLS12_RSA_suit.png" srcset="/img/loading.gif" lazyload alt="TLS12_RSA_suit.png"></p><blockquote><p>以下密码套件定义用于服务器身份验证(也可以选择通过客户端身份验证)的<code>Diffie-Hellman</code>.<code>DH</code>表示服务器证书包含<code>ca</code>签名的<code>Diffie-Hellman</code>参数, <code>DHE</code>表示临时<code>Diffie-Hellman</code>, 其中<code>Diffie-Hellman</code>参数由具有签名功能的证书签名.</p></blockquote><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/TLS12_DH_DHE_suit.png" srcset="/img/loading.gif" lazyload alt="TLS12_DH_DHE_suit.png"></p><blockquote><p>以下密码套件是完全基于匿名<code>DH</code>通讯, 双方没有身份验证, 容易受到中间人攻击, <code>TLS1.2</code>实现绝对不能使用这些密码套件, 除非应用层明确允许匿名密钥交换。</p></blockquote><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/TLS12_DH_ANON_suit.png" srcset="/img/loading.gif" lazyload alt="TLS12_DH_ANON_suit.png"></p><p>从上面可以看出, <code>TLS</code>支持很多的密码套件, 不同密码套件的性能也各不一样, 如下是来自网上不同密码套件性能对比。</p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/tls%E5%90%84%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94.png" srcset="/img/loading.gif" lazyload alt="tls各算法的性能对比.png"></p><p><img src="/2023/08/16/tls/protocol/tls1_2/085339/%E5%90%84%E7%A7%8D%E7%AE%97%E6%B3%95%E5%8A%A0%E5%AF%86%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94.png" srcset="/img/loading.gif" lazyload alt="各种算法加密性能对比.png"></p><p>密码套件种类繁多, 关于密码套件的使用和选择很容易出错, 可以参考 <a target="_blank" rel="noopener" href="https://wiki.mozilla.org/Security/Server_Side_TLS#Recommended_configurations">权威文档</a></p><hr><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><ul><li><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc5246">RFC5246 - The Transport Layer Security (TLS) Protocol Version 1.2</a></li><li><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/rfc6066">RFC6066 - TLS Extensions: Extension Definitions(RFC5246)</a></li><li><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc4366">RFC4366 - Transport Layer Security (TLS) Extensions</a></li><li><a target="_blank" rel="noopener" href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4">Transport Layer Security (TLS) Parameters</a></li><li><a target="_blank" rel="noopener" href="https://www.biaodianfu.com/https-ssl-tls.html">理解 HTTPS 原理，SSL/TLS协议详解</a></li><li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/jcQXL0mLVkCM9ISayVEAmQ#at">字节二面：优化 HTTPS 的手段，你知道几个？</a></li><li><a target="_blank" rel="noopener" href="https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/">SSL/TLS协议详解</a></li><li><a target="_blank" rel="noopener" href="https://aijishu.com/a/1060000000338161">【憨豆话安全】TLS的前世今生</a></li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" class="category-chain-item">密码学</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%8E%9F%E5%88%9B/">#原创</a> <a href="/tags/TLS1-2/">#TLS1.2</a></div></div><div class="license-box my-3"><div class="license-title"><div>tls1.2协议原理</div><div>http://example.com/2023/08/16/tls/protocol/tls1_2/085339/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>EtcFly</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年8月16日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2024年3月5日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2023/08/16/tls/protocol/tls1_0/085550/" title="tls1.0协议原理"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">tls1.0协议原理</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2023/08/16/tls/protocol/tls1_3/085339/" title="tls1.3协议原理"><span class="hidden-mobile">tls1.3协议原理</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="waline"></div><script type="text/javascript">Fluid.utils.loadComments("#waline",(function(){Fluid.utils.createCssLink("https://lib.baomitu.com/waline/2.14.1/waline.min.css"),Fluid.utils.createScript("https://lib.baomitu.com/waline/2.14.1/waline.min.js",(function(){var i=Object.assign({serverURL:"https://etcfly.top:14000/",path:"window.location.pathname",meta:["nick","mail","link"],requiredMeta:["nick"],lang:"zh-CN",emoji:["https://unpkg.com/@waline/emojis@1.1.0/qq"],dark:'html[data-user-color-scheme="dark"]',wordLimit:0,pageSize:10},{el:"#waline",path:window.location.pathname});Waline.init(i),Fluid.utils.waitElementVisible("#waline .vcontent",()=>{var i="#waline .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://github.com/EtcFly" target="_blank" rel="nofollow noopener"><span>Copyright</span></a> <i class="iconfont icon-copyright"></i> <a href="https://etcfly.top:14100/share/yqTLFDlP/%E4%BB%97%E5%89%91%E8%B5%B0%E5%A4%A9%E6%B6%AF" target="_blank" rel="nofollow noopener"><span>2018-2024 EtcFly</span></a><div style="font-size:.85rem"><span>总访问量 <span style="color:#000" id="PVstatic">0</span> 次&nbsp</span> <span>总访客数 <span style="color:#000" id="UVstatic">0</span> 人&nbsp</span> <span>当前在线 <span style="color:#000" id="ACTstatic">0</span> 人&nbsp</span><script src="https://etcfly.top:14200/statistics" defer></script></div><div style="font-size:.85rem"><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="js/duration.js"></script></div></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener"></a> </span><span><a href="http://beian.miit.gov.cn/2023000858" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" alt="police-icon"> <span>浙ICP备2023000858号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/jquery.min.js"></script><script src="/live2d-widget/autoload.js"></script><script src="/js/star.js"></script><script src="/js/ribbon.min.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>