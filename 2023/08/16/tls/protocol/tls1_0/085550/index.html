<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="EtcFly"><meta name="keywords" content=""><meta name="description" content="版权归作者所有, 转载请保留该部分声明。本文作者：EtcFly原文地址：https:&#x2F;&#x2F;etcfly.top               版权声明 版权所有（C）互联网协会（1999）。 版权所有。  概述   本文档规定了传输层安全Transport Layer Security（TLS）协议的版本1.0。 TLS协议通过Internet提供隐私通信。该协议允许客户端&#x2F;"><meta property="og:type" content="article"><meta property="og:title" content="tls1.0协议原理"><meta property="og:url" content="http://example.com/2023/08/16/tls/protocol/tls1_0/085550/"><meta property="og:site_name" content="仗剑走天涯"><meta property="og:description" content="版权归作者所有, 转载请保留该部分声明。本文作者：EtcFly原文地址：https:&#x2F;&#x2F;etcfly.top               版权声明 版权所有（C）互联网协会（1999）。 版权所有。  概述   本文档规定了传输层安全Transport Layer Security（TLS）协议的版本1.0。 TLS协议通过Internet提供隐私通信。该协议允许客户端&#x2F;"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/chipher.png"><meta property="article:published_time" content="2023-08-16T08:55:50.000Z"><meta property="article:modified_time" content="2024-03-05T03:41:03.000Z"><meta property="article:author" content="EtcFly"><meta property="article:tag" content="原创"><meta property="article:tag" content="TLS1.0"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/img/chipher.png"><title>tls1.0协议原理 仗剑走天涯</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/fluid-extention.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:4},web_analytics:{enable:!0,follow_dnt:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"3AEufnWAJdp8cFODp1DXvrQU-MdYXbMMI",app_key:"mGJiL6xVvYv21ygqfynJoCyO",server_url:null,path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Strive For Dream</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="tls1.0协议原理"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-08-16 08:55" pubdate>2023年8月16日 早上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 59k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 496 分钟 </span><span id="vvdpost_container_page_pvuv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="vvdpost_value_page_pv">0</span> 次&nbsp&nbsp <i class="iconfont icon-users" aria-hidden="true"></i> <span id="vvdpost_value_page_uv">0</span> 人</span><script>console.log(window.location.pathname);var httpRequest=new XMLHttpRequest;httpRequest.open("POST","https://etcfly.top:14200/poststats",!0),httpRequest.setRequestHeader("Content-type","application/json"),httpRequest.send(JSON.stringify(window.location.pathname)),httpRequest.onreadystatechange=function(){if(4==httpRequest.readyState&&200==httpRequest.status){var e=httpRequest.responseText,t=JSON.parse(e);console.log(t.pv);var o=document.querySelector("#vvdpost_container_page_pvuv");if(console.log(o),o){var n=document.querySelector("#vvdpost_value_page_pv");console.log(n);var s=document.querySelector("#vvdpost_value_page_uv");console.log(s),s&&s&&(n.innerText=t.pv,s.innerText=t.uv,o.style.display="inline")}}}</script></div></div></div></div></div></div><script async src="https://etcfly.top:14100/script.js" data-website-id="1a5c096d-21e5-4556-99b0-28c810c9c868"></script></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">tls1.0协议原理</h1><p class="note note-info">本文最后更新于：2024年3月5日 凌晨</p><div class="markdown-body"><div class="note note-success"><p>版权归作者所有, 转载请保留该部分声明。<br>本文作者：EtcFly<br>原文地址：<a target="_blank" rel="noopener" href="https://etcfly.top">https://etcfly.top</a></p></div><hr><hr><h2 id="版权声明"><a class="markdownIt-Anchor" href="#版权声明"></a> 版权声明</h2><p>版权所有（C）互联网协会（1999）。 版权所有。</p><h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><p>  本文档规定了传输层安全<code>Transport Layer Security（TLS）</code>协议的版本<code>1.0</code>。 <code>TLS</code>协议通过<code>Internet</code>提供隐私通信。该协议允许客户端/服务器应用程序以旨在防止窃听、篡改或消息伪造的方式进行通信。</p><h2 id="1介绍"><a class="markdownIt-Anchor" href="#1介绍"></a> 1.介绍</h2><p>  <code>TLS</code>协议的主要目标是在两个通信应用之间提供隐私和数据完整性。协议由两层组成：<code>TLS</code>记录(<code>Record</code>)协议和<code>TLS</code>握手(<code>Handshake</code>)协议。在最底层，在一些可靠的传输协议（例如，<code>TCP [TCP]</code>）之上，是<code>TLS</code>记录协议。<code>TLS</code>记录协议提供了具有两个基本的连接安全性特性：</p><ul><li><p>连接是私有的。对称加密用于数据加密（例如，<code>DES [DES]</code>，<code>RC4 [RC4]</code>等）。这种对称加密的密钥是为每个连接唯一生成的，并且基于另一个协议协商的机密信息(<code>secret</code>)（如TLS握手协议）。记录协议也可以在没有加密的情况下使用。</p></li><li><p>连接是可靠的。消息传输包括使用密钥MAC的消息完整性检查。安全散列函数（例如，<code>SHA</code>，<code>MD5</code>等）用于<code>MAC</code>计算。记录协议可以在没有<code>MAC</code>的情况下运行，但这通常仅在另一个协议利用记录协议作为传输工具来协商安全参数的时候才会发生。</p></li></ul><p><code>TLS</code>记录协议用于封装各种较高级协议。而<code>TLS</code>握手协议允许服务器和客户端彼此认证，并在应用协议发送或接收其第一个数据字节之前协商加密算法和加密密钥。<code>TLS</code>握手协议提供的连接安全性有三个基本属性：</p><ul><li><p>对等体的身份认证可以使用非对称或公钥加密（例如，<code>RSA [RSA]</code>，<code>DSS [DSS]</code>等）算法。该认证可以是可选的，但对于至少一个对等体通常是必需的。</p></li><li><p>共享机密信息(<code>secret</code>)的协商是安全的：协商的机密信息(<code>secret</code>)不可用于窃听者，并且对于任何经过身份验证的连接，即使能够将自己置于连接中的攻击者也无法获得该机密信息(<code>secret</code>)。</p></li><li><p>协商是可靠的：没有攻击者可以在不被通信方发现的情况下修改协商通信。</p></li></ul><p><code>TLS</code>的一个优点是它与应用协议无关。高级协议可以透明地层叠在<code>TLS</code>协议之上。然而，<code>TLS</code>标准没有指定协议如何使用TLS添加安全性;关于如何启动<code>TLS</code>握手以及如何解释交换的认证证书的决定取决于在<code>TLS</code>之上运行的协议的设计者和实现者的判断。</p><hr><h2 id="2目标"><a class="markdownIt-Anchor" href="#2目标"></a> 2.目标</h2><p><code>TLS</code>协议的目标是按照优先顺序：</p><ol><li>加密安全性：<code>TLS</code>应用于建立双方之间的安全连接。</li><li>互操作性：独立的程序员应该能够开发使用<code>TLS</code>的应用程序，然后能够成功地交换加密参数，而不需要彼此了解代码。</li><li>可扩展性：<code>TLS</code>旨在提供一个可以根据需要纳入新公钥和批量加密方法的框架。 这也将实现两个次级目标：防止创建新协议(并冒险引入可能的新漏洞)，并避免不得不为此实现一整套新的安全库。</li><li>相对效率：加密操作往往是<code>CPU</code>密集型，特别是公钥操作。因此，TLS协议已经结合了可选的会话高速缓存方案，以减少需要从头开始建立的连接数。另外，已经注意减少网络活动。</li></ol><h2 id="3本文档的目标"><a class="markdownIt-Anchor" href="#3本文档的目标"></a> 3.本文档的目标</h2><p>  本文档和<code>TLS</code>协议本身是基于<code>Netscape</code>发布的<code>SSL 3.0</code>协议规范。此协议与<code>SSL 3.0</code>之间的区别并不明显，但它们足够重要，因为<code>TLS 1.0</code>和<code>SSL 3.0</code>不能互操作（尽管<code>TLS 1.0</code> 确实包含一个机制使一个<code>TLS</code>实现可以降级为 <code>SSL 3.0</code>）。</p><p>  本文档主要面向将要执行协议的读者以及进行加密分析的用户。这个说明书写在这一点上，它的目的是反映这两个组的需要。因此，许多算法依赖的数据结构和规则都包含在文本正文中（与附录相反），可以更容易地访问它们。</p><p>  本文档不是为了提供服务定义和接口定义的任何细节，尽管它涵盖了保护安全性所需的选择政策领域。</p><h2 id="4描述语言"><a class="markdownIt-Anchor" href="#4描述语言"></a> 4.描述语言</h2><p>  本文档涉及外部表示中数据的格式化。 将使用以下非常基本和稍微定义的演示语法。 该语法从其结构中的多个来源获取。 虽然它的语法和<code>XDR [XDR]</code>的语法和意图类似于编程语言<code>“C”</code>，但是绘制太多的并行体系将是冒险的。 此演示语言的目的仅在于记录<code>TLS</code>，而不是超出该特定目标的一般应用。</p><h3 id="41-基本块大小"><a class="markdownIt-Anchor" href="#41-基本块大小"></a> 4.1 基本块大小</h3><p>  明确指定所有数据项的表示。 基本数据块大小是一个字节（即<code>8</code>位）。 多字节数据项是从左到右从上到下的字节连接。 从字节流中，通过以下方式形成多字节项（示例中的数字）（使用<code>C</code>表示法）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">value = (byte[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">8</span>*(n<span class="hljs-number">-1</span>)) | (byte[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>*(n<span class="hljs-number">-2</span>)) |<br>... | byte[n<span class="hljs-number">-1</span>];<br></code></pre></td></tr></table></figure><p>多字节值的字节排序是常见的网络字节顺序或大端(<code>big endian</code>)格式。</p><h3 id="42-其他"><a class="markdownIt-Anchor" href="#42-其他"></a> 4.2 其他</h3><p>注释以<code>“/ *”</code> 开头，以 <code>“* /”</code> 结尾。<br>可选组件用 <code>“[[]]”</code> 括号括起来表示。<br>包含未解释数据的单字节实体的类型不透明。</p><h3 id="43-向量vectors"><a class="markdownIt-Anchor" href="#43-向量vectors"></a> 4.3 向量(Vectors)</h3><p>  向量（单尺寸数组）是同种数据元素的流。可以在编写文档规范时指定向量的大小，或者在运行时指定向量的大小。在任一情况下，长度都会声明向量中的字节数，而不是元素的数量。用于指定类型T的固定长度向量的新类型<code>T'</code>的语法是:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">T T<span class="hljs-number">&#x27;</span>[n];<br></code></pre></td></tr></table></figure><p>这里<code>T'</code>在数据流中占据<code>n</code>个字节，其中<code>n</code>是<code>T</code>的大小的倍数。矢量的长度不包括在编码流中。</p><p>在以下示例中，<code>Datum</code>被定义为协议不解释的三个连续字节，而<code>Data</code>是连续三个<code>Datum</code>，共耗用<code>9</code>个字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">opaque Datum[<span class="hljs-number">3</span>]; <span class="hljs-comment">/* three uninterpreted bytes */</span><br>Datum Data[<span class="hljs-number">9</span>]; <span class="hljs-comment">/* 3 consecutive 3 byte vectors */</span><br></code></pre></td></tr></table></figure><p>  可变长度向量通过使用符号<code>&lt;floor..ceiling&gt;</code>指定法定长度的子范围来定义。 当编码时，实际长度在字节流中的向量的内容之前。 长度将以数字的形式消耗尽可能多的字节，以保持向量的指定最大(<code>ceiling</code>)长度。 具有实际长度字段为零的可变长度向量被称为空向量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">T T<span class="hljs-number">&#x27;</span>&lt;<span class="hljs-built_in">floor</span>..ceiling&gt;;<br></code></pre></td></tr></table></figure><p>  在以下示例中，<code>mandatory</code>是必须包含类型为<code>opaque</code>的<code>300</code>到<code>400</code>字节之间的向量。 它永远不会是空的。实际长度字段消耗两个字节，一个<code>uint16</code>，足以表示值<code>400</code>（参见第<code>4.4</code>节）。 另一方面，<code>longer</code>可以表示多达<code>800</code>字节的数据，或<code>400</code>个<code>uint16</code>元素，它可能为空。 它的编码将包括一个两字节的实际长度字段，前面是向量。编码向量的长度必须是单个元素的长度的偶数倍（例如，<code>uint16</code>的<code>17</code>字节向量将是非法的）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">opaque mandatory&lt;<span class="hljs-number">300.</span><span class="hljs-number">.400</span>&gt;; <span class="hljs-comment">/* length field is 2 bytes, cannot be empty */</span><br>uint16 longer&lt;<span class="hljs-number">0.</span><span class="hljs-number">.800</span>&gt;; <span class="hljs-comment">/* zero to 400 16-bit unsigned integers */</span><br></code></pre></td></tr></table></figure><hr><h3 id="44-数字numbers"><a class="markdownIt-Anchor" href="#44-数字numbers"></a> 4.4 数字(Numbers)</h3><p>  基本数字数据类型是无符号字节（<code>uint8</code>）。所有较大的数字数据类型由固定长度的字节序列组成，如第<code>4.1</code>节所述连接，也是无符号的。以下数字类型是预定义的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">uint8 uint16[<span class="hljs-number">2</span>];<br>uint8 uint24[<span class="hljs-number">3</span>];<br>uint8 uint32[<span class="hljs-number">4</span>];<br>uint8 uint64[<span class="hljs-number">8</span>];<br></code></pre></td></tr></table></figure><p>说明书中的这里和其他地方的所有值都以<code>“network”</code>或<code>“big-endian”</code>的顺序存储; 由十六进制字节<code>01 02 03 04</code>表示的<code>uint32</code>等价于十进制值<code>16909060</code>。</p><h3 id="45-枚举enumerateds"><a class="markdownIt-Anchor" href="#45-枚举enumerateds"></a> 4.5 枚举(Enumerateds)</h3><p>  稀疏数据类型称为枚举。类型枚举的字段只能是定义中声明的值。每个定义是不同的类型。相同类型的枚举才能被赋值和比较。必须为枚举的每个元素分配一个值，如下例所示。由于枚举的元素未被排序，因此可以按任何顺序分配任何唯一的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> e1(v1), e2(v2), ... , en(vn) [[, (n)]] &#125; Te;<br></code></pre></td></tr></table></figure><p>枚举在字节流中占用与其最大定义的顺序值一样多的空间。以下定义将导致一个字节用于携带<code>Color</code>类型的字段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> red(<span class="hljs-number">3</span>), blue(<span class="hljs-number">5</span>), white(<span class="hljs-number">7</span>) &#125; Color;<br></code></pre></td></tr></table></figure><p>人们可以可选地指定一个没有关联标签的值来强制宽度定义而不定义多余的元素。在以下示例中，<code>Taste</code>将在数据流中消耗两个字节，但只能取值为<code>1,2</code>或<code>4</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> sweet(<span class="hljs-number">1</span>), sour(<span class="hljs-number">2</span>), bitter(<span class="hljs-number">4</span>), (<span class="hljs-number">32000</span>) &#125; Taste;<br></code></pre></td></tr></table></figure><p>  枚举的元素的名称在定义的类型范围内。在第一个示例中，对枚举的第二个元素的完全限定引用将是<code>Color.blue</code>。如果目标明确指定，则不需要这种限定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">Color color = Color.blue; <span class="hljs-comment">/* overspecified, legal */</span><br>Color color = blue; <span class="hljs-comment">/* correct, type implicit */</span><br></code></pre></td></tr></table></figure><p>对于从未转换为外部表示的枚举，可以省略数字信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> low, medium, high &#125; Amount;<br></code></pre></td></tr></table></figure><hr><h3 id="46-结构类型"><a class="markdownIt-Anchor" href="#46-结构类型"></a> 4.6 结构类型</h3><p>  结构类型可以由原始类型构建。每个规范声明一个新的唯一类型。定义的语法很像<code>C</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    T1 f1;<br>    T2 f2;<br>    ...<br>    Tn fn;<br>&#125; [[T]];<br></code></pre></td></tr></table></figure><p>结构中的字段可能使用类似于枚举的语法，使用类型的名称进行去确定。 例如，<code>T.f2</code> 指上面声明的第二个字段。 可以嵌套定义结构。</p><h4 id="461-变体variants"><a class="markdownIt-Anchor" href="#461-变体variants"></a> 4.6.1 变体(Variants)</h4><p>  定义的结构可能具有变体。选择器必须是枚举类型指定的可用的结构体变量。在选择中声明的枚举的每个元素都必须有一个<code>case arm</code>。可以给出变体结构体的标号以供引用。运行时选择变体的机制不是由演示语言规定的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    T1 f1;<br>    T2 f2;<br>    ....<br>    Tn fn;<br>    select (E) &#123;<br>        <span class="hljs-keyword">case</span> e1: Te1;<br>        <span class="hljs-keyword">case</span> e2: Te2;<br>        ....<br>        <span class="hljs-keyword">case</span> en: Ten;<br>    &#125; [[fv]];<br>&#125; [[Tv]];<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> apple, orange &#125; VariantTag;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    uint16 number;<br>    opaque <span class="hljs-built_in">string</span>&lt;<span class="hljs-number">0.</span><span class="hljs-number">.10</span>&gt;; <span class="hljs-comment">/* variable length */</span><br>&#125; V1;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    uint32 number;<br>    opaque <span class="hljs-built_in">string</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">/* fixed length */</span><br>&#125; V2;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    select (VariantTag) &#123; <span class="hljs-comment">/* value of selector is implicit */</span><br>        <span class="hljs-keyword">case</span> apple: V1; <span class="hljs-comment">/* VariantBody, tag = apple */</span><br>        <span class="hljs-keyword">case</span> orange: V2; <span class="hljs-comment">/* VariantBody, tag = orange */</span><br>    &#125; variant_body; <span class="hljs-comment">/* optional label on variant */</span><br>&#125; VariantRecord;<br></code></pre></td></tr></table></figure><p>可以通过在类型之前指定选择器的值来限定（缩小）变体结构。 例如，<code>a</code>是包含类型<code>V2</code>的<code>variant_body</code>的<code>VariantRecord</code>的缩小类型。</p><hr><h2 id="47-加密属性"><a class="markdownIt-Anchor" href="#47-加密属性"></a> 4.7 加密属性</h2><p>  四种加密操作：数字签名、流加密、分组加密和公钥加密分别被指定为数字签名、流加密、块加密和公开密钥加密。字段的加密处理通过在字段的类型规范之前提供适当的关键字指定来指定。加密密钥由当前会话状态暗示（见第<code>6.1</code>节）。</p><p>在数字签名中，单向散列函数用作签名算法的输入。 数字签名元素被编码为不透明向量<code>&lt;0..2 ^ 16-1&gt;</code>，其长度由签名算法和密钥指定。</p><p>在<code>RSA</code>签名中，两个哈希（一个<code>SHA</code>和一个<code>MD5</code>）的<code>36</code>字节结构被签名（用私钥加密）。它使用<code>PKCS＃1</code>块类型<code>0</code>或类型<code>1</code>进行编码，如<code>[PKCS1]</code>中所述。</p><p>在<code>DSS</code>中，<code>SHA</code>哈希的<code>20</code>个字节直接通过数字签名算法运行，没有额外的散列。 这产生两个值<code>r</code>和<code>s</code>。 <code>DSS</code>签名是一个不透明的向量，如上所述，其内容是<code>DER</code>编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs der">Dss-Sig-Value ::= SEQUENCE &#123;<br>    r INTEGER,<br>    s INTEGER<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>在流加密中，明文与由加密安全密钥伪随机数发生器产生的相同数量的输出进行异或运算。</p></li><li><p>在块加密中，每个明文块加密成一个密文块。 所有块加密在CBC（加密块链）模式下完成，所有被块加密的项目将是加密块长度的精确倍数。</p></li><li><p>在公共密钥加密中，使用公钥算法对数据进行加密，使得只能使用匹配的私钥进行解密。 公钥加密元素被编码为不透明向量<code>&lt;0..2 ^ 16-1&gt;</code>，其长度由签名算法和密钥指定。</p></li></ul><p><code>RSA</code>加密值用<code>PKCS＃1</code>块类型<code>2</code>编码，如<code>[PKCS1]</code>中所述。</p><p>在以下示例中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">stream-ciphered <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    uint8 field1;<br>    uint8 field2;<br>    digitally-<span class="hljs-type">signed</span> opaque hash[<span class="hljs-number">20</span>];<br>&#125; UserType;<br></code></pre></td></tr></table></figure><p>哈希的内容被用作签名算法的输入，然后整个结构用流加密。该结构的长度（以字节为单位）将相当于<code>field1</code>和<code>field2</code>的<code>2</code>个字节，加上签名长度的两个字节以及签名算法输出的长度。 这是已知的，因为用于签名的算法和密钥在编码或解码该结构之前是已知的。</p><hr><h3 id="48-常量"><a class="markdownIt-Anchor" href="#48-常量"></a> 4.8 常量</h3><p>  可以通过声明所需类型的符号并为其分配值来定义类型化常数。这些类型（不透明，可变长度向量和包含不透明的结构）不能够赋值。 无字段的多元素结构体或向量可以被省略。</p><p>例如，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    uint8 f1;<br>    uint8 f2;<br>&#125; Example1;<br><br>Example1 ex1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;; <span class="hljs-comment">/* assigns f1 = 1, f2 = 4 */</span><br></code></pre></td></tr></table></figure><hr><h2 id="5-hmac和伪随机函数"><a class="markdownIt-Anchor" href="#5-hmac和伪随机函数"></a> 5 HMAC和伪随机函数</h2><p>  <code>TLS</code>记录和握手层中的一些操作需要一个密钥<code>MAC</code>; 这是一个通过机密信息(<code>secret</code>)保护的数据的安全摘要。不知道<code>MAC</code>的<code>secret</code>是无法构造正确的<code>MAC</code>摘要的。我们用于此操作的结构称为<code>HMAC</code>，如<code>[HMAC]</code>中所述。</p><p>  <code>HMAC</code>可以与各种不同的散列算法一起使用。<code>TLS</code>在握手中使用两种不同的算法：<code>MD5</code>和<code>SHA-1</code>，将其表示为<code>HMAC_MD5（secret,data</code>）和<code>HMAC_SHA（secret,data）</code>。额外的散列算法可以由加密组件定义并用于保护记录数据，但是<code>MD5</code>和<code>SHA-1</code>被硬编码到该版本协议的握手描述中。</p><p>  此外，为了密钥生成或验证的目的，需要构建将机密信息(<code>secrets</code>)扩展到数据块。该伪随机函数(<code>PRF</code>)将<code>secret</code>、<code>seed</code>和识别<code>label</code>作为输入，并产生任意长度的输出。</p><p>  首先，我们定义一个数据扩展函数<code>P_hash(secret,data)</code>，它使用单个散列函数将<code>secret</code>和<code>seed</code>扩展为任意数量的输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">P_hash(secret, seed) =  HMAC_hash(secret, A(<span class="hljs-number">1</span>) + seed) +<br>                        HMAC_hash(secret, A(<span class="hljs-number">2</span>) + seed) +<br>                        HMAC_hash(secret, A(<span class="hljs-number">3</span>) + seed) + ...<br></code></pre></td></tr></table></figure><p>其中<code>+</code>表示连接。</p><p><code>A()</code> 被定义为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">A(<span class="hljs-number">0</span>) = seed<br>A(i) = HMAC_hash(secret, A(i<span class="hljs-number">-1</span>))<br></code></pre></td></tr></table></figure><p><code>P_hash</code>可以重复生成所需数量的数据所需的次数。例如，如果使用<code>P_SHA-1</code>来创建<code>64</code>字节的数据，则必须迭代<code>4</code>次（通过<code>A（4）</code>），创建<code>80</code>字节的输出数据; 最终迭代的最后<code>16</code>个字节将被丢弃，留下<code>64</code>个字节的输出数据。</p><p><code>TLS</code>的<code>PRF</code>是通过将<code>secret</code>分割成两半而使用一半来生成带有<code>P_MD5</code>的数据，另一半用<code>P_SHA-1</code>生成数据，然后将这两个扩展功能的输出相互排斥在一起。</p><p><code>S1</code>和<code>S2</code>是<code>secret</code>的两半，每个都是相同的长度。 <code>S1</code>从<code>secret</code>的前半部分采取，<code>S2</code>是从下半部开始的。他们的长度是通过将总<code>secret</code>的长度除以<code>2</code>来创建的; 因此，如果原始<code>secret</code>是奇数个字节长，则<code>S1</code>的最后一个字节将与<code>S2</code>的第一个字节相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">L_S = length in bytes of secret;<br>L_S1 = L_S2 = <span class="hljs-built_in">ceil</span>(L_S / <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>如上所述，<code>secret</code>被分成两半（具有一个共享字节的可能性），<code>S1</code>取第一个<code>L_S1</code>字节，<code>S2</code>取最后一个<code>L_S2</code>字节。然后将<code>PRF</code>定义为将两个伪随机流混合在一起的结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">PRF(secret, label, seed) = P_MD5(S1, label + seed) XOR P_SHA<span class="hljs-number">-1</span>(S2, label + seed);<br></code></pre></td></tr></table></figure><p>标签是<code>ASCII</code>字符串。它应该被包括在给定的没有长度字节或尾随空字符的确切形式。 例如，<code>label</code> <code>“slithy toves”</code>将通过散列以下字节来处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">73</span> <span class="hljs-number">6</span>C <span class="hljs-number">69</span> <span class="hljs-number">74</span> <span class="hljs-number">68</span> <span class="hljs-number">79</span> <span class="hljs-number">20</span> <span class="hljs-number">74</span> <span class="hljs-number">6F</span> <span class="hljs-number">76</span> <span class="hljs-number">65</span> <span class="hljs-number">73</span><br></code></pre></td></tr></table></figure><p>请注意，由于<code>MD5</code>产生<code>16</code>字节输出，<code>SHA-1</code>产生<code>20</code>字节输出，因此内部迭代的边界将不对齐; 生成<code>80</code>字节的输出将涉及<code>P_MD5</code>通过<code>A(5)</code>迭代，而<code>P_SHA-1</code>将仅迭代<code>A(4)</code>。</p><hr><h2 id="6-tls-记录协议tls-record-protocol"><a class="markdownIt-Anchor" href="#6-tls-记录协议tls-record-protocol"></a> 6 TLS 记录协议(TLS Record Protocol)</h2><p>  <code>TLS</code>记录协议是分层协议。在每个层，消息可以包括用于长度、描述和内容的字段。记录协议将消息传送出去，将数据分解成可管理的块，可选压缩数据、应用<code>MAC</code>、加密和传输结果。接收到的数据被解密、验证、解压缩和重新组合，然后传递给更高级别的客户端。</p><p>  本文档描述了四个记录协议客户端：握手协议(<code>handshake protocol</code>)、警报协议(<code>alert protocol</code>)、更改加密规范协议(<code>change cipher spec protocol</code>)和应用程序数据协议(<code>application data protocol</code>)。为了允许扩展<code>TLS</code>协议，记录协议可以支持附加的记录类型。任何新的记录类型都应该为这里描述的四种记录类型的<code>ContentType</code>值立即分配类型值（见附录<code>A.2</code>）。如果<code>TLS</code>实现接收到它不明白的记录类型，则应该忽略它。任何设计用于<code>TLS</code>的协议都必须仔细设计，以应对所有可能的攻击。请注意，由于记录的类型和长度不受加密保护，因此应注意尽量减少这些值的流量分析值。</p><h3 id="61-连接状态connection-states"><a class="markdownIt-Anchor" href="#61-连接状态connection-states"></a> 6.1 连接状态(Connection states)</h3><p>  <code>TLS</code>连接状态是<code>TLS</code>记录协议的操作环境。它规定了压缩算法、加密算法和<code>MAC</code>算法。此外，这些算法的参数是已知的：<code>MAC secret</code>和用于在读取和写入方向上的连接的批量加密密钥和<code>IV</code>。在逻辑上，总是有四个连接状态未完成：当前的读写状态以及待处理的读写状态。所有记录都以当前的读写状态进行处理。挂起状态的安全参数可以通过<code>TLS</code>握手协议来设置，而握手协议可以选择性地使两个待处理状态中的任何一个状态为当前状态，在这种情况下，适当的当前状态被处理并替换为挂起状态;待处理状态然后重新初始化为空状态。这是非法的尚未使用安全参数初始化的状态为当前状态。初始当前状态总是指定不使用加密、压缩、或<code>MAC</code>。</p><p>TLS连接读写状态的安全参数通过提供以下值来设置：</p><ul><li>连接端(<code>connection end</code>)</li></ul><blockquote><p>实体是否被视为“客户端”或“服务器”。</p></blockquote><ul><li>批量加密算法(<code>bulk encryption algorithm</code>)</li></ul><blockquote><p>用于批量加密的算法。 该规范包括该算法的密钥大小、该<code>secret</code>有多少密钥、加密的块大小（如果适用），以及它是否被认为是可“出口”加密算法。</p></blockquote><ul><li><code>MAC</code>算法(<code>MAC algorithm</code>)</li></ul><blockquote><p>用于消息认证的算法。 该规范包括由<code>MAC</code>算法返回的散列的大小。</p></blockquote><ul><li>压缩算法(<code>compression algorithm</code>)</li></ul><blockquote><p>用于数据压缩的算法。 该规范必须包括算法需要进行压缩的所有信息。</p></blockquote><ul><li>主机密信息(<code>Master secret</code>)</li></ul><blockquote><p>在连接中的两个对等体之间共享一个<code>48</code>字节的密钥。</p></blockquote><ul><li>客户随机数(<code>client random</code>)</li></ul><blockquote><p>由客户端提供的<code>32</code>字节值。</p></blockquote><ul><li>服务器随机数(<code>server random</code>)</li></ul><blockquote><p>由服务器提供的<code>32</code>字节值。</p></blockquote><p>这些参数以演示语言定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> server, client &#125; ConnectionEnd;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> null, rc4, rc2, des, <span class="hljs-number">3</span>des, des40 &#125; BulkCipherAlgorithm;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> stream, block &#125; CipherType;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span> &#125; IsExportable;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> null, md5, sha &#125; MACAlgorithm;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> null(<span class="hljs-number">0</span>), (<span class="hljs-number">255</span>) &#125; CompressionMethod;<br><br><span class="hljs-comment">/* The algorithms specified in CompressionMethod,</span><br><span class="hljs-comment">BulkCipherAlgorithm, and MACAlgorithm may be added to. */</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ConnectionEnd entity;<br>    BulkCipherAlgorithm bulk_cipher_algorithm;<br>    CipherType cipher_type;<br>    uint8 key_size;<br>    uint8 key_material_length;<br>    IsExportable is_exportable;<br>    MACAlgorithm mac_algorithm;<br>    uint8 hash_size;<br>    CompressionMethod compression_algorithm;<br>    opaque master_secret[<span class="hljs-number">48</span>];<br>    opaque client_random[<span class="hljs-number">32</span>];<br>    opaque server_random[<span class="hljs-number">32</span>];<br>&#125; SecurityParameters;<br></code></pre></td></tr></table></figure><p>记录层将使用安全参数来生成以下六个项目：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">client write MAC secret<br>server write MAC secret<br>client write key<br>server write key<br>client write <span class="hljs-title function_">IV</span> <span class="hljs-params">(<span class="hljs-keyword">for</span> block ciphers only)</span><br>server write <span class="hljs-title function_">IV</span> <span class="hljs-params">(<span class="hljs-keyword">for</span> block ciphers only)</span><br></code></pre></td></tr></table></figure><p>服务器在接收和处理记录时使用客户端写入参数，反之亦然。 用于从安全参数生成这些项目的算法在第<code>6.3</code>节中描述。</p><p>一旦设置了安全参数并且已经生成密钥，则可以通过使连接状态成为当前状态来实例化连接状态。必须对每个处理的记录更新这些当前状态。 每个连接状态包括以下元素：</p><ul><li>压缩状态(<code>compression state</code>)</li></ul><blockquote><p>当前压缩算法的状态。</p></blockquote><ul><li>加密状态(<code>cipher state</code>)</li></ul><blockquote><p>当前状态的加密算法。这将包括该连接的预定密钥。此外，对于以<code>CBC</code>模式运行的块加密（仅为<code>TLS</code>指定的模式），最初将包含该连接状态的<code>IV</code>，并将其更新为包含处理记录时加密或解密的最后一个块的密文。对于流加密，这将包含任何必要的状态信息，以允许流继续加密或解密数据。</p></blockquote><ul><li><code>MAC secret</code></li></ul><blockquote><p>此连接的<code>MAC</code> 机密信息如上所述。</p></blockquote><ul><li>序列号(<code>sequence number</code>)</li></ul><blockquote><p>每个连接状态包含一个序列号，该序列号分别用于读取和写入状态。每当连接状态为活动状态，序列号必须设置为零。序列号为<code>uint64</code>，不得超过<code>2^ 64-1</code>。序列号在每条记录之后增加：具体来说，在特定连接状态下发送的第一条记录应使用序列号<code>0</code>。</p></blockquote><h3 id="62-记录层record-layer"><a class="markdownIt-Anchor" href="#62-记录层record-layer"></a> 6.2 记录层(Record layer)</h3><p><code>TLS</code>记录层从任意大小的非空块中的较高层接收未解释的数据。</p><h4 id="621-碎片fragmentation"><a class="markdownIt-Anchor" href="#621-碎片fragmentation"></a> 6.2.1 碎片(Fragmentation)</h4><p>  记录层将信息块分割成携带<code>2 ^ 14</code>字节(<code>16K</code>块)或更少块的数据的<code>TLSPlaintext</code>记录。客户端消息边界不保留在记录层中（即，相同<code>ContentType</code>的多个客户端消息可以合并到单个<code>TLSPlaintext</code>记录中，或者单个消息可能跨多个记录分段）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    uint8 major, minor;<br>&#125; ProtocolVersion;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    change_cipher_spec(<span class="hljs-number">20</span>), alert(<span class="hljs-number">21</span>), handshake(<span class="hljs-number">22</span>),<br>    application_data(<span class="hljs-number">23</span>), (<span class="hljs-number">255</span>)<br>&#125; ContentType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ContentType type;<br>    ProtocolVersion version;<br>    uint16 length;<br>    opaque fragment[TLSPlaintext.length];<br>&#125; TLSPlaintext;<br></code></pre></td></tr></table></figure><ul><li><code>type</code></li></ul><blockquote><p>用于处理封闭片段的较高级协议。</p></blockquote><ul><li><code>version</code></li></ul><blockquote><p>使用的协议版本。 本文档介绍了使用版本<code>&#123;3，1&#125;</code>的<code>TLS</code>版本<code>1.0</code>。 版本值<code>3.1</code>是历史的：<code>TLS</code>版本<code>1.0</code>是<code>SSL 3.0</code>协议的一个小修改，它承载版本值<code>3.0</code>。 （见附录<code>A.1</code>）。</p></blockquote><ul><li><code>length</code></li></ul><blockquote><p>以下<code>TLSPlaintext.fragment</code>的长度（以字节为单位）。长度不能超过<code>2 ^ 14</code>。</p></blockquote><ul><li><code>fragment</code></li></ul><blockquote><p>应用数据。 该数据是透明的，被视为独立的块，由类型字段指定的较高级协议处理。</p></blockquote><p>注意：不同<code>TLS</code>记录层内容类型的数据可能会交错。与其他内容类型相比，应用程序数据的传输优先级通常较低。</p><h4 id="622-记录压缩和解压缩"><a class="markdownIt-Anchor" href="#622-记录压缩和解压缩"></a> 6.2.2 记录压缩和解压缩</h4><p>  所有记录都使用当前会话状态中定义的压缩算法进行压缩。总是有一个活动的压缩算法; 然而，最初定义为<code>CompressionMethod.null</code>(<code>null</code>表示不压缩)。压缩算法将<code>TLSPlaintext</code>结构转换为<code>TLSCompressed</code>结构。每当连接状态被激活时，压缩函数都将使用默认状态信息进行初始化。</p><p>压缩必须是无损的，不能将内容长度增加超过<code>1024</code>字节。 如果解压缩功能遇到一个<code>TLSCompressed.fragment</code>，它将解压缩到超过<code>2 ^ 14</code>个字节的长度，则应报告致命的解压缩失败错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ContentType type; <span class="hljs-comment">/* same as TLSPlaintext.type */</span><br>    ProtocolVersion version;<span class="hljs-comment">/* same as TLSPlaintext.version */</span><br>    uint16 length;<br>    opaque fragment[TLSCompressed.length];<br>&#125; TLSCompressed;<br></code></pre></td></tr></table></figure><ul><li><code>length</code></li></ul><blockquote><p>以下<code>TLSCompressed.fragment</code>的长度（以字节为单位）。长度不应超过<code>2 ^ 14 + 1024</code>。</p></blockquote><ul><li><code>fragment</code></li></ul><blockquote><p>压缩格式的<code>TLSPlaintext.fragment</code>。</p></blockquote><p>注意：<code>CompressionMethod.null</code>操作是一个<code>identity</code>操作; 没有字段被改变。</p><p>实施说明：解压缩功能负责确保消息不会导致内部缓冲区溢出。</p><hr><h4 id="623-记录有效载荷保护record-payload-protection"><a class="markdownIt-Anchor" href="#623-记录有效载荷保护record-payload-protection"></a> 6.2.3 记录有效载荷保护(Record payload protection)</h4><p>  加密和<code>MAC</code>功能将<code>TLSCompressed</code>结构转换为<code>TLSCiphertext</code>。解密功能使过程相反。记录的<code>MAC</code>还包括序列号，以便可以检测到丢失，额外或重复的消息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ContentType type;<br>        ProtocolVersion version;<br>        uint16 length;<br>        select (CipherSpec.cipher_type) &#123;<br>        <span class="hljs-keyword">case</span> stream: GenericStreamCipher;<br>        <span class="hljs-keyword">case</span> block: GenericBlockCipher;<br>    &#125; fragment;<br>&#125; TLSCiphertext;<br></code></pre></td></tr></table></figure><ul><li><code>type</code></li></ul><blockquote><p>类型字段与<code>TLSCompressed.type</code>相同。</p></blockquote><ul><li><code>version</code></li></ul><blockquote><p>版本字段与<code>TLSCompressed.version</code>相同。</p></blockquote><ul><li><code>length</code></li></ul><blockquote><p>以下<code>TLSCiphertext.fragment</code>的长度（以字节为单位）。长度不得超过<code>2 ^ 14 + 2048</code>。</p></blockquote><ul><li><code>fragment</code></li></ul><blockquote><p><code>TLSCompressed.fragment</code>的加密形式，带有<code>MAC</code>。</p></blockquote><h5 id="6231-空或标准流加密null-or-standard-stream-cipher"><a class="markdownIt-Anchor" href="#6231-空或标准流加密null-or-standard-stream-cipher"></a> 6.2.3.1 空或标准流加密(Null or standard stream cipher)</h5><p>  流加密（包括<code>BulkCipherAlgorithm.null</code> - 见附录<code>A.6</code>）将<code>TLSCompressed.fragment</code>结构转换为流<code>TLSCiphertext.fragment</code>结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">stream-ciphered <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    opaque content[TLSCompressed.length];<br>    opaque MAC[CipherSpec.hash_size];<br>&#125; GenericStreamCipher;<br></code></pre></td></tr></table></figure><p><code>MAC</code>产生如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">HMAC_hash(MAC_write_secret, seq_num + TLSCompressed.type +<br>            TLSCompressed.version + TLSCompressed.length +<br>            TLSCompressed.fragment));<br></code></pre></td></tr></table></figure><p>其中<code>“+”</code>表示连接。</p><ul><li><code>seq_num</code></li></ul><blockquote><p>这个记录的序列号</p></blockquote><ul><li><code>hash</code></li></ul><blockquote><p>由<code>SecurityParameters.mac_algorithm</code>指定的散列算法。</p></blockquote><p>请注意，<code>MAC</code>是在加密之前计算的。流加密加密整个块，包括<code>MAC</code>。对于不使用同步向量(例如<code>RC4</code>)的流加密，从一个记录结尾处的流加密状态仅用于后续数据包。如果<code>CipherSuite</code>是<code>TLS_NULL_WITH_NULL_NULL</code>，则加密由身份操作(即，数据未加密，<code>MAC</code>大小为零，暗示不使用<code>MAC</code>)组成。<code>TLSCiphertext.length</code>是<code>TLSCompressed.length</code>加上<code>CipherSpec.hash_size</code>。</p><hr><h5 id="6232-cbc块加密"><a class="markdownIt-Anchor" href="#6232-cbc块加密"></a> 6.2.3.2 CBC块加密</h5><p>  对于块加密（如<code>RC2</code>或<code>DES</code>），加密和<code>MAC</code>功能将<code>TLSCompressed.fragment</code>结构转换为块<code>TLSCiphertext.fragment</code>结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">block-ciphered <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    opaque content[TLSCompressed.length];<br>    opaque MAC[CipherSpec.hash_size];<br>    uint8 padding[GenericBlockCipher.padding_length];<br>    uint8 padding_length;<br>&#125; GenericBlockCipher;<br></code></pre></td></tr></table></figure><p>如第<code>6.2.3.1</code>节所述生成<code>MAC</code>。</p><ul><li><code>padding</code></li></ul><blockquote><p>添加的填充将明文长度强制为块密码块长度的整数倍。填充可以是长达<code>255</code>字节的任何长度，只要它导致<code>TLSCiphertext.length</code>是块长度的整数倍。可能需要长于所需时间的长度来阻止基于对交换的消息的长度的分析对协议的攻击。填充数据向量中的每个<code>uint8</code>必须填充填充长度值。</p></blockquote><ul><li><code>padding_length</code></li></ul><blockquote><p>填充长度应该使得<code>GenericBlockCipher</code>结构的总大小是加密块长度的倍数。 合法值范围从零到<code>255</code>（含）。 该长度指定<code>padding_length</code>字段本身排除的填充字段的长度。</p></blockquote><p>加密的数据长度（<code>TLSCiphertext.length</code>）比<code>TLSCompressed.length</code>，<code>CipherSpec.hash_size</code>和<code>padding_length</code>的总和多一个。</p><p>示例：<br>如果块长度为<code>8</code>字节，则内容长度（<code>TLSCompressed.length</code>）为<code>61</code>字节，<code>MAC</code>长度为<code>20</code>字节，填充前的长度为<code>82</code>字节。因此，为了使总长度为<code>8</code>字节的偶数倍（块长度），模8的填充长度必须等于<code>6</code>。通过<code>254</code>，填充长度可以为<code>6,14,22</code>等。如果填充长度是必需的最小值，如图<code>6</code>所示，填充将为<code>6</code>字节，每个包含值<code>6</code>.因此，块加密之前的<code>GenericBlockCipher</code>的最后<code>8</code>个八位字节将为<code>xx 06，06 06 06 06 06，</code>其中<code>xx</code>是<code>MAC</code>的最后一个八位字节。</p><p>注意：<br>使用<code>CBC</code>模式（加密块链接）中的块加密，当设置了安全参数时，将生成第一条记录的初始化向量（<code>IV</code>）和其他密钥和秘密。后续记录的<code>IV</code>是上次记录的最后一个密文块。</p><hr><h3 id="63-密钥计算key-calculation"><a class="markdownIt-Anchor" href="#63-密钥计算key-calculation"></a> 6.3 密钥计算(Key calculation)</h3><p>记录协议需要一种算法，从握手协议提供的安全性参数生成密钥、<code>IV</code>和<code>MAC secret</code>。</p><p><code>Master secret</code>被散列成一系列安全字节，分配给当前连接状态所需的<code>MAC secret</code>、密钥和非导出<code>IV</code>(见附录<code>A.6</code>)。<code>CipherSpecs</code>需要<code>client write MAC secret、server write MAC secret、client write key、server write key、client write IV 和server write IV</code>，这是从主<code>Master secret</code>按顺序生成的。未使用的值为空。</p><p>当生成密钥和<code>MAC secrets</code>时，<code>Master secret</code>被用作熵源，并且随机值为可出口的加密提供未加密的<code>salt material</code>和<code>IV</code>。</p><p>要生成密钥材料，计算</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">key_block = PRF(SecurityParameters.master_secret,<br>                <span class="hljs-string">&quot;key expansion&quot;</span>,<br>                SecurityParameters.server_random +<br>                SecurityParameters.client_random);<br></code></pre></td></tr></table></figure><p>直到产生足够的输出。然后将<code>key_block</code>分区如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">client_write_MAC_secret[SecurityParameters.hash_size]<br>server_write_MAC_secret[SecurityParameters.hash_size]<br>client_write_key[SecurityParameters.key_material_length]<br>server_write_key[SecurityParameters.key_material_length]<br>client_write_IV[SecurityParameters.IV_size]<br>server_write_IV[SecurityParameters.IV_size]<br></code></pre></td></tr></table></figure><p><code>client_write_IV</code>和<code>server_write_IV</code>仅针对非导出块加密生成。 对于可出口的块加密，稍后生成初始化向量，如下所述。 任何额外的<code>key_block</code>资料都被丢弃。</p><p>实施说明：<br>在本文档中定义的加密规范需要最多的材料是<code>3DES_EDE_CBC_SHA</code>：它需要<code>2 x 24</code>字节的密钥，<code>2 x 20</code>字节的<code>MAC secrets</code>和<code>2 x 8</code>字节的<code>IV</code>，总共<code>104</code>个字节的密钥材料。</p><p>可出口的加密算法（<code>CipherSpec.is_exportable</code>为<code>true</code>）需要额外的处理，以获得最终的写入密钥：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">final_client_write_key = PRF(SecurityParameters.client_write_key,<br>                        <span class="hljs-string">&quot;client write key&quot;</span>,<br>                        SecurityParameters.client_random +<br>                        SecurityParameters.server_random);<br><br>final_server_write_key = PRF(SecurityParameters.server_write_key,<br>                        <span class="hljs-string">&quot;server write key&quot;</span>,<br>                        SecurityParameters.client_random +<br>                        SecurityParameters.server_random);<br></code></pre></td></tr></table></figure><p>可出口的加密算法仅从<code>hello</code>消息的随机值中导出其<code>IV</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">iv_block = PRF(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;IV block&quot;</span>, SecurityParameters.client_random +<br>                SecurityParameters.server_random);<br></code></pre></td></tr></table></figure><p>由于<code>key_block</code>位于上面，所以将<code>iv_block</code>分成两个初始化向量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">client_write_IV[SecurityParameters.IV_size]<br>server_write_IV[SecurityParameters.IV_size]<br></code></pre></td></tr></table></figure><p>请注意，在这种情况下，<code>PRF</code>在无<code>secret</code>下使用：这仅仅意味着<code>secret</code>的长度为零字节，对<code>PRF</code>中的散列没有任何贡献。</p><h4 id="631-出口export密钥生成示例"><a class="markdownIt-Anchor" href="#631-出口export密钥生成示例"></a> 6.3.1 出口(Export)密钥生成示例</h4><p><code>TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5</code>对于两个加密密钥中的每一个需要五个随机字节，对于每个<code>MAC</code>密钥需要<code>16</code>个字节，总共<code>42</code>个字节的密钥材料。 <code>PRF</code>输出存储在<code>key_block</code>中。 <code>key_block</code>被分区，并且写密钥被伪装的(<code>salted</code>)，因为这是可出口(<code>exportable</code>)的加密算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">key_block = PRF(master_secret,<br>                <span class="hljs-string">&quot;key expansion&quot;</span>,<br>                server_random +<br>                client_random)[<span class="hljs-number">0.</span><span class="hljs-number">.41</span>]<br><br>client_write_MAC_secret = key_block[<span class="hljs-number">0.</span><span class="hljs-number">.15</span>]<br>server_write_MAC_secret = key_block[<span class="hljs-number">16.</span><span class="hljs-number">.31</span>]<br>client_write_key = key_block[<span class="hljs-number">32.</span><span class="hljs-number">.36</span>]<br>server_write_key = key_block[<span class="hljs-number">37.</span><span class="hljs-number">.41</span>]<br><br>final_client_write_key = PRF(client_write_key,<br>                            <span class="hljs-string">&quot;client write key&quot;</span>,<br>                            client_random +<br>                            server_random)[<span class="hljs-number">0.</span><span class="hljs-number">.15</span>]<br><br>final_server_write_key = PRF(server_write_key,<br>                            <span class="hljs-string">&quot;server write key&quot;</span>,<br>                            client_random +<br>                            server_random)[<span class="hljs-number">0.</span><span class="hljs-number">.15</span>]<br><br>iv_block = PRF(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;IV block&quot;</span>, client_random +<br>                server_random)[<span class="hljs-number">0.</span><span class="hljs-number">.15</span>]<br><br>client_write_IV = iv_block[<span class="hljs-number">0.</span><span class="hljs-number">.7</span>]<br>server_write_IV = iv_block[<span class="hljs-number">8.</span><span class="hljs-number">.15</span>]<br></code></pre></td></tr></table></figure><hr><h2 id="7-tsl握手协议tls-handshake-protocol"><a class="markdownIt-Anchor" href="#7-tsl握手协议tls-handshake-protocol"></a> 7 TSL握手协议(TLS Handshake Protocol)</h2><p>  TLS握手协议包括一组三个子协议，用于允许对等体同意记录层的安全性参数，对自身进行身份验证，实例化协商的安全参数以及将错误状况报告给彼此。</p><p>握手议定负责协商会话，其中包括以下内容：</p><ul><li>会话标识符(<code>session identifier</code>)</li></ul><blockquote><p>由服务器选择的用于标识活动或可恢复的会话状态的任意字节序列。</p></blockquote><ul><li>对等证书(<code>peer certificate</code>)</li></ul><blockquote><p><code>X509v3 [X509]</code>对等证书。 状态的这个元素可能为<code>null</code>。</p></blockquote><ul><li>压缩方式(<code>compression method</code>)</li></ul><blockquote><p>用于在加密之前压缩数据的算法。</p></blockquote><ul><li>加密规范(<code>cipher spec</code>)</li></ul><blockquote><p>指定批量数据加密算法（如<code>null</code>，<code>DES</code>等）和<code>MAC</code>算法（如<code>MD5</code>或<code>SHA</code>）。 它还定义了加密属性，如<code>hash_size</code>。 （关于正式定义见附录<code>A.6</code>）</p></blockquote><ul><li>主机密信息(<code>master secret</code>)</li></ul><blockquote><p>在客户端和服务器之间共享<code>48</code>字节的机密信息。</p></blockquote><ul><li>是否可以恢复</li></ul><blockquote><p>指示会话是否可用于发起新连接的标志。</p></blockquote><p>然后，这些项目用于创建安全参数，以便在保护应用程序数据时由记录层使用。通过<code>TLS</code>握手协议的恢复功能，可以使用相同的会话来实例化许多连接。</p><hr><h3 id="71-更改加密规范协议change-cipher-spec-protocol"><a class="markdownIt-Anchor" href="#71-更改加密规范协议change-cipher-spec-protocol"></a> 7.1 更改加密规范协议(Change cipher spec protocol)</h3><p>  改变加密规范协议存在于信号转换的加密策略。 该协议由单个消息组成，它在当前（非阻塞）连接状态下被加密和压缩。 该消息由单个字节的值1组成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> change_cipher_spec(<span class="hljs-number">1</span>), (<span class="hljs-number">255</span>) &#125; type;<br>&#125; ChangeCipherSpec;<br></code></pre></td></tr></table></figure><p>  更改加密规范消息由客户端和服务器发送，以通知接收方，后续记录将受到新协商的加密算法和密钥的保护。 该消息的接收使得接收器指示记录层立即将读取待处理状态复制到读取当前状态。 在发送此消息后，发送方应立即指示记录层将写入挂起状态设置为写入活动状态。 （见第<code>6.1</code>节）在协商安全参数之后，但在验证完成的消息发送之前，在握手期间发送更改加密规范消息（见<code>7.4.9</code>节）。</p><h3 id="72-警报协议alert-protocol"><a class="markdownIt-Anchor" href="#72-警报协议alert-protocol"></a> 7.2 警报协议(Alert protocol)</h3><p>  <code>TLS</code>记录层支持的内容类型之一是警报类型。警报消息传达消息的严重性和警报的描述。警报消息，其中一连串致命的结果立即终止连接。在这种情况下，与会话相对应的其他连接可能会继续，但会话标识符必须无效，从而阻止失败的会话被用于建立新的连接。 像其他消息一样，警报消息被加密和压缩，如当前连接状态所指定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> warning(<span class="hljs-number">1</span>), fatal(<span class="hljs-number">2</span>), (<span class="hljs-number">255</span>) &#125; AlertLevel;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    close_notify(<span class="hljs-number">0</span>),<br>    unexpected_message(<span class="hljs-number">10</span>),<br>    bad_record_mac(<span class="hljs-number">20</span>),<br>    decryption_failed(<span class="hljs-number">21</span>),<br>    record_overflow(<span class="hljs-number">22</span>),<br>    decompression_failure(<span class="hljs-number">30</span>),<br>    handshake_failure(<span class="hljs-number">40</span>),<br>    bad_certificate(<span class="hljs-number">42</span>),<br>    unsupported_certificate(<span class="hljs-number">43</span>),<br>    certificate_revoked(<span class="hljs-number">44</span>),<br>    certificate_expired(<span class="hljs-number">45</span>),<br>    certificate_unknown(<span class="hljs-number">46</span>),<br>    illegal_parameter(<span class="hljs-number">47</span>),<br>    unknown_ca(<span class="hljs-number">48</span>),<br>    access_denied(<span class="hljs-number">49</span>),<br>    decode_error(<span class="hljs-number">50</span>),<br>    decrypt_error(<span class="hljs-number">51</span>),<br>    export_restriction(<span class="hljs-number">60</span>),<br>    protocol_version(<span class="hljs-number">70</span>),<br>    insufficient_security(<span class="hljs-number">71</span>),<br>    internal_error(<span class="hljs-number">80</span>),<br>    user_canceled(<span class="hljs-number">90</span>),<br>    no_renegotiation(<span class="hljs-number">100</span>),<br>    (<span class="hljs-number">255</span>)<br>&#125; AlertDescription;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    AlertLevel level;<br>    AlertDescription description;<br>&#125; Alert;<br></code></pre></td></tr></table></figure><hr><h4 id="721-关闭警报closure-alerts"><a class="markdownIt-Anchor" href="#721-关闭警报closure-alerts"></a> 7.2.1 关闭警报(Closure alerts)</h4><p>客户端和服务器必须共享连接正在结束的知识，以避免截断攻击。 任何一方可以启动关闭消息的交换。</p><p><code>close_notify</code>: 此消息通知收件人，发件人不会在此连接上发送更多消息。如果任何连接终止而没有正确等于警告级别的<code>close_notify</code>消息，则会话将变为不可解释。</p><p>任何一方可以通过发送<code>close_notify</code>警报来启动关闭。关闭警报之后收到的任何数据将被忽略。</p><p>在关闭连接的写入端之前，每方都需要发送<code>close_notify</code>警报。要求对方以其自己的<code>close_notify</code>警报进行响应，并立即关闭连接，并丢弃任何挂起的写入。在关闭连接的读取端之前，关闭的发起方不需要等待响应<code>close_notify</code>警报。</p><p>如果使用<code>TLS</code>的应用程序协议规定，在<code>TLS</code>连接关闭后，任何数据都可能通过底层传输进行传输，则<code>TLS</code>实现必须在向应用层指示<code>TLS</code>连接已结束之前收到响应的<code>close_notify</code>警报。如果应用协议不会传输任何附加数据，但只会关闭底层传输连接，则执行可能会选择关闭传输，而不必等待响应<code>close_notify</code>。不应采用本标准的任何部分来规定<code>TLS</code>管理其数据传输的使用配置文件的方式，包括何时打开或关闭连接。</p><p>注意：假设在销毁传输之前关闭连接可靠地传送挂起的数据。</p><h4 id="722-错误警报"><a class="markdownIt-Anchor" href="#722-错误警报"></a> 7.2.2 错误警报</h4><p>  <code>TLS</code>握手协议中的错误处理非常简单。 当检测到错误时，检测方向另一方发送消息。 在发送或接收致命警报消息时，双方立即关闭连接。 服务器和客户端需要忘记与故障连接相关联的任何会话标识符，密钥和秘密。 定义了以下错误警报：</p><ul><li><code>unexpected_message</code></li></ul><blockquote><p>收到不正确的消息。 这种警报总是致命的，在正确的实现之间的通信中不应该被观察到。</p></blockquote><ul><li><code>bad_record_mac</code></li></ul><blockquote><p>如果收到带有错误<code>MAC</code>的记录，则返回该警报。 这个消息总是致命的。</p></blockquote><ul><li><code>decryption_failed</code></li></ul><blockquote><p>以无效方式解密的<code>TLSCiphertext</code>：当被检查时，它不是块长度或其填充值的偶数倍，不正确。 这个消息总是致命的。</p></blockquote><ul><li><code>record_overflow</code></li></ul><blockquote><p>接收到<code>TLSCiphertext</code>记录，其长度大于<code>2 ^ 14 + 2048</code>字节，或解密到具有超过<code>2 ^ 14 + 1024</code>字节的<code>TLSCompressed</code>记录的记录。 这个消息总是致命的。</p></blockquote><ul><li><code>decompression_failure</code></li></ul><blockquote><p>解压缩功能接收到不正确的输入（例如将扩展到过长的数据）。 这个消息总是致命的。</p></blockquote><ul><li><code>handshake_failure</code></li></ul><blockquote><p>接收<code>handshake_failure</code>警报消息表明发送方无法协商一个可接受的一组安全参数，给定可用的选项。这是一个致命的错误。</p></blockquote><ul><li><code>bad_certificate</code></li></ul><blockquote><p>证书已损坏，包含未正确验证的签名等。</p></blockquote><ul><li><code>unsupported_certificate</code></li></ul><blockquote><p>证书是不受支持的类型。</p></blockquote><ul><li><code>certificate_revoked</code></li></ul><blockquote><p>证书由签字人撤销。</p></blockquote><ul><li><code>certificate_expired</code></li></ul><blockquote><p>证书已过期或目前无效。</p></blockquote><ul><li><code>certificate_unknown</code></li></ul><blockquote><p>在处理证书时出现了一些其他（未指定）问题，使其不能接受。</p></blockquote><ul><li><code>illegal_parameter</code></li></ul><blockquote><p>握手中的一个字段超出了范围，或与其他字段不一致。这总是致命的。</p></blockquote><ul><li><code>unknown_ca</code></li></ul><blockquote><p>收到有效的证书链或部分链，但不能接受证书，因为CA证书无法找到或者不能与已知的可信任<code>CA</code>匹配。这个消息总是致命的。</p></blockquote><ul><li>拒绝访问</li></ul><blockquote><p>收到有效的证书，但是当应用访问控制时，发件人决定不进行协商。这个消息总是致命的。</p></blockquote><ul><li><code>decode_error</code></li></ul><blockquote><p>无法解码邮件，因为某些字段超出了指定的范围或邮件的长度不正确。这个消息总是致命的。</p></blockquote><ul><li><code>decrypt_error</code></li></ul><blockquote><p>握手加密操作失败，包括无法正确验证签名，解密密钥交换或验证已完成的邮件。</p></blockquote><ul><li><code>export_restriction</code></li></ul><blockquote><p>检测到不符合出口限制的谈判;例如，尝试传输用于<code>RSA_EXPORT</code>握手方法的<code>1024</code>位临时<code>RSA</code>密钥。这个消息总是致命的。</p></blockquote><ul><li><code>protocol_version</code></li></ul><blockquote><p>客户端尝试协商的协议版本被识别，但不被支持。 （例如，出于安全考虑，可能会避免旧的协议版本）。这个消息总是致命的。</p></blockquote><ul><li><code>insufficient_security</code></li></ul><blockquote><p>当协商失败时，返回而不是<code>handshake_failure</code>，因为服务器需要比客户端支持的加密更安全的加密。这个消息总是致命的。</p></blockquote><ul><li>内部错误</li></ul><blockquote><p>与对等体无关的内部错误或协议的正确性使得无法继续（例如内存分配失败）。这个消息总是致命的。</p></blockquote><ul><li><code>user_canceled</code></li></ul><blockquote><p>由于与协议失败无关的某种原因，此握手被取消。如果用户在握手完成后取消操作，则只需通过发送<code>close_notify</code>来关闭连接更合适。此警报后面应该有一个<code>close_notify</code>。这个消息通常是一个警告。</p></blockquote><ul><li><code>no_renegotiation</code></li></ul><blockquote><p>客户端响应<code>hello</code>请求或由服务器响应初始握手后的客户端发送。这些之一通常会导致重新谈判;当不合适时，收件人应该用这个警报来回应;在这一点上，原请求者可以决定是否继续进行连接。一种适合这种情况的情况是服务器产生了满足请求的过程;该过程可能会在启动时接收安全参数（密钥长度，身份验证等），并且可能难以在此之后传送这些参数的更改。此消息始终是警告。</p></blockquote><p>对于没有明确指定警报级别的所有错误，发送方可以自行决定是否是致命错误; 如果接收到警告级别的警报，接收方可以决定是否将其视为致命错误。 然而，所有以致命级别传输的消息必须被视为致命消息。</p><hr><h3 id="73-握手协议概述"><a class="markdownIt-Anchor" href="#73-握手协议概述"></a> 7.3 握手协议概述</h3><p>  会话状态的加密参数由<code>TLS</code>握手协议产生，<code>TLS</code>协议在<code>TLS Record</code>层之上运行。当<code>TLS</code>客户端和服务器首先开始通信时，他们先对协议版本达成一致、选择加密算法、可选地进行身份验证、使用公钥加密技术来生成共享密钥。</p><p><code>TLS</code>握手协议包括以下步骤：</p><ul><li>交换<code>hello</code>消息来对协商算法，交换随机值，并检查会话恢复。</li><li>交换必要的加密参数，以允许客户端和服务器协商一个前置主<code>secret</code>。</li><li>交换证书和加密信息，以允许客户端和服务器对其进行身份验证。</li><li>从前置主<code>secret</code>生成一个主<code>secret</code>，交换随机值。</li><li>为记录层提供安全参数。</li><li>允许客户端和服务器验证他们的对等体已经计算出相同的安全参数，并且握手过程没有被被攻击者篡改。</li></ul><p>请注意，较高的层不应该过分依赖于<code>TLS</code>，它始终协商两个对等体之间最强的连接：中间攻击者中的一个人可以尝试使两个实体下降到他们支持的最不安全的方法。 该协议的设计旨在最大程度地降低这种风险，但仍然有可用的攻击：例如，攻击者可能会阻止对安全服务运行的端口的访问，或尝试让对等体协商未经身份验证的连接。 基本规则是，较高的级别必须认识到他们的安全要求是什么，而不是通过不那么安全的渠道来传递信息。 <code>TLS</code>协议是安全的，因为任何加密组件都提供了其承诺的安全级别：如果您通过与验证证书的主机进行<code>1024</code>位<code>RSA</code>密钥交换来协商<code>3DES</code>，则可以期待安全性。</p><p>但是，除非您觉得数据的价值不超过打破加密所需的工作量，否则绝对不要通过加密40位安全性的链接发送数据。</p><p>这些目标是通过握手协议实现的，可以总结如下：客户端发送客户端<code>hello</code>消息，服务器必须使用服务器<code>hello</code>消息进行响应，否则将发生致命错误，并且连接将失败。 <code>Client hello</code>和<code>Server hello</code>用于在客户端和服务器之间建立安全增强功能。<code>Client hello</code>和<code>Server hello</code>建立以下属性：协议版本、会话<code>ID</code>、加密组件和压缩方法。 另外，生成和交换两个随机值：<code>ClientHello.random</code>和<code>ServerHello.random</code>。(见<code>Fig. 1</code> )</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">Client                                               Server<br><br>ClientHello                  --------&gt;<br>                                                ServerHello<br>                                               Certificate*<br>                                         ServerKeyExchange*<br>                                        CertificateRequest*<br>                             &lt;--------      ServerHelloDone<br>Certificate*<br>ClientKeyExchange<br>CertificateVerify*<br>[ChangeCipherSpec]<br>Finished                     --------&gt;<br>                                         [ChangeCipherSpec]<br>                             &lt;--------             Finished<br>Application Data             &lt;-------&gt;     Application Data<br><br>       Fig. <span class="hljs-number">1</span> - Message flow <span class="hljs-keyword">for</span> a full handshake<br></code></pre></td></tr></table></figure><p>  实际的密钥交换最多可以使用四个消息：服务器证书、服务器密钥交换、客户端证书和客户端密钥交换。 可以通过指定这些消息的格式并定义消息的使用来允许客户端和服务器同意共享密钥来创建新的密钥交换方法。 这个<code>secret</code>应该很长; 当前定义的密钥交换方法交换的<code>secret</code>范围从<code>48</code>到<code>128</code>字节</p><p>如果要进行身份验证，按照<code>hello</code>消息，服务器将发送其证书。另外，如果需要，可以发送服务器密钥交换消息（例如，如果其服务器没有证书，或者其证书仅用于签名）。如果服务器被认证，它可以从客户端请求一个证书，如果这适合所选的加密组件。现在服务器将发送服务器<code>hello</code>完成消息，表示握手的<code>hello-message</code>阶段已经完成。然后服务器将等待客户端的响应。如果服务器发送了证书请求消息，则客户端必须发送证书消息。客户端密钥交换消息现在被发送，该消息的内容将取决于在客户端<code>hello</code>和服务器之间选择的公钥算法。如果客户端已经发送了具有签名能力的证书，则会发送一个经数字签名的证书验证消息来显式验证证书。</p><p>此时，客户端发送更改加密规范消息，客户端将待处理的加密规范复制到当前加密规范中。 然后，客户端立即按照新的算法、密钥和<code>secret</code>发送<code>finished</code>消息。作为响应，服务器将发送自己的更改加密规范消息，将待处理传输到当前加密规范，并在新的加密规范下发送其<code>finished</code>消息。此时，握手完成，客户端和服务器可以开始交换应用层数据。(见<code>Fig. 1</code> )</p><p>注意：为了帮助避免流水线停顿，<code>ChangeCipherSpec</code>是独立的<code>TLS</code>协议内容类型，实际上并不是<code>TLS</code>握手消息。</p><p>当客户端和服务器决定恢复上一个会话或重复现有会话（而不是协商新的安全参数）时，消息流如下所示：</p><p>客户端使用要恢复的会话的会话<code>ID</code>发送<code>ClientHello</code>。 然后，服务器检查其会话缓存以进行匹配。 如果发现匹配，并且服务器愿意在指定的会话状态下重新建立连接，则它将发送具有相同会话<code>ID</code>值的<code>ServerHello</code>。 在这一点上，客户端和服务器都必须发送更改加密规范消息，并直接进行完成的消息。 重新建立完成后，客户端和服务器可以开始交换应用层数据。（<code>Fig. 2</code>）如果找不到会话<code>ID</code>匹配，则服务器生成新的会话<code>ID</code>，<code>TLS</code>客户端和服务器执行完全握手。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c">      Client                                                Server<br><br>      ClientHello                   --------&gt;<br>                                                       ServerHello<br>                                                [ChangeCipherSpec]<br>                                    &lt;--------             Finished<br>      [ChangeCipherSpec]<br>      Finished                      --------&gt;<br>      Application Data              &lt;-------&gt;     Application Data<br><br>          Fig. <span class="hljs-number">2</span> - Message flow <span class="hljs-keyword">for</span> an abbreviated handshake<br>````<br><br>每条消息的内容和意义将在以下部分中详细介绍。<br><br>----<br>### <span class="hljs-number">7.4</span> 握手协议<br>&amp;emsp;&amp;emsp;`TLS`握手协议是`TLS`记录协议的定义更高级别的客户端之一。 该协议用于协商会话的安全属性。 握手消息被提供给`TLS`记录层，它们被封装在一个或多个`TLSPlaintext`结构内，按照当前活动会话状态的指定进行处理和传输。<br>```c<br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    hello_request(<span class="hljs-number">0</span>), client_hello(<span class="hljs-number">1</span>), server_hello(<span class="hljs-number">2</span>),<br>    certificate(<span class="hljs-number">11</span>), server_key_exchange (<span class="hljs-number">12</span>),<br>    certificate_request(<span class="hljs-number">13</span>), server_hello_done(<span class="hljs-number">14</span>),<br>    certificate_verify(<span class="hljs-number">15</span>), client_key_exchange(<span class="hljs-number">16</span>),<br>    finished(<span class="hljs-number">20</span>), (<span class="hljs-number">255</span>)<br>&#125; HandshakeType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    HandshakeType msg_type; <span class="hljs-comment">/* handshake type */</span><br>    uint24 length; <span class="hljs-comment">/* bytes in message */</span><br>    select (HandshakeType) &#123;<br>        <span class="hljs-keyword">case</span> hello_request: HelloRequest;<br>        <span class="hljs-keyword">case</span> client_hello: ClientHello;<br>        <span class="hljs-keyword">case</span> server_hello: ServerHello;<br>        <span class="hljs-keyword">case</span> certificate: Certificate;<br>        <span class="hljs-keyword">case</span> server_key_exchange: ServerKeyExchange;<br>        <span class="hljs-keyword">case</span> certificate_request: CertificateRequest;<br>        <span class="hljs-keyword">case</span> server_hello_done: ServerHelloDone;<br>        <span class="hljs-keyword">case</span> certificate_verify: CertificateVerify;<br>        <span class="hljs-keyword">case</span> client_key_exchange: ClientKeyExchange;<br>        <span class="hljs-keyword">case</span> finished: Finished;<br>    &#125; body;<br>&#125; Handshake;<br></code></pre></td></tr></table></figure><p>握手协议消息按照它们必须发送的顺序显示; 以意外的顺序发送握手信息会导致致命错误。 然而，不需要的握手信息可以省略。 注意排序的一个例外：证书消息在握手中使用两次（从服务器到客户端，然后从客户端到服务器），但仅在其第一个位置描述。 在<code>Hello</code>请求消息中不受这些排序规则约束的消息，可以在任何时候发送，但如果在握手中到达应该被客户端忽略。</p><hr><h4 id="741-hello消息"><a class="markdownIt-Anchor" href="#741-hello消息"></a> 7.4.1 Hello消息</h4><p><code>hello</code>阶段消息用于交换客户端和服务器之间的安全增强功能。 当新的会话开始时，记录层的连接状态加密、散列和压缩算法被初始化为空。 当前连接状态用于重新协商消息。</p><h5 id="7411-hello请求"><a class="markdownIt-Anchor" href="#7411-hello请求"></a> 7.4.1.1 Hello请求</h5><p>发送此消息时机：</p><p><code>Hello</code>请求消息可以由服务器随时发送。</p><p>此消息的含义：<br><code>Hello</code>请求是一个简单的通知，客户端应该在方便时发送客户端<code>hello</code>消息重新开始协商过程。 如果客户端正在协商会话，客户端将忽略此消息。 如果客户端不希望重新协商会话，客户端可能会忽略此消息，如果客户端希望通过<code>no_renegotiation</code>警报响应，客户端可能会忽略此消息。 由于握手消息旨在具有优先于应用数据的传输优先权，所以预期协商将在从客户端接收到的记录不超过几个之前开始。 如果服务器发送一个<code>hello</code>请求，但没有收到一个客户端<code>hello</code>作为响应，它可能会关闭一个致命警报的连接。</p><p>发送<code>hello</code>请求后，服务器不应重复请求，直到后续的握手协商完成。</p><p>此消息的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>&#125; HelloRequest;<br></code></pre></td></tr></table></figure><p>注意：此消息不应包含在消息散列中，这些消息在整个握手过程中维护，并在完成的消息和证书验证消息中使用。</p><h5 id="7412-客户端hello"><a class="markdownIt-Anchor" href="#7412-客户端hello"></a> 7.4.1.2 客户端hello</h5><p>发送此消息时机：</p><p>当客户端首先连接到服务器时，需要发送客户端<code>hello</code>作为其第一条消息。 客户端还可以发送一条客户端<code>hello</code>消息响应<code>hello</code>请求，或为了重新协商现有连接中的安全参数。</p><p>此消息的结构：</p><p>客户端<code>hello</code>消息包括随机结构，该协议在以后的协议中使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    uint32 gmt_unix_time;<br>    opaque random_bytes[<span class="hljs-number">28</span>];<br>&#125; Random;<br></code></pre></td></tr></table></figure><ul><li><code>gmt_unix_time</code></li></ul><blockquote><p>标准<code>UNIX 32</code>位格式的当前时间和日期（从<code>1970</code>年<code>1</code>月<code>1</code>日起，<code>GMT</code>开始的午夜之后的秒数），根据发件人的内部时钟。 基本的<code>TLS</code>协议不需要正确设置时钟; 较高级别或应用协议可以定义附加要求。</p></blockquote><ul><li><code>random_bytes</code></li></ul><blockquote><p>由安全随机数生成器生成的<code>28</code>字节。</p></blockquote><p>客户端<code>hello</code>消息包括可变长度会话标识符(<code>session identifier</code>)。 如果不为空，则该值标识客户端希望重用其安全参数的同一客户端和服务器之间的会话。 会话标识符可以来自较早的连接，该连接或另一个当前活动的连接。 如果客户端仅希望更新连接的随机结构和派生值，则第二个选项很有用，而第三个选项可以建立多个独立的安全连接，而不会重复完整的握手协议。 这些独立连接可以顺序或同时进行; 当握手协商完成交换完成的消息并持续存在时，<code>SessionID</code>将变为有效，直到由于老化或由于与会话相关联的连接遇到致命错误而被移除。 <code>SessionID</code>的实际内容由服务器定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">opaque SessionID&lt;<span class="hljs-number">0.</span><span class="hljs-number">.32</span>&gt;;<br></code></pre></td></tr></table></figure><p>警告：</p><p>因为<code>SessionID</code>是在没有加密或即时<code>MAC</code>保护的情况下传输的，所以服务器不得将机密信息放在会话标识符中，或让伪会话标识符的内容导致任何安全漏洞。 （请注意，握手的内容，包括<code>SessionID</code>，由握手结束时交换的完成消息保护。）</p><p>在客户机<code>hello</code>消息中从客户端传递到服务器的<code>CipherSuite</code>列表包含客户端按照客户端的偏好（首选的首选项）支持的加密算法的组合。 每个<code>CipherSuite</code>定义密钥交换算法、批量加密算法（包括密钥长度）和<code>MAC</code>算法。 服务器将选择一个加密组件，或者如果不提供可接受的选择，则返回握手失败警报并关闭连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">uint8 CipherSuite[<span class="hljs-number">2</span>]; <span class="hljs-comment">/* Cryptographic suite selector */</span><br></code></pre></td></tr></table></figure><p>客户端<code>hello</code>包括客户端支持的压缩算法列表，根据客户端的偏好进行排序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> null(<span class="hljs-number">0</span>), (<span class="hljs-number">255</span>) &#125; CompressionMethod;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ProtocolVersion client_version;<br>    Random random;<br>    SessionID session_id;<br>    CipherSuite cipher_suites&lt;<span class="hljs-number">2.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>    CompressionMethod compression_methods&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">8</span><span class="hljs-number">-1</span>&gt;;<br>&#125; ClientHello;<br></code></pre></td></tr></table></figure><ul><li><code>client_version</code></li></ul><blockquote><p>客户端希望在此会话期间通信的<code>TLS</code>协议版本。这应该是客户端支持的最新(最高价值)版本。对于此版本的规范，版本将为<code>3.1</code>(有关向后兼容性的详细信息，请参阅附录E)。</p></blockquote><ul><li><code>random</code></li></ul><blockquote><p>客户端生成的随机结构。</p></blockquote><ul><li><code>session_id</code></li></ul><blockquote><p>客户端希望用于此连接的会话的<code>ID</code>。 如果没有<code>session_id</code>可用或客户端希望生成新的安全参数，则该字段应为空。</p></blockquote><ul><li><code>cipher_suites</code></li></ul><blockquote><p>这是客户端支持的加密选项的列表，首先是客户端的首选项。 如果<code>session_id</code>字段不为空（意味着会话恢复请求），则此向量必须至少包含该会话的<code>cipher_suite</code>。 值在附录<code>A.5</code>中定义。</p></blockquote><ul><li><code>compression_methods</code></li></ul><blockquote><p>这是客户端支持的压缩方法的列表，按客户端偏好排序。 如果<code>session_id</code>字段不为空（意味着会话恢复请求），则它必须包含该会话中的<code>compression_method</code>。 此向量必须包含，并且所有实现必须支持<code>CompressionMethod.null</code>。 因此，客户端和服务器将始终能够就压缩方法达成一致。</p></blockquote><p>发送客户端<code>hello</code>消息后，客户端等待服务器<code>hello</code>消息。 除了<code>hello</code>请求之外，服务器返回的任何其他握手消息被视为致命错误。</p><p><strong>向前兼容性说明：</strong><br>为了向前兼容性，<code>ClientHello</code>消息允许在压缩方法之后包含额外的数据。 这些数据必须包含在握手哈希中，否则将被忽略。 这是唯一的握手信息，这是合法的; 对于所有其他消息，消息中的数据量必须与消息的描述精确匹配。</p><hr><h5 id="7413-服务器hello"><a class="markdownIt-Anchor" href="#7413-服务器hello"></a> 7.4.1.3 服务器hello</h5><p><strong>发送此消息时机：</strong><br>当服务器能够找到可接受的一组算法时，服务器将发送此消息以响应客户端的问候消息。 如果找不到这样的匹配，它会用握手失败警报进行响应。</p><p>此消息的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ProtocolVersion server_version;<br>    Random random;<br>    SessionID session_id;<br>    CipherSuite cipher_suite;<br>    CompressionMethod compression_method;<br>&#125; ServerHello;<br></code></pre></td></tr></table></figure><ul><li><code>server_version</code></li></ul><blockquote><p>该字段将包含客户机在客户机中建议的较低者，而服务器支持的最高级别。对于此版本的规范，版本为<code>3.1</code>（有关向后兼容性的详细信息，请参阅附录E）。</p></blockquote><ul><li><code>random</code></li></ul><blockquote><p>该结构由服务器生成，并且必须与<code>ClientHello.random</code>不同(并且独立于) <code>ClientHello.random</code>。</p></blockquote><ul><li><code>session_id</code></li></ul><blockquote><p>这是与此连接相对应的会话的身份。如果<code>ClientHello.session_id</code>不为空，服务器将在其会话缓存中查找匹配项。如果发现匹配，并且服务器愿意使用指定的会话状态建立新连接，则服务器将以与客户端提供的相同的值进行响应。这表示恢复会议，并且指示双方必须直接执行完成的消息。否则，此字段将包含标识新会话的不同值。服务器可能会返回一个空的<code>session_id</code>，以指示会话不会被缓存，因此无法恢复。如果会话恢复，则必须使用最初协商的相同加密组件来恢复会话。</p></blockquote><ul><li><code>cipher_suite</code></li></ul><blockquote><p>服务器从<code>ClientHello.cipher_suites</code>列表中选择的单一加密组件。对于恢复会话，该字段是恢复会话状态的值。</p></blockquote><ul><li><code>compression_method</code></li></ul><blockquote><p>服务器从<code>ClientHello.compression_methods</code>列表中选择的单一压缩算法。对于恢复会话，该字段是恢复会话状态的值。</p></blockquote><hr><h4 id="742-服务器证书"><a class="markdownIt-Anchor" href="#742-服务器证书"></a> 7.4.2 服务器证书</h4><p><strong>发送此消息时机：</strong><br>只要协商密钥交换方法不是匿名的，服务器必须发送证书。此消息将始终紧跟服务器的<code>hello</code>消息。</p><p><strong>此消息的含义：</strong><br>证书类型必须适用于所选加密组件的密钥交换算法，通常为<code>X.509v3</code>证书。 它必须包含与密钥交换方法匹配的密钥，如下所示。 除非另有说明，证书的签名算法必须与证书密钥的算法相同。 除非另有说明，否则公钥可以是任何长度的。</p><p><strong>密钥交换算法证书密钥类型:</strong></p><ul><li><code>RSA</code> : <code>RSA</code>公钥;证书必须允许密钥用于加密。</li><li><code>RSA_EXPORT</code>: 长度大于<code>512</code>位的<code>RSA_EXPORT RSA</code>公钥，可用于签名，或<code>512</code>位或更短的密钥，可用于加密或签名。</li><li><code>DHE_DSS</code>: <code>DSS</code>公钥。</li><li><code>DHE_DSS_EXPORT</code>: <code>DSS</code>公钥。</li><li><code>DHE_RSA</code>: 可用于签名的<code>RSA</code>公钥。</li><li><code>DHE_RSA_EXPORT</code>: 可用于签名的<code>RSA</code>公钥。</li><li><code>DH_DSS</code>: <code>Diffie-Hellman</code>密钥。用于签署证书的算法应为<code>DSS</code>。</li><li><code>DH_RSA</code> : <code>Diffie-Hellman</code>密钥。用于签署证书的算法应为<code>RSA</code>。</li></ul><p>所有证书配置文件，密钥和加密格式由<code>IETF PKIX</code>工作组<code>[PKIX]</code>定义。 当存在密钥使用扩展时，如上所述，必须为密钥设置数字签名比特，如上所述，密钥加密位必须存在以允许加密，如上所述。 <code>keyAgreement</code>位必须在<code>Diffie-Hellman</code>证书上设置。</p><p>由于为<code>TLS</code>协议指定了指定新密钥交换方法的<code>CipherSuites</code>，它们将暗示证书格式和所需的编码密钥信息。</p><p>此消息的结构为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">opaque ASN<span class="hljs-number">.1</span>Cert&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">24</span><span class="hljs-number">-1</span>&gt;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ASN<span class="hljs-number">.1</span>Cert certificate_list&lt;<span class="hljs-number">0.</span><span class="hljs-number">.2</span>^<span class="hljs-number">24</span><span class="hljs-number">-1</span>&gt;;<br>&#125; Certificate;<br></code></pre></td></tr></table></figure><ul><li><code>certificate_list</code></li></ul><blockquote><p>这是<code>X.509v3</code>证书的序列（链）。 发件人的证书必须列在列表中。 每个以下证书必须直接证明其前面的证书。 因为证书验证需要独立分发根密钥，所以指定根证书颁发机构的自签名证书可以可选地从链中省略，假设远端必须已经拥有它，以便在任何情况下验证它。</p></blockquote><p>相同的消息类型和结构将用于客户端对证书请求消息的响应。 请注意，如果客户端没有适当的证书发送以响应服务器的身份验证请求，客户端可能不会发送证书。</p><p>注意：<code>PKCS＃7 [PKCS7]</code>不用作证书向量的格式，因为<code>PKCS＃6 [PKCS6]</code>扩展证书不被使用。 另外<code>PKCS＃7</code>定义了一个<code>SET</code>而不是一个<code>SEQUENCE</code>，使解析列表的任务更加困难。</p><h4 id="743-服务器密钥交换消息"><a class="markdownIt-Anchor" href="#743-服务器密钥交换消息"></a> 7.4.3 服务器密钥交换消息</h4><p><strong>发送此消息时机：</strong><br>该消息将在服务器证书消息（或服务器hello消息，如果这是匿名协商）之后立即发送。</p><p>服务器密钥交换消息仅在服务器证书消息（如果发送）不包含足够的数据以允许客户端交换预主<code>secret</code>时才由服务器发送。 以下密钥交换方法是正确的：</p><ul><li><code>RSA_EXPORT</code> (如果服务器证书中的公钥长于512位)</li><li><code>DHE_DSS</code></li><li><code>DHE_DSS_EXPORT</code></li><li><code>DHE_RSA</code></li><li><code>DHE_RSA_EXPORT</code></li><li><code>DH_anon</code></li></ul><p>发送以下密钥交换方法的服务器密钥交换消息是不合法的：</p><ul><li><code>RSA</code></li><li><code>RSA_EXPORT</code> (当服务器证书中的公钥长度小于或等于512位时)</li><li><code>DH_DSS</code></li><li><code>DH_RSA</code></li></ul><p><strong>此消息的含义：</strong><br>该消息传达加密信息，以允许客户端传达预主<code>secret</code>：<code>RSA</code>公钥加密预主<code>secret</code>，或者<code>Diffie-Hellman</code>公钥，客户端可以通过该密钥完成密钥交换（结果是预主<code>secret</code>。）</p><p>由于额外的<code>CipherSuites</code>被定义为<code>TLS</code>，包括新的密钥交换算法，当且仅当与密钥交换算法相关联的证书类型没有提供足够的信息以供客户端交换前端秘密时，将发送服务器密钥交换消息。</p><p>注：根据目前的美国出口法，<code>RSA</code>模数大于<code>512</code>位可能不会用于从美国出口的软件的密钥交换。 使用此消息，可以使用证书中编码的较大的<code>RSA</code>密钥为<code>RSA_EXPORT</code>密钥交换方法签署临时较短的<code>RSA</code>密钥。</p><p>这个消息的结构为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> rsa, diffie_hellman &#125; KeyExchangeAlgorithm;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    opaque rsa_modulus&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>    opaque rsa_exponent&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>&#125; ServerRSAParams;<br></code></pre></td></tr></table></figure><ul><li><code>rsa_modulus</code></li></ul><blockquote><p><code>The modulus of the server's temporary RSA key</code>.</p></blockquote><ul><li><code>rsa_exponent</code></li></ul><blockquote><p><code>The public exponent of the server's temporary RSA key.</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    opaque dh_p&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>    opaque dh_g&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>    opaque dh_Ys&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>&#125; ServerDHParams; <span class="hljs-comment">/* Ephemeral DH parameters */</span><br></code></pre></td></tr></table></figure><ul><li><code>dh_p</code></li></ul><blockquote><p>用于<code>Diffie-Hellman</code>操作的质量模数。</p></blockquote><ul><li><code>dh_g</code></li></ul><blockquote><p>用于<code>Diffie-Hellman</code>操作的生成器。</p></blockquote><ul><li><code>dh_Ys</code></li></ul><blockquote><p>服务器的<code>Diffie-Hellman</code>公共值(<code>g ^ X mod p</code>)。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    select (KeyExchangeAlgorithm) &#123;<br>        <span class="hljs-keyword">case</span> diffie_hellman:<br>                ServerDHParams params;<br>                Signature signed_params;<br>        <span class="hljs-keyword">case</span> rsa:<br>                ServerRSAParams params;<br>                Signature signed_params;<br>    &#125;;<br>&#125; ServerKeyExchange;<br></code></pre></td></tr></table></figure><ul><li><code>PARAMS</code></li></ul><blockquote><p>服务器的密钥交换参数。</p></blockquote><ul><li><code>signed_params</code></li></ul><blockquote><p>对于非匿名密钥交换，对应的<code>params</code>值的散列值与适用于该哈希的签名相对应。</p></blockquote><ul><li><code>MD5_HASH</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">MD5（ClientHello.random + ServerHello.random + ServerParams）;<br></code></pre></td></tr></table></figure><ul><li><code>sha_hash</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">SHA（ClientHello.random + ServerHello.random + ServerParams）;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> anonymous, rsa, dsa &#125; SignatureAlgorithm;<br><br>select (SignatureAlgorithm) &#123;<br>    <span class="hljs-keyword">case</span> anonymous:<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> &#125;;<br>    <span class="hljs-keyword">case</span> rsa:<br>        digitally-<span class="hljs-type">signed</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            opaque md5_hash[<span class="hljs-number">16</span>];<br>            opaque sha_hash[<span class="hljs-number">20</span>];<br>        &#125;;<br>    <span class="hljs-keyword">case</span> dsa:<br>        digitally-<span class="hljs-type">signed</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            opaque sha_hash[<span class="hljs-number">20</span>];<br>        &#125;;<br>&#125; Signature;<br></code></pre></td></tr></table></figure><hr><h4 id="744-证书请求certificate-request"><a class="markdownIt-Anchor" href="#744-证书请求certificate-request"></a> 7.4.4 证书请求(Certificate request)</h4><p><strong>发送此消息时机：</strong><br>如果适用于所选择的加密组件，非匿名服务器可以选择从客户端请求证书。 此消息（如果发送）将立即遵循服务器密钥交换消息（如果已发送;否则为服务器证书消息）。</p><p><strong>此消息的结构如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    rsa_sign(<span class="hljs-number">1</span>), dss_sign(<span class="hljs-number">2</span>), rsa_fixed_dh(<span class="hljs-number">3</span>), dss_fixed_dh(<span class="hljs-number">4</span>),(<span class="hljs-number">255</span>)<br>&#125; ClientCertificateType;<br><br>opaque DistinguishedName&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ClientCertificateType certificate_types&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">8</span><span class="hljs-number">-1</span>&gt;;<br>    DistinguishedName certificate_authorities&lt;<span class="hljs-number">3.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>&#125; CertificateRequest;<br></code></pre></td></tr></table></figure><ul><li><code>certificate_types</code></li></ul><blockquote><p>此字段是请求的证书类型的列表，按照服务器的首选项的顺序进行排序。</p></blockquote><ul><li><code>certificate_authorities</code></li></ul><blockquote><p>可接受的认证机构的可分辨名称的列表。 这些可分辨名称可以为根<code>CA</code>或下级<code>CA</code>指定期望的可分辨名称; 因此，该消息可以用于描述已知的根和期望的授权空间。</p></blockquote><p>注意：<code>DistinguishedName</code>派生自<code>[X509]</code>。</p><p>注意：匿名服务器请求客户端的身份识别是一个致命的<code>handshake_failure</code>警报。</p><h4 id="745-服务器hello完成"><a class="markdownIt-Anchor" href="#745-服务器hello完成"></a> 7.4.5 服务器hello完成</h4><p>发送此消息时机：</p><p>服务器<code>hello</code>完成消息由服务器发送，以指示服务器的结束<code>hello</code>和关联的消息。 发送此消息后，服务器将等待客户端响应。</p><p><strong>此消息的含义：</strong><br>该消息意味着服务器完成发送消息以支持密钥交换，并且客户端可以继续进行密钥交换的阶段。</p><p>在收到服务器<code>hello</code>完成消息后，客户端应该验证服务器是否提供有效证书（如果需要），并检查服务器<code>hello</code>参数是否可以接受。</p><p>此消息的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> &#125; ServerHelloDone;<br></code></pre></td></tr></table></figure><h4 id="746-客户证书client-certificate"><a class="markdownIt-Anchor" href="#746-客户证书client-certificate"></a> 7.4.6 客户证书(Client certificate)</h4><p>发送此消息时机：</p><p>这是客户端在收到服务器<code>hello</code>完成消息后可以发送的第一条消息。 仅当服务器请求证书时，才会发送此消息。 如果没有合适的证书可用，客户端应发送不包含证书的证书消息。如果服务器需要客户端身份验证才能继续握手，则可能会使用致命的握手失败警报进行响应。使用第<code>7.4.2</code>节中定义的证书结构发送客户端证书。</p><p>注意：当使用基于静态<code>Diffie-Hellman</code>的密钥交换方法（<code>DH_DSS</code>或<code>DH_RSA</code>）时，如果客户端认证被请求，客户端证书中编码的<code>Diffie-Hellman</code>组和生成器必须与服务器指定的<code>Diffie-Hellman</code>参数匹配，如果客户端的参数 将用于密钥交换。</p><hr><h4 id="747-客户端密钥交换key-exchange消息"><a class="markdownIt-Anchor" href="#747-客户端密钥交换key-exchange消息"></a> 7.4.7 客户端密钥交换(key exchange)消息</h4><p>发送此消息时机：</p><p>此消息始终由客户端发送。如果发送，它将立即遵循客户端证书消息。否则，它将是客户端收到服务器<code>hello</code>完成消息后发送的第一条消息。</p><p>此消息的含义：</p><p>有了这个消息，即使是直接传输<code>RSA</code>加密的<code>secret</code>，还是通过传输<code>Diffie-Hellman</code>参数，这将允许每一方同意相同的前置<code>secret</code>，设置了前置<code>secret</code>。当密钥交换方式为<code>DH_RSA</code>或<code>DH_DSS</code>时，客户端已经被请求认证，客户端能够使用包含<code>Diffie-Hellman</code>公钥的证书进行响应，该密钥的参数（组和生成器）与服务器在其证书中指定的参数，此消息将不包含任何数据。</p><p>此消息的结构：</p><p>消息的选择取决于选择了哪种密钥交换方式。 <code>KeyExchangeAlgorithm</code>定义见<code>7.4.3</code>节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    select (KeyExchangeAlgorithm) &#123;<br>        <span class="hljs-keyword">case</span> rsa: EncryptedPreMasterSecret;<br>        <span class="hljs-keyword">case</span> diffie_hellman: ClientDiffieHellmanPublic;<br>    &#125; exchange_keys;<br>&#125; ClientKeyExchange;<br></code></pre></td></tr></table></figure><h5 id="7471-rsa加密的premaster-secret消息"><a class="markdownIt-Anchor" href="#7471-rsa加密的premaster-secret消息"></a> 7.4.7.1 RSA加密的premaster secret消息</h5><p>此消息的含义：</p><p>如果使用<code>RSA</code>进行密钥协商和认证，则客户端将生成一个<code>48</code>字节的<code>premaster secret</code>，使用服务器证书中的公钥或服务器密钥交换消息中提供的临时<code>RSA</code>密钥对其进行加密，并将发送含有加密<code>premaster secret</code>的结果消息。 该结构(<code>PreMasterSecret</code>)是客户端密钥交换消息的变体，而不是消息本身。</p><p>此消息的结构定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ProtocolVersion client_version;<br>    opaque random[<span class="hljs-number">46</span>];<br>&#125; PreMasterSecret;<br><br></code></pre></td></tr></table></figure><ul><li><code>client_version</code></li></ul><blockquote><p>客户端支持的最新（最新）版本。 这用于检测版本回滚攻击。 在接收到<code>premaster secret</code>后，服务器应该检查该值是否与客户机<code>hello</code>消息中客户端发送的值相匹配。</p></blockquote><ul><li><code>random</code></li></ul><blockquote><p><code>46</code>个安全生成的随机字节。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    public-key-encrypted PreMasterSecret pre_master_secret;<br>&#125; EncryptedPreMasterSecret;<br></code></pre></td></tr></table></figure><p>注意：<code>Daniel Bleichenbacher [BLEI]</code>发现的攻击可用于攻击使用<code>PKCS＃1</code>编码的<code>RSA</code>的<code>TLS</code>服务器。 攻击利用了以下事实：通过以不同的方式失败，可以强制TLS服务器来揭示当解密时特定消息是否正确<code>PKCS＃1</code>格式化。</p><p>避免这种攻击的脆弱性的最佳方法是以不正确格式的<code>RSA</code>块区分的方式处理格式错误的消息。 因此，当它接收到格式不正确的<code>RSA</code>块时，服务器应该生成一个随机的<code>48</code>字节的值，然后继续使用它作为前置机密信息。 因此，无论接收的<code>RSA</code>块是否被正确编码，服务器将相同地起作用。</p><ul><li><code>pre_master_secret</code></li></ul><blockquote><p>该随机值由客户端生成，用于生成主机密信息，如第<code>8.1</code>节所述。</p></blockquote><hr><h5 id="7472-客户diffie-hellman公共值"><a class="markdownIt-Anchor" href="#7472-客户diffie-hellman公共值"></a> 7.4.7.2 客户Diffie-Hellman公共值</h5><p>此消息的含义：</p><p>如果客户的证书中没有包含客户端的<code>Diffie-Hellman</code>公共值（<code>Yc</code>），则该结构将传达该消息。用于<code>Yc</code>的编码由枚举的<code>PublicValueEncoding</code>确定。该结构是客户端密钥交换消息的变体，而不是消息本身。</p><p>此消息的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> implicit, explicit &#125; PublicValueEncoding;<br></code></pre></td></tr></table></figure><ul><li><code>implicit</code></li></ul><blockquote><p>如果客户端证书已经包含合适的<code>Diffie-Hellman</code>密钥，则<code>Yc</code>是隐式的，不需要再次发送。 在这种情况下，客户端密钥交换消息将被发送，但将为空。</p></blockquote><ul><li><code>explicit</code></li></ul><blockquote><p><code>Yc needs to be sent.</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    select (PublicValueEncoding) &#123;<br>        <span class="hljs-keyword">case</span> implicit:<br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> &#125;;<br>        <span class="hljs-keyword">case</span> explicit:<br>                opaque dh_Yc&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>    &#125; dh_public;<br>&#125; ClientDiffieHellmanPublic;<br></code></pre></td></tr></table></figure><ul><li><code>dh_Yc</code></li></ul><blockquote><p>客户的<code>Diffie-Hellman</code>公共价值(<code>Yc</code>)。</p></blockquote><h4 id="748-证书验证certificate-verify"><a class="markdownIt-Anchor" href="#748-证书验证certificate-verify"></a> 7.4.8 证书验证(Certificate verify)</h4><p>发送此消息时机：</p><p>此消息用于提供客户端证书的显式验证。 该消息仅在具有签名功能的客户端证书（即除包含固定<code>Diffie-Hellman</code>参数的证书之外的所有证书）之后发送。 发送后，将立即按照客户端密钥交换消息。</p><p>此消息结构为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    Signature signature;<br>&#125; CertificateVerify;<br></code></pre></td></tr></table></figure><p>签名类型在<code>7.4.3</code>中定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">CertificateVerify.signature.md5_hash<br><span class="hljs-title function_">MD5</span><span class="hljs-params">(handshake_messages)</span>;<br><br>Certificate.signature.sha_hash<br><span class="hljs-title function_">SHA</span><span class="hljs-params">(handshake_messages)</span>;<br></code></pre></td></tr></table></figure><p>这里的<code>handshake_messages</code>是指从客户端开始发送或接收的所有握手消息，但不包括此消息，包括握手消息的类型和长度字段。 这是到目前为止交换的所有握手结构的连接。</p><h4 id="749-结束finished"><a class="markdownIt-Anchor" href="#749-结束finished"></a> 7.4.9 结束(Finished)</h4><p>发送此消息时机：</p><p>完成的消息总是在更改加密规范消息之后立即发送，以验证密钥交换和认证过程是否成功。 必须在其他握手消息和完成消息之间接收更改加密规范消息。</p><p>此消息的含义：</p><p>完成的消息是第一个使用刚刚协商的算法，密钥和秘密进行保护的消息。 完成消息的收件人必须验证内容是否正确。 一旦一方已经发送了其完成的消息并从其对等体接收并验证了完成的消息，则它可以开始通过连接发送和接收应用程序数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    opaque verify_data[<span class="hljs-number">12</span>];<br>&#125; Finished;<br></code></pre></td></tr></table></figure><ul><li><code>verify_data</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">PRF(master_secret，finished_label，MD5(handshake_messages)+<br>                SHA<span class="hljs-number">-1</span>(handshake_messages))[<span class="hljs-number">0.</span><span class="hljs-number">.11</span>];<br></code></pre></td></tr></table></figure><ul><li><code>finished_label</code></li></ul><blockquote><p>对于客户端发送的完成消息，字符串“客户端已完成”。 对于服务器发送的完成消息，字符串“<code>server finished</code>”。</p></blockquote><ul><li><code>handshake_messages</code></li></ul><blockquote><p>来自所有握手消息的所有数据，但不包括此消息。 这只是在握手层可见的数据，不包括记录层标题。这是到目前为止交换的所有握手结构的连接。</p></blockquote><p>如果完成的消息在握手中的适当位置前没有更改加密规范消息，则是致命的错误。</p><p>由服务器发送的完成消息中包含的哈希值包含<code>Sender.server</code>;由客户端发送的那些包含<code>Sender.client</code>。值<code>handshake_messages</code>包括从客户端开始，但不包括此完成的消息的所有握手消息。这可能与第<code>7.4.8</code>节中的<code>handshake_messages</code>不同，因为它将包括证书验证消息（如果发送）。此外，客户端发送的完成消息的<code>handshake_messages</code>将与服务器发送的完成消息的<code>handshake_messages</code>不同，因为第二个发送的消息将包括先前的消息。</p><p>注意：更改加密规则消息，警报和任何其他记录类型不是握手消息，不包括在散列计算中。此外，在握手哈希中省略了<code>Hello</code>请求消息。</p><hr><h2 id="8-加密计算cryptographic-computations"><a class="markdownIt-Anchor" href="#8-加密计算cryptographic-computations"></a> 8 加密计算(Cryptographic computations)</h2><p>  为了开始连接保护，<code>TLS Record</code>协议需要规定一套算法，一个<code>master secret</code>以及客户端和服务器的随机值。认证、加密和<code>MAC</code>算法由服务器选择的<code>cipher_suite</code>确定，并显示在服务器<code>hello</code>消息中。压缩算法在<code>hello</code>消息中协商，随机值在<code>hello</code>消息中交换。剩下的一切就是计算<code>master secret</code>。</p><h3 id="81-计算master-secret"><a class="markdownIt-Anchor" href="#81-计算master-secret"></a> 8.1 计算master secret</h3><p>对于所有密钥交换方法，使用相同的算法将<code>pre_master_secret</code>转换为<code>master_secret</code>。 一旦计算了<code>master_secret</code>，<code>pre_master_secret</code>应该从内存中删除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">master_secret = PRF(pre_master_secret, <span class="hljs-string">&quot;master secret&quot;</span>,<br>                    ClientHello.random + ServerHello.random)<br>[<span class="hljs-number">0.</span><span class="hljs-number">.47</span>];<br></code></pre></td></tr></table></figure><p><code>master_secret</code>长度一般为<code>48</code>字节。 <code>pre_master_secret</code>的长度将根据密钥交换方式而有所不同。</p><h4 id="811-rsa"><a class="markdownIt-Anchor" href="#811-rsa"></a> 8.1.1 RSA</h4><p>  当<code>RSA</code>用于服务器认证和密钥交换时，客户端生成一个<code>48</code>字节的<code>pre_master_secret</code>，并在服务器的公钥下加密，并发送到服务器。服务器使用其私钥来解密<code>pre_master_secret</code>。 双方然后将<code>pre_master_secret</code>转换为<code>master_secret</code>，如上所述。</p><p>使用<code>PKCS＃1 [PKCS1]</code>块类型1执行<code>RSA</code>数字签名。使用<code>PKCS＃1</code>块类型<code>2</code>执行<code>RSA</code>公钥加密。</p><h4 id="812-diffie-hellman"><a class="markdownIt-Anchor" href="#812-diffie-hellman"></a> 8.1.2 Diffie-Hellman</h4><p>  执行传统的<code>Diffie-Hellman</code>计算。 协商密钥（<code>Z</code>）用作<code>pre_master_secret</code>，并转换为<code>master_secret</code>，如上所述。</p><p>注意：<code>Diffie-Hellman</code>参数由服务器指定，可能是短暂的或包含在服务器的证书中。</p><hr><h2 id="9-强制加密组件mandatory-cipher-suites"><a class="markdownIt-Anchor" href="#9-强制加密组件mandatory-cipher-suites"></a> 9 强制加密组件(Mandatory Cipher Suites)</h2><p>  在没有另外指定的应用程序标准配置文件的情况下，<code>TLS</code>兼容应用程序必须实现加密组件<code>TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA</code>。</p><h2 id="10-应用程序数据协议application-data-protocol"><a class="markdownIt-Anchor" href="#10-应用程序数据协议application-data-protocol"></a> 10 应用程序数据协议(Application data protocol)</h2><p>  应用数据消息由记录层承载，并根据当前的连接状态进行分段，压缩和加密。 消息被视为记录层的透明数据。</p><h2 id="a-协议常数protocol-constant-values"><a class="markdownIt-Anchor" href="#a-协议常数protocol-constant-values"></a> A 协议常数(Protocol constant values)</h2><p>本节介绍协议类型和常量。</p><h3 id="a1-record-层"><a class="markdownIt-Anchor" href="#a1-record-层"></a> A.1 Record 层</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    uint8 major, minor;<br>&#125; ProtocolVersion;<br><br>ProtocolVersion version = &#123; <span class="hljs-number">3</span>, <span class="hljs-number">1</span> &#125;; <span class="hljs-comment">/* TLS v1.0 */</span><br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    change_cipher_spec(<span class="hljs-number">20</span>), alert(<span class="hljs-number">21</span>), handshake(<span class="hljs-number">22</span>),<br>    application_data(<span class="hljs-number">23</span>), (<span class="hljs-number">255</span>)<br>&#125; ContentType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ContentType type;<br>    ProtocolVersion version;<br>    uint16 length;<br>    opaque fragment[TLSPlaintext.length];<br>&#125; TLSPlaintext;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ContentType type;<br>    ProtocolVersion version;<br>    uint16 length;<br>    opaque fragment[TLSCompressed.length];<br>&#125; TLSCompressed;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ContentType type;<br>    ProtocolVersion version;<br>    uint16 length;<br>    select (CipherSpec.cipher_type) &#123;<br>        <span class="hljs-keyword">case</span> stream: GenericStreamCipher;<br>        <span class="hljs-keyword">case</span> block: GenericBlockCipher;<br>    &#125; fragment;<br>&#125; TLSCiphertext;<br><br>stream-ciphered <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    opaque content[TLSCompressed.length];<br>    opaque MAC[CipherSpec.hash_size];<br>&#125; GenericStreamCipher;<br><br>block-ciphered <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    opaque content[TLSCompressed.length];<br>    opaque MAC[CipherSpec.hash_size];<br>    uint8 padding[GenericBlockCipher.padding_length];<br>    uint8 padding_length;<br>&#125; GenericBlockCipher;<br></code></pre></td></tr></table></figure><hr><h3 id="a2-更改加密规范消息"><a class="markdownIt-Anchor" href="#a2-更改加密规范消息"></a> A.2 更改加密规范消息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> change_cipher_spec(<span class="hljs-number">1</span>), (<span class="hljs-number">255</span>) &#125; type;<br>&#125; ChangeCipherSpec;<br></code></pre></td></tr></table></figure><h3 id="a3-报警消息"><a class="markdownIt-Anchor" href="#a3-报警消息"></a> A.3 报警消息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> warning(<span class="hljs-number">1</span>), fatal(<span class="hljs-number">2</span>), (<span class="hljs-number">255</span>) &#125; AlertLevel;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    close_notify(<span class="hljs-number">0</span>),<br>    unexpected_message(<span class="hljs-number">10</span>),<br>    bad_record_mac(<span class="hljs-number">20</span>),<br>    decryption_failed(<span class="hljs-number">21</span>),<br>    record_overflow(<span class="hljs-number">22</span>),<br>    decompression_failure(<span class="hljs-number">30</span>),<br>    handshake_failure(<span class="hljs-number">40</span>),<br>    bad_certificate(<span class="hljs-number">42</span>),<br>    unsupported_certificate(<span class="hljs-number">43</span>),<br>    certificate_revoked(<span class="hljs-number">44</span>),<br>    certificate_expired(<span class="hljs-number">45</span>),<br>    certificate_unknown(<span class="hljs-number">46</span>),<br>    illegal_parameter(<span class="hljs-number">47</span>),<br>    unknown_ca(<span class="hljs-number">48</span>),<br>    access_denied(<span class="hljs-number">49</span>),<br>    decode_error(<span class="hljs-number">50</span>),<br>    decrypt_error(<span class="hljs-number">51</span>),<br>    export_restriction(<span class="hljs-number">60</span>),<br>    protocol_version(<span class="hljs-number">70</span>),<br>    insufficient_security(<span class="hljs-number">71</span>),<br>    internal_error(<span class="hljs-number">80</span>),<br>    user_canceled(<span class="hljs-number">90</span>),<br>    no_renegotiation(<span class="hljs-number">100</span>),<br>    (<span class="hljs-number">255</span>)<br>&#125; AlertDescription;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    AlertLevel level;<br>    AlertDescription description;<br>&#125; Alert;<br></code></pre></td></tr></table></figure><h3 id="a4-握手协议"><a class="markdownIt-Anchor" href="#a4-握手协议"></a> A.4 握手协议</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    hello_request(<span class="hljs-number">0</span>), client_hello(<span class="hljs-number">1</span>), server_hello(<span class="hljs-number">2</span>),<br>    certificate(<span class="hljs-number">11</span>), server_key_exchange (<span class="hljs-number">12</span>),<br>    certificate_request(<span class="hljs-number">13</span>), server_hello_done(<span class="hljs-number">14</span>),<br>    certificate_verify(<span class="hljs-number">15</span>), client_key_exchange(<span class="hljs-number">16</span>),<br>    finished(<span class="hljs-number">20</span>), (<span class="hljs-number">255</span>)<br>&#125; HandshakeType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    HandshakeType msg_type;<br>    uint24 length;<br>    select (HandshakeType) &#123;<br>        <span class="hljs-keyword">case</span> hello_request: HelloRequest;<br>        <span class="hljs-keyword">case</span> client_hello: ClientHello;<br>        <span class="hljs-keyword">case</span> server_hello: ServerHello;<br>        <span class="hljs-keyword">case</span> certificate: Certificate;<br>        <span class="hljs-keyword">case</span> server_key_exchange: ServerKeyExchange;<br>        <span class="hljs-keyword">case</span> certificate_request: CertificateRequest;<br>        <span class="hljs-keyword">case</span> server_hello_done: ServerHelloDone;<br>        <span class="hljs-keyword">case</span> certificate_verify: CertificateVerify;<br>        <span class="hljs-keyword">case</span> client_key_exchange: ClientKeyExchange;<br>        <span class="hljs-keyword">case</span> finished: Finished;<br>    &#125; body;<br>&#125; Handshake;<br></code></pre></td></tr></table></figure><hr><h4 id="a41-hello消息"><a class="markdownIt-Anchor" href="#a41-hello消息"></a> A.4.1 Hello消息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> &#125; HelloRequest;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    uint32 gmt_unix_time;<br>    opaque random_bytes[<span class="hljs-number">28</span>];<br>&#125; Random;<br><br>opaque SessionID&lt;<span class="hljs-number">0.</span><span class="hljs-number">.32</span>&gt;;<br><br>uint8 CipherSuite[<span class="hljs-number">2</span>];<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> null(<span class="hljs-number">0</span>), (<span class="hljs-number">255</span>) &#125; CompressionMethod;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ProtocolVersion client_version;<br>    Random random;<br>    SessionID session_id;<br>    CipherSuite cipher_suites&lt;<span class="hljs-number">2.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>    CompressionMethod compression_methods&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">8</span><span class="hljs-number">-1</span>&gt;;<br>&#125; ClientHello;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ProtocolVersion server_version;<br>    Random random;<br>    SessionID session_id;<br>    CipherSuite cipher_suite;<br>    CompressionMethod compression_method;<br>&#125; ServerHello;<br></code></pre></td></tr></table></figure><hr><h4 id="a42-服务器认证和密钥交换消息"><a class="markdownIt-Anchor" href="#a42-服务器认证和密钥交换消息"></a> A.4.2 服务器认证和密钥交换消息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c">opaque ASN<span class="hljs-number">.1</span>Cert&lt;<span class="hljs-number">2</span>^<span class="hljs-number">24</span><span class="hljs-number">-1</span>&gt;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ASN<span class="hljs-number">.1</span>Cert certificate_list&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">24</span><span class="hljs-number">-1</span>&gt;;<br>&#125; Certificate;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> rsa, diffie_hellman &#125; KeyExchangeAlgorithm;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    opaque RSA_modulus&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>    opaque RSA_exponent&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>&#125; ServerRSAParams;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    opaque DH_p&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>    opaque DH_g&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>    opaque DH_Ys&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>&#125; ServerDHParams;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    select (KeyExchangeAlgorithm) &#123;<br>        <span class="hljs-keyword">case</span> diffie_hellman:<br>            ServerDHParams params;<br>            Signature signed_params;<br>        <span class="hljs-keyword">case</span> rsa:<br>            ServerRSAParams params;<br>            Signature signed_params;<br>    &#125;;<br>&#125; ServerKeyExchange;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> anonymous, rsa, dsa &#125; SignatureAlgorithm;<br><br>select (SignatureAlgorithm) &#123;<br>    <span class="hljs-keyword">case</span> anonymous: <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> &#125;;<br>    <span class="hljs-keyword">case</span> rsa:<br>        digitally-<span class="hljs-type">signed</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            opaque md5_hash[<span class="hljs-number">16</span>];<br>            opaque sha_hash[<span class="hljs-number">20</span>];<br>        &#125;;<br>    <span class="hljs-keyword">case</span> dsa:<br>        digitally-<span class="hljs-type">signed</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            opaque sha_hash[<span class="hljs-number">20</span>];<br>        &#125;;<br>&#125; Signature;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    rsa_sign(<span class="hljs-number">1</span>), dss_sign(<span class="hljs-number">2</span>), rsa_fixed_dh(<span class="hljs-number">3</span>), dss_fixed_dh(<span class="hljs-number">4</span>),<br>    (<span class="hljs-number">255</span>)<br>&#125; ClientCertificateType;<br><br>opaque DistinguishedName&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ClientCertificateType certificate_types&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">8</span><span class="hljs-number">-1</span>&gt;;<br>    DistinguishedName certificate_authorities&lt;<span class="hljs-number">3.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>&#125; CertificateRequest;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> &#125; ServerHelloDone;<br></code></pre></td></tr></table></figure><h4 id="a43-客户端验证和密钥交换消息"><a class="markdownIt-Anchor" href="#a43-客户端验证和密钥交换消息"></a> A.4.3 客户端验证和密钥交换消息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    select (KeyExchangeAlgorithm) &#123;<br>        <span class="hljs-keyword">case</span> rsa: EncryptedPreMasterSecret;<br>        <span class="hljs-keyword">case</span> diffie_hellman: DiffieHellmanClientPublicValue;<br>    &#125; exchange_keys;<br>&#125; ClientKeyExchange;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ProtocolVersion client_version;<br>    opaque random[<span class="hljs-number">46</span>];<br>&#125; PreMasterSecret;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    public-key-encrypted PreMasterSecret pre_master_secret;<br>&#125; EncryptedPreMasterSecret;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> implicit, explicit &#125; PublicValueEncoding;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    select (PublicValueEncoding) &#123;<br>        <span class="hljs-keyword">case</span> implicit: <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>&#125;;<br>        <span class="hljs-keyword">case</span> explicit: opaque DH_Yc&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>    &#125; dh_public;<br>&#125; ClientDiffieHellmanPublic;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    Signature signature;<br>&#125; CertificateVerify;<br></code></pre></td></tr></table></figure><h4 id="a44-握手完成消息"><a class="markdownIt-Anchor" href="#a44-握手完成消息"></a> A.4.4 握手完成消息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    opaque verify_data[<span class="hljs-number">12</span>];<br>&#125; Finished;<br></code></pre></td></tr></table></figure><hr><h4 id="a5-加密组件ciphersuite"><a class="markdownIt-Anchor" href="#a5-加密组件ciphersuite"></a> A.5 加密组件(CipherSuite)</h4><p>以下值定义客户机<code>hello</code>和服务器<code>hello</code>消息中使用的<code>CipherSuite</code>代码。</p><p><code>CipherSuite</code>定义了<code>TLS</code>版本<code>1.0</code>中支持的加密规范。</p><p><code>TLS_NULL_WITH_NULL_NULL</code>被指定，并且是在该通道的第一次握手中的<code>TLS</code>连接的初始状态，但不能协商，因为它不提供比不安全连接更多的保护。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">CipherSuite TLS_NULL_WITH_NULL_NULL = &#123;<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>&#125;;<br></code></pre></td></tr></table></figure><p>以下<code>CipherSuite</code>定义要求服务器提供可用于密钥交换的<code>RSA</code>证书。 服务器可以在证书请求消息中请求具有<code>RSA</code>或<code>DSS</code>签名的证书。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">CipherSuite TLS_RSA_WITH_NULL_MD5 = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x01</span> &#125;;<br>CipherSuite TLS_RSA_WITH_NULL_SHA = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x02</span> &#125;;<br>CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5 = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x03</span> &#125;;<br>CipherSuite TLS_RSA_WITH_RC4_128_MD5 = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x04</span> &#125;;<br>CipherSuite TLS_RSA_WITH_RC4_128_SHA = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x05</span> &#125;;<br>CipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x06</span> &#125;;<br>CipherSuite TLS_RSA_WITH_IDEA_CBC_SHA = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x07</span> &#125;;<br>CipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x08</span> &#125;;<br>CipherSuite TLS_RSA_WITH_DES_CBC_SHA = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x09</span> &#125;;<br>CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x0A</span> &#125;;<br></code></pre></td></tr></table></figure><p>  以下<code>CipherSuite</code>定义用于服务器认证（可选的客户端认证）<code>Diffie-Hellman</code>。 <code>DH</code>表示加密组件，其中服务器的证书包含由证书颁发机构（<code>CA</code>）签名的<code>Diffie-Hellman</code>参数。 <code>DHE</code>表示短暂的<code>Diffie-Hellman</code>，其中<code>Diffie-Hellman</code>参数由已经由<code>CA</code>签名的<code>DSS</code>或<code>RSA</code>证书签名。 所使用的签名算法在<code>DH</code>或<code>DHE</code>参数之后指定。 服务器可以从客户端请求具有<code>RSA</code>或<code>DSS</code>签名的证书进行客户端认证，或者可以请求<code>Diffie-Hellman</code>证书。 客户端提供的任何<code>Diffie-Hellman</code>证书必须使用服务器描述的参数（组和生成器）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x0B</span> &#125;;<br>CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x0C</span> &#125;;<br>CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x0D</span> &#125;;<br>CipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x0E</span> &#125;;<br>CipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x0F</span> &#125;;<br>CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x10</span> &#125;;<br>CipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x11</span> &#125;;<br>CipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x12</span> &#125;;<br>CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x13</span> &#125;;<br>CipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x14</span> &#125;;<br>CipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x15</span> &#125;;<br>CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x16</span> &#125;;<br></code></pre></td></tr></table></figure><p>以下<code>CipherSuite</code>用于完全匿名的<code>Diffie-Hellman</code>通信，其中双方都不进行身份验证。 请注意，这种模式很容易受到中间人攻击，因此不推荐使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x17</span> &#125;;<br>CipherSuite TLS_DH_anon_WITH_RC4_128_MD5 = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x18</span> &#125;;<br>CipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x19</span> &#125;;<br>CipherSuite TLS_DH_anon_WITH_DES_CBC_SHA = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x1A</span> &#125;;<br>CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = &#123; <span class="hljs-number">0x00</span>,<span class="hljs-number">0x1B</span> &#125;;<br></code></pre></td></tr></table></figure><p>注意：第一个字节为<code>0xFF</code>的所有<code>CipherSuite</code>都被认为是私有的，可用于定义本地/实验算法。 这种类型的互操作性是本地事务。</p><p>注意：可以通过发布指定<code>CipherSuite</code>的<code>RFC</code>来注册其他<code>CipherSuite</code>，包括必要的<code>TLS</code>协议信息，包括消息编码，<code>pre_master_secret</code>推导，对称加密和<code>MAC</code>计算以及所涉及的算法的适当参考信息。 <code>RFC</code>编辑办公室可以自行决定发布不完全描述的<code>CipherSuite</code>的规范（例如，对于分类算法），如果该规范发现该技术规范具有技术上的意义并被完全指定。</p><p>注意：保留<code>CipherSuite</code>值<code>&#123;0x00,0x1C&#125;</code>和<code>&#123;0x00,0x1D&#125;</code>，以避免与<code>SSL 3</code>中基于<code>Fortezza</code>的<code>CipherSuite</code>冲突。</p><hr><h3 id="a6-安全参数"><a class="markdownIt-Anchor" href="#a6-安全参数"></a> A.6 安全参数</h3><p>这些安全参数由<code>TLS</code>握手协议确定，并作为参数提供给<code>TLS</code>记录层，以初始化连接状态。 <code>SecurityParameters</code>包括：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> null(<span class="hljs-number">0</span>), (<span class="hljs-number">255</span>) &#125; CompressionMethod;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> server, client &#125; ConnectionEnd;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> null, rc4, rc2, des, <span class="hljs-number">3</span>des, des40, idea &#125; BulkCipherAlgorithm;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> stream, block &#125; CipherType;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span> &#125; IsExportable;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> null, md5, sha &#125; MACAlgorithm;<br><br><span class="hljs-comment">/* The algorithms specified in CompressionMethod,</span><br><span class="hljs-comment">BulkCipherAlgorithm, and MACAlgorithm may be added to. */</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ConnectionEnd entity;<br>    BulkCipherAlgorithm bulk_cipher_algorithm;<br>    CipherType cipher_type;<br>    uint8 key_size;<br>    uint8 key_material_length;<br>    IsExportable is_exportable;<br>    MACAlgorithm mac_algorithm;<br>    uint8 hash_size;<br>    CompressionMethod compression_algorithm;<br>    opaque master_secret[<span class="hljs-number">48</span>];<br>    opaque client_random[<span class="hljs-number">32</span>];<br>    opaque server_random[<span class="hljs-number">32</span>];<br>&#125; SecurityParameters;<br></code></pre></td></tr></table></figure><hr><h2 id="b-词汇表"><a class="markdownIt-Anchor" href="#b-词汇表"></a> B 词汇表</h2><ul><li>应用程序协议(<code>application protocol</code>)</li></ul><blockquote><p>应用协议是通常直接在传输层之上（例如<code>TCP / IP</code>）层级的协议。 示例包括<code>HTTP</code>，<code>TELNET</code>，<code>FTP</code>和<code>SMTP</code>。</p></blockquote><ul><li>不对称加密(<code>asymmetric cipher</code>)</li></ul><blockquote><p>请参阅公钥加密。</p></blockquote><ul><li>认证(<code>authentication</code>)</li></ul><blockquote><p>认证是一个实体确定另一个实体身份的能力。</p></blockquote><ul><li>块加密(<code>block cipher</code>)</li></ul><blockquote><p>块加密是在被称为块的比特组中以明文操作的算法。 <code>64</code>位是一个通用的块大小。</p></blockquote><ul><li>批量加密(<code>bulk cipher</code>)</li></ul><blockquote><p>一种用于加密大量数据的对称加密算法。</p></blockquote><ul><li>加密块链接（<code>CBC</code>）</li></ul><blockquote><p><code>CBC</code>是使用块加密的每个明文块首先与先前的密文块（或者在第一个块的情况下，与初始化向量）进行异或运算的模式。对于解密，首先对每个块进行解密，然后与先前的密文块（或<code>IV</code>）进行异或。</p></blockquote><ul><li>证书(<code>certificate</code>)</li></ul><blockquote><p>作为<code>X.509</code>协议（<code>a.k.a. ISO</code>认证框架）的一部分，证书由受信任的证书颁发机构分配，并在一方的身份或某些其他属性及其公钥之间提供强大的绑定。</p></blockquote><ul><li>客户(<code>client</code>)</li></ul><blockquote><p>启动与服务器的<code>TLS</code>连接的应用程序实体。这可能意味着客户端启动了底层传输连接。服务器和客户端之间的主要操作差异在于服务器通常被认证，而客户端只可以被认证。</p></blockquote><ul><li>客户端写密钥(<code>client write key</code>)</li></ul><blockquote><p>用于加密客户端写入数据的密钥。</p></blockquote><ul><li>客户端写<code>MAC secret</code> (<code>client write MAC secret</code>)</li></ul><blockquote><p>用于验证客户端写入数据的机密信息。</p></blockquote><ul><li>连接(<code>connection</code>)</li></ul><blockquote><p>连接是提供合适类型服务的传输（在<code>OSI</code>分层模型定义中）。对于<code>TLS</code>，这种连接是对等关系。连接是短暂的。每个连接与一个会话相关联。</p></blockquote><ul><li>数据加密标准(<code>Data Encryption Standard</code>)</li></ul><blockquote><p><code>DES</code>是一种非常广泛使用的对称加密算法。 <code>DES</code>是具有<code>56</code>位密钥和<code>8</code>字节块大小的块加密。请注意，在<code>TLS</code>中，对于密钥生成目的，<code>DES</code>被视为具有<code>8</code>字节密钥长度（<code>64</code>位），但它仍然只提供<code>56</code>位保护。 （假设每个关键字节的低位被设置为在该关键字节中产生奇校验）。<code>DES</code>也可以以对于每个数据块使用三个独立的键和三个加密的模式来操作。这使用<code>168</code>位密钥（<code>TLS</code>密钥生成方法中的<code>24</code>个字节），并提供相当于<code>112</code>位的安全性。 <code>[DES]</code>，<code>[3DES]</code></p></blockquote><ul><li>数字签名标准(<code>DSS</code>)(<code>Digital Signature Standard</code>)</li></ul><blockquote><p>由美国国家标准技术研究所批准的数字签名标准，由美国商务部<code>1994</code>年<code>5</code>月出版的<code>NIST FIPS PUB 186</code>“数字签名标准”中定义。<code>[DSS]</code></p></blockquote><ul><li>数字签名(<code>digital signatures</code>)</li></ul><blockquote><p>数字签名利用公钥加密和单向哈希函数来产生可以被认证的数据的签名，并且难以伪造或拒绝。</p></blockquote><ul><li>握手(<code>handshake</code>)</li></ul><blockquote><p>客户端和服务器之间的初步协商，建立其交易参数。</p></blockquote><ul><li>初始化向量(<code>IV</code>)(<code>Initialization Vector</code>)</li></ul><blockquote><p>当在<code>CBC</code>模式中使用块加密时，初始化向量在加密之前与第一个明文块进行异或运算。</p></blockquote><ul><li><code>IDEA</code></li></ul><blockquote><p><code>Xuejia Lai</code>和<code>James Massey</code>设计的<code>64</code>位块加密。 <code>[IDEA]</code></p></blockquote><ul><li>消息认证码<code>(MAC)Message Authentication Code</code></li></ul><blockquote><p>消息认证码是从消息和一些<code>secret</code>计算的单向散列。在不知道<code>secret</code>的情况下难以伪造。其目的是检测消息是否已被更改。</p></blockquote><ul><li>主机密信息(<code>master secret</code>)</li></ul><blockquote><p>用于生成加密密钥，<code>MAC secret</code>和<code>IV</code>的安全<code>secret</code>数据。</p></blockquote><ul><li><code>MD5</code></li></ul><blockquote><p><code>MD5</code>是将任意长的数据流转换为固定大小（<code>16</code>字节）的摘要的安全散列函数。</p></blockquote><ul><li><p>公共密钥加密(<code>public key cryptography</code>) : &gt;一类使用双加密密码的加密技术。使用公钥加密的消息只能使用关联的私钥进行解密。相反，使用私钥签名的邮件可以通过公钥进行验证。</p></li><li><p>单向散列函数(<code>one-way hash function</code>) : &gt;将任意数量的数据转换为固定长度散列的单向转换。在计算上很难扭转转型或发现碰撞。 <code>MD5</code>和<code>SHA</code>是单向哈希函数的例子。</p></li><li><p><code>RC2</code></p></li></ul><blockquote><p>由<code>Ron Rivest</code>在<code>RSA Data Security，Inc. [RSADSI]</code>开发的块加密在<code>[RC2]</code>中描述。</p></blockquote><ul><li><code>RC4</code></li></ul><blockquote><p>由<code>RSA Data Security [RSADSI]</code>授权的流加密。兼容加密在<code>[RC4]</code>中有描述。</p></blockquote><ul><li><code>RSA</code></li></ul><blockquote><p>一种非常广泛使用的公共密钥算法，可用于加密或数字签名。 <code>[RSA]</code></p></blockquote><ul><li><code>salt</code></li></ul><blockquote><p>用于导出加密密钥的非秘密随机数据可抵抗预计算攻击。</p></blockquote><ul><li>服务器(<code>server</code>)</li></ul><blockquote><p>服务器是响应来自客户端的连接请求的应用程序实体。另见客户端。</p></blockquote><ul><li>会话(<code>session</code>)</li></ul><blockquote><p><code>TLS</code>会话是客户端和服务器之间的关联。会话由握手协议创建。会话定义了一组加密安全参数，可以在多个连接之间共享。会话用于避免每个连接的新安全参数的昂贵协商。</p></blockquote><ul><li>会话标识符(<code>session identifier</code>)</li></ul><blockquote><p>会话标识符是由标识特定会话的服务器生成的值。</p></blockquote><ul><li>服务器写入密钥(<code>server write key</code>)</li></ul><blockquote><p>用于加密由服务器写入的数据的密钥。</p></blockquote><ul><li>服务器写<code>MAC secret(server write MAC secret)</code></li></ul><blockquote><p>用于认证由服务器写入的数据的机密数据。</p></blockquote><ul><li><code>SHA</code></li></ul><blockquote><p>安全散列算法在<code>FIPS PUB 180-1</code>中定义。它产生一个<code>20</code>字节的输出。注意，所有对<code>SHA</code>的引用实际上都使用修改后的<code>SHA-1</code>算法。 <code>[SHA]</code></p></blockquote><ul><li><code>SSL</code></li></ul><blockquote><p><code>Netscape</code>的安全套接层协议<code>[SSL3]</code>。 <code>TLS</code>基于<code>SSL</code>版本<code>3.0</code></p></blockquote><ul><li>流加密(<code>stream cipher</code>)</li></ul><blockquote><p>将密钥转换为加密较强的密钥流的加密算法，然后将其与纯文本进行异或运算。</p></blockquote><ul><li>对称加密(<code>symmetric cipher</code>)</li></ul><blockquote><p>请参阅批量加密。</p></blockquote><ul><li>传输层安全(<code>TLS</code>)(<code>Transport Layer Security</code>)</li></ul><blockquote><p>这个协议还有互联网工程任务组（<code>IETF</code>）的传输层安全工作组。请参阅本文档末尾的“注释”。</p></blockquote><hr><h2 id="c-ciphersuite-定义"><a class="markdownIt-Anchor" href="#c-ciphersuite-定义"></a> C CipherSuite 定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c">CipherSuite                      Is       Key          Cipher      Hash<br>                             Exportable Exchange<br><br>TLS_NULL_WITH_NULL_NULL               * <span class="hljs-literal">NULL</span>           <span class="hljs-literal">NULL</span>        <span class="hljs-literal">NULL</span><br>TLS_RSA_WITH_NULL_MD5                 * RSA            <span class="hljs-literal">NULL</span>         MD5<br>TLS_RSA_WITH_NULL_SHA                 * RSA            <span class="hljs-literal">NULL</span>         SHA<br>TLS_RSA_EXPORT_WITH_RC4_40_MD5        * RSA_EXPORT     RC4_40       MD5<br>TLS_RSA_WITH_RC4_128_MD5                RSA            RC4_128      MD5<br>TLS_RSA_WITH_RC4_128_SHA                RSA            RC4_128      SHA<br>TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5    * RSA_EXPORT     RC2_CBC_40   MD5<br>TLS_RSA_WITH_IDEA_CBC_SHA               RSA            IDEA_CBC     SHA<br>TLS_RSA_EXPORT_WITH_DES40_CBC_SHA     * RSA_EXPORT     DES40_CBC    SHA<br>TLS_RSA_WITH_DES_CBC_SHA                RSA            DES_CBC      SHA<br>TLS_RSA_WITH_3DES_EDE_CBC_SHA           RSA            <span class="hljs-number">3</span>DES_EDE_CBC SHA<br>TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA  * DH_DSS_EXPORT  DES40_CBC    SHA<br>TLS_DH_DSS_WITH_DES_CBC_SHA             DH_DSS         DES_CBC      SHA<br>TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA        DH_DSS         <span class="hljs-number">3</span>DES_EDE_CBC SHA<br>TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA  * DH_RSA_EXPORT  DES40_CBC    SHA<br>TLS_DH_RSA_WITH_DES_CBC_SHA             DH_RSA         DES_CBC      SHA<br>TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA        DH_RSA         <span class="hljs-number">3</span>DES_EDE_CBC SHA<br>TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA * DHE_DSS_EXPORT DES40_CBC    SHA<br>TLS_DHE_DSS_WITH_DES_CBC_SHA            DHE_DSS        DES_CBC      SHA<br>TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA       DHE_DSS        <span class="hljs-number">3</span>DES_EDE_CBC SHA<br>TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA * DHE_RSA_EXPORT DES40_CBC    SHA<br>TLS_DHE_RSA_WITH_DES_CBC_SHA            DHE_RSA        DES_CBC      SHA<br>TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA       DHE_RSA        <span class="hljs-number">3</span>DES_EDE_CBC SHA<br>TLS_DH_anon_EXPORT_WITH_RC4_40_MD5    * DH_anon_EXPORT RC4_40       MD5<br>TLS_DH_anon_WITH_RC4_128_MD5            DH_anon        RC4_128      MD5<br>TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA   DH_anon        DES40_CBC    SHA<br>TLS_DH_anon_WITH_DES_CBC_SHA            DH_anon        DES_CBC      SHA<br>TLS_DH_anon_WITH_3DES_EDE_CBC_SHA       DH_anon        <span class="hljs-number">3</span>DES_EDE_CBC SHA<br></code></pre></td></tr></table></figure><ul><li><code>Indicates IsExportable is True</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">Key<br>     Exchange<br>     Algorithm       Description                        Key size limit<br><br>     DHE_DSS         Ephemeral DH with DSS signatures   None<br>     DHE_DSS_EXPORT  Ephemeral DH with DSS signatures   DH = <span class="hljs-number">512</span> bits<br>     DHE_RSA         Ephemeral DH with RSA signatures   None<br>     DHE_RSA_EXPORT  Ephemeral DH with RSA signatures   DH = <span class="hljs-number">512</span> bits,<br>                                                        RSA = none<br>     DH_anon         Anonymous DH, no signatures        None<br>     DH_anon_EXPORT  Anonymous DH, no signatures        DH = <span class="hljs-number">512</span> bits<br><br>     DH_DSS          DH with DSS-based certificates     None<br>     DH_DSS_EXPORT   DH with DSS-based certificates     DH = <span class="hljs-number">512</span> bits<br>     DH_RSA          DH with RSA-based certificates     None<br>     DH_RSA_EXPORT   DH with RSA-based certificates     DH = <span class="hljs-number">512</span> bits,<br>                                                        RSA = none<br>     <span class="hljs-literal">NULL</span>            No key exchange                    N/A<br>     RSA             RSA key exchange                   None<br>     RSA_EXPORT      RSA key exchange                   RSA = <span class="hljs-number">512</span> bits<br></code></pre></td></tr></table></figure><ul><li>密钥大小限制</li></ul><blockquote><p>密钥大小限制给出了在可出口的加密组件中可以合法用于加密的最大公钥的大小。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">                  Key      Expanded   Effective   IV    Block<br>Cipher       Type  Material Key Material  Key Bits  Size   Size<br><br><span class="hljs-literal">NULL</span>       * Stream   <span class="hljs-number">0</span>          <span class="hljs-number">0</span>           <span class="hljs-number">0</span>        <span class="hljs-number">0</span>     N/A<br>IDEA_CBC     Block   <span class="hljs-number">16</span>         <span class="hljs-number">16</span>         <span class="hljs-number">128</span>        <span class="hljs-number">8</span>      <span class="hljs-number">8</span><br>RC2_CBC_40 * Block    <span class="hljs-number">5</span>         <span class="hljs-number">16</span>          <span class="hljs-number">40</span>        <span class="hljs-number">8</span>      <span class="hljs-number">8</span><br>RC4_40     * Stream   <span class="hljs-number">5</span>         <span class="hljs-number">16</span>          <span class="hljs-number">40</span>        <span class="hljs-number">0</span>     N/A<br>RC4_128      Stream  <span class="hljs-number">16</span>         <span class="hljs-number">16</span>         <span class="hljs-number">128</span>        <span class="hljs-number">0</span>     N/A<br>DES40_CBC  * Block    <span class="hljs-number">5</span>          <span class="hljs-number">8</span>          <span class="hljs-number">40</span>        <span class="hljs-number">8</span>      <span class="hljs-number">8</span><br>DES_CBC      Block    <span class="hljs-number">8</span>          <span class="hljs-number">8</span>          <span class="hljs-number">56</span>        <span class="hljs-number">8</span>      <span class="hljs-number">8</span><br><span class="hljs-number">3</span>DES_EDE_CBC Block   <span class="hljs-number">24</span>         <span class="hljs-number">24</span>         <span class="hljs-number">168</span>        <span class="hljs-number">8</span>      <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><ul><li><p><code>Indicates IsExportable is true</code>.</p></li><li><p><code>Type</code></p></li></ul><blockquote><p>指示这是否是以<code>CBC</code>模式运行的流加密或块加密。</p></blockquote><ul><li><code>Key Material</code></li></ul><blockquote><p>用于生成写入密钥的<code>key_block</code>的字节数。</p></blockquote><ul><li><code>Expanded Key Material</code></li></ul><blockquote><p>实际馈入加密算法的字节数</p></blockquote><ul><li><code>Effective Key Bits</code></li></ul><blockquote><p>在加密程序中输入的关键材料中有多少熵材料。</p></blockquote><ul><li><code>IV Size</code></li></ul><blockquote><p>需要为初始化向量生成多少数据。 零为流加密; 其余为块加密的块大小。</p></blockquote><ul><li><code>Block Size</code></li></ul><blockquote><p>块加密在一个块中加密的数据量; 以<code>CBC</code>模式运行的块加密只能加密其块大小的偶数倍。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">Hash      Hash      Padding<br>function    Size       Size<br>  <span class="hljs-literal">NULL</span>       <span class="hljs-number">0</span>          <span class="hljs-number">0</span><br>  MD5        <span class="hljs-number">16</span>         <span class="hljs-number">48</span><br>  SHA        <span class="hljs-number">20</span>         <span class="hljs-number">40</span><br></code></pre></td></tr></table></figure><hr><h2 id="d-实施说明"><a class="markdownIt-Anchor" href="#d-实施说明"></a> D 实施说明</h2><p><code>TLS</code>协议不能防止许多常见的安全错误。 本节提供了几个建议来协助实现者。</p><h3 id="d1-临时rsa密钥"><a class="markdownIt-Anchor" href="#d1-临时rsa密钥"></a> D.1 临时RSA密钥</h3><p>  美国出口限制将用于加密的<code>RSA</code>密钥限制为<code>512</code>位，但不要对用于签名操作的<code>RSA</code>密钥的长度设置任何限制。证书通常需要大于<code>512</code>位，因为<code>512</code>位<code>RSA</code>密钥对于高价值交易或需要长期安全性的应用来说不够安全。一些证书也被指定为仅签名，在这种情况下，它们不能用于密钥交换。</p><p>  当证书中的公钥不能用于加密时，服务器签署一个临时的<code>RSA</code>密钥，然后进行交换。在可出口应用中，临时<code>RSA</code>密钥应为最大允许长度（即<code>512</code>位）。因为<code>512</code>位<code>RSA</code>密钥相对不安全，应该经常更改。对于典型的电子商务应用，建议每天或每<code>500</code>个交易更改密钥，如果可能，更频繁地更改密钥。请注意，虽然对于多个事务使用相同的临时密钥是可以接受的，但它必须在每次使用时都进行签名。</p><p><code>RSA</code>密钥生成是一个耗时的过程。在许多情况下，可以将低优先级进程分配给密钥生成任务。</p><p>无论何时完成新密钥，现有的临时密钥都可以用新的密钥替代。</p><h3 id="d2-随机数生成和种子"><a class="markdownIt-Anchor" href="#d2-随机数生成和种子"></a> D.2 随机数生成和种子</h3><p>  <code>TLS</code>需要一个加密安全的伪随机数生成器（<code>PRNG</code>）。 必须注意设计和做种<code>PRNG</code>。 基于安全散列操作的<code>PRNG</code>（最值得注意的是<code>MD5</code>和/或<code>SHA</code>）是可接受的，但不能提供比随机数发生器状态的大小更多的安全性。 （例如，基于<code>MD5</code>的<code>PRNG</code>通常提供<code>128</code>位的状态。）</p><p>要估计正在产生的种子材料的数量，请在每个种子字节中添加不可预测信息的位数。 例如，即使计数器值的总大小为<code>16</code>位或更多，从<code>PC</code>兼容的<code>18.2 Hz</code>定时器获取的击键定时值也分别提供<code>1</code>个或<code>2</code>个安全位。 为了播种<code>128</code>位<code>PRNG</code>，因此需要大约<code>100</code>个这样的定时器值。</p><p><strong>警告：</strong></p><p><code>RSAREF</code>中的种子功能和<code>3.0</code>之前的<code>BSAFE</code>版本与订单无关。 例如，如果提供<code>1000</code>个种子比特，则在种子功能的<code>1000</code>次单独调用中一次一个，则<code>PRNG</code>将结束于仅依赖于种子数据中的<code>0</code>或<code>1</code>种子比特数的状态（即有<code>1001</code>个可能的最终状态）。 使用<code>BSAFE</code>或<code>RSAREF</code>的应用必须特别注意确保正确播种。 这可以通过将种子位累加到缓冲器中并且一次处理它们或通过用每个种子位处理递增计数器来实现; 任何一种方法将重新引入依赖于种子过程的顺序。</p><h3 id="d3-证书和认证certificates-and-authentication"><a class="markdownIt-Anchor" href="#d3-证书和认证certificates-and-authentication"></a> D.3 证书和认证(Certificates and authentication)</h3><p>  实施负责验证证书的完整性，通常应支持证书撤销消息。 应始终验证证书，以确保受信任的证书颁发机构（<code>CA</code>）正确签名。 信任<code>CA</code>的选择和添加应该非常仔细地进行。 用户应该能够查看有关证书和根<code>CA</code>的信息。</p><h3 id="d4-加密组件ciphersuites"><a class="markdownIt-Anchor" href="#d4-加密组件ciphersuites"></a> D.4 加密组件(CipherSuites)</h3><p>  <code>TLS</code>支持一系列密钥大小和安全级别，包括一些不提供或最小安全性的密钥。 正确的实现可能不会支持许多加密组件。 例如，<code>40</code>位加密很容易被破解，所以需要强大安全性的实现不应该允许<code>40</code>位密钥。 同样地，匿名的<code>Diffie-Hellman</code>是非常不鼓励的，因为它不能防止中间人的袭击。 应用程序还应执行最小和最大密钥大小。 例如，包含<code>512</code>位<code>RSA</code>密钥或签名的证书链不适用于高安全性应用程序。</p><h2 id="e-向后兼容ssl"><a class="markdownIt-Anchor" href="#e-向后兼容ssl"></a> E 向后兼容SSL</h2><p>由于历史原因，为了避免浪费预留端口号码，由<code>TLS 1.0</code>，<code>SSL 3.0</code>和<code>SSL 2.0</code>保护的应用协议都经常共享相同的连接端口：例如<code>https</code>协议（由<code>SSL</code>保护的<code>HTTP</code>或<code>TLS</code>）使用端口<code>443</code>，无论使用哪种安全协议。因此，必须确定一些机制来区分和协商各种协议。</p><p><code>TLS</code>版本<code>1.0</code>和<code>SSL 3.0</code>非常相似;因此，两者都很容易。希望与<code>SSL 3.0</code>服务器进行协商的<code>TLS</code>客户端应使用<code>SSL 3.0</code>记录格式和客户机端口结构发送客户端<code>hello</code>消息，为版本字段发送<code>&#123;3，1&#125;</code>以注意它们支持<code>TLS 1.0</code>。如果服务器仅支持<code>SSL 3.0</code>，则会使用<code>SSL 3.0</code>服务器进行响应;如果它支持<code>TLS</code>，使用<code>TLS</code>服务器<code>hello</code>。然后协商进行协商的协议。</p><p>类似地，希望与<code>SSL 3.0</code>客户端互操作的<code>TLS</code>服务器应该接受<code>SSL 3.0</code>客户端<code>hello</code>消息，并且如果接收到版本字段为<code>&#123;3,0&#125;</code>的<code>SSL 3.0</code>客户端<code>hello</code>，则响应<code>SSL 3.0</code>服务器<code>hello</code>，表示该此客户端不支持<code>TLS</code>。</p><p>每当客户端已经知道服务器已知的最高协议（例如，恢复会话时），它应该启动该本地协议的连接。</p><p>支持<code>SSL 2.0</code>服务器的<code>TLS 1.0</code>客户端必须发送<code>SSL</code>版本<code>2.0</code>客户端问候消息<code>[SSL2]</code>。如果<code>TLS</code>服务器希望在同一连接端口上支持<code>SSL 2.0</code>客户端，那么<code>TLS</code>服务器应该接受客户端<code>hello</code>格式。与版本<code>2.0</code>规范的唯一偏差是能够指定值为<code>3</code>的版本，并支持<code>CipherSpec</code>中更多的加密类型。</p><p>警告：发送版本<code>2.0</code>客户端<code>hello</code>消息的能力将逐渐被淘汰。 实施者应尽全力推进。 <code>3.0</code>版提供了更好的机制来移动到较新的版本。</p><p>以下加密规范是<code>SSL</code>版本<code>2.0</code>的转储。 假设使用<code>RSA</code>进行密钥交换和认证。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">V2CipherSpec TLS_RC4_128_WITH_MD5 = &#123; <span class="hljs-number">0x01</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x80</span> &#125;;<br>V2CipherSpec TLS_RC4_128_EXPORT40_WITH_MD5 = &#123; <span class="hljs-number">0x02</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x80</span> &#125;;<br>V2CipherSpec TLS_RC2_CBC_128_CBC_WITH_MD5 = &#123; <span class="hljs-number">0x03</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x80</span> &#125;;<br>V2CipherSpec TLS_RC2_CBC_128_CBC_EXPORT40_WITH_MD5 = &#123; <span class="hljs-number">0x04</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x80</span> &#125;;<br>V2CipherSpec TLS_IDEA_128_CBC_WITH_MD5 = &#123; <span class="hljs-number">0x05</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x80</span> &#125;;<br>V2CipherSpec TLS_DES_64_CBC_WITH_MD5 = &#123; <span class="hljs-number">0x06</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x40</span> &#125;;<br>V2CipherSpec TLS_DES_192_EDE3_CBC_WITH_MD5 = &#123; <span class="hljs-number">0x07</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xC0</span> &#125;;<br></code></pre></td></tr></table></figure><p>使用以下语法可以将<code>TLS</code>原生的加密规范包含在<code>V2.0</code>客户端<code>hello</code>消息中。 其第一个字节等于零的任何<code>V2CipherSpec</code>元素将被<code>2.0</code>版服务器忽略。 发送任何上述<code>V2CipherSpecs</code>的客户端还应包含<code>TLS</code>等效项（见附录<code>A.5</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">V2CipherSpec (see TLS name) = &#123; <span class="hljs-number">0x00</span>, CipherSuite &#125;;<br></code></pre></td></tr></table></figure><h3 id="e1-版本2客户端hello"><a class="markdownIt-Anchor" href="#e1-版本2客户端hello"></a> E.1 版本2客户端hello</h3><p>以下使用本文档的演示模型介绍<code>2.0</code>版客户端的<code>hello</code>消息。 真正的定义仍然被认为是<code>SSL</code>版本<code>2.0</code>规范。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">uint8 V2CipherSpec[<span class="hljs-number">3</span>];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    uint8 msg_type;<br>    Version version;<br>    uint16 cipher_spec_length;<br>    uint16 session_id_length;<br>    uint16 challenge_length;<br>    V2CipherSpec cipher_specs[V2ClientHello.cipher_spec_length];<br>    opaque session_id[V2ClientHello.session_id_length];<br>    Random challenge;<br>&#125; V2ClientHello;<br></code></pre></td></tr></table></figure><ul><li><code>msg_type</code></li></ul><blockquote><p>此字段与版本字段一起标识版本2客户端hello消息。 值应为1（1）。</p></blockquote><ul><li><code>version</code></li></ul><blockquote><p>客户端支持的协议的最高版本（等于<code>ProtocolVersion.version</code>，请参阅附录<code>A.1</code>）。</p></blockquote><ul><li><code>cipher_spec_length</code></li></ul><blockquote><p>该字段是字段<code>cipher_specs</code>的总长度。 它不能为零，必须是<code>V2CipherSpec</code>长度（<code>3</code>）的倍数。</p></blockquote><ul><li><code>session_id_length</code></li></ul><blockquote><p>该字段的值必须为零或<code>16</code>.如果为零，客户端将创建一个新的会话。如果<code>16</code>，<code>session_id</code>字段将包含<code>16</code>个字节的会话标识。</p></blockquote><ul><li><code>challenge_length</code></li></ul><blockquote><p>客户端对服务器进行身份验证的挑战的长度（以字节为单位）此值必须为32。</p></blockquote><ul><li><code>cipher_specs</code></li></ul><blockquote><p>这是客户端愿意并能够使用的所有<code>CipherSpecs</code>的列表。服务器必须至少有一个<code>CipherSpec</code>可以接受。</p></blockquote><ul><li><code>session_id</code></li></ul><blockquote><p>如果该字段的长度不为零，它将包含客户端希望恢复的会话的标识。</p></blockquote><ul><li><code>challenge</code></li></ul><blockquote><p>客户端对服务器的挑战，使服务器识别自身是一个（几乎）任意长度的随机数。 <code>TLS</code>服务器将正确地证明挑战数据成为<code>ClientHello.random</code>数据（如果需要，填充前导零），如本协议规范中所述。如果挑战的长度大于<code>32</code>字节，则仅使用最后的<code>32</code>个字节。 <code>V3</code>服务器拒绝具有少于<code>16</code>个字节的挑战数据的<code>V2 ClientHello</code>是合法的（但不是必需的）。</p></blockquote><p>注意：恢复<code>TLS</code>会话的请求应该使用<code>TLS</code>客户端<code>hello</code>。</p><h3 id="e2-避免中间版本的回滚"><a class="markdownIt-Anchor" href="#e2-避免中间版本的回滚"></a> E.2 避免中间版本的回滚</h3><p>  当<code>TLS</code>客户端回到版本<code>2.0</code>兼容模式时，他们应该使用特殊的<code>PKCS＃1</code>块格式化。 这样做是为了使<code>TLS</code>服务器能够拒绝具有<code>TLS</code>功能的客户端的<code>2.0</code>版本会话。</p><p>当<code>TLS</code>客户端处于版本<code>2.0</code>兼容模式时，它们为加密密钥数据字段的<code>RSA</code>加密设置了<code>PKCS</code>填充（不包括填充的终端<code>null</code>）的右侧（最低有效）8个随机字节 的<code>CLIENT-MASTER-KEY</code>到<code>0x03</code>（其他填充字节是随机的）。 解密<code>ENCRYPTED-KEY-DATA</code>字段后，如果这8个填充字节为<code>0x03</code>，则支持<code>TLS</code>的服务器应该发出错误。 接收以这种方式填充的块的<code>2.0</code>版服务器将正常进行。</p><hr><h2 id="f-安全分析security-analysis"><a class="markdownIt-Anchor" href="#f-安全分析security-analysis"></a> F 安全分析(Security analysis)</h2><p>  握手协议负责选择<code>CipherSpec</code>并生成一个<code>Master Secret</code>，它们一起构成与安全会话关联的主加密参数。握手协议还可以可选地验证具有由受信任的证书颁发机构签名的证书的各方。</p><h3 id="f1-handshake-protocol"><a class="markdownIt-Anchor" href="#f1-handshake-protocol"></a> F.1. Handshake protocol</h3><p>  握手协议负责选择密码规范和生成一个主秘密，它们一起构成了主秘密与安全会话关联的加密参数。握手协议还可以有选择地验证具有由受信任的证书颁发机构签署的证书。</p><h4 id="f11-认证和密钥交换authentication-and-key-exchange"><a class="markdownIt-Anchor" href="#f11-认证和密钥交换authentication-and-key-exchange"></a> F.1.1 认证和密钥交换(Authentication and key exchange)</h4><p>  <code>TLS</code>支持三种认证方式：双方认证，未认证客户端进行服务器认证，全匿名。每当服务器进行身份验证时，该通道对于中间人的攻击是安全的，但完全匿名的会话本身就容易受到这种攻击。匿名服务器无法验证客户端。如果服务器进行身份验证，其证书消息必须提供一个有效的证书链，从而导致可接受的证书颁发机构。同样，经过身份验证的客户端必须向服务器提供可接受的证书。各方负责核实对方的证书是否有效，还没有过期或被吊销。</p><p>密钥交换过程的总体目标是创建一个通信方知道而攻击方不知道的<code>pre_master_secret</code>，这个参数将用于生成<code>master_secret</code>（参见第<code>8.1</code>节）。 <code>master_secret</code>需要生成证书验证和完成的消息、加密密钥和<code>MAC secrets</code>（参见<code>7.4.8,7.4.9</code>和<code>6.3</code>节）。通过发送正确的完成消息，各方因此证明他们知道正确的<code>pre_master_secret</code>。</p><h5 id="f111-匿名密钥交换"><a class="markdownIt-Anchor" href="#f111-匿名密钥交换"></a> F.1.1.1 匿名密钥交换</h5><p>  使用<code>RSA</code>或<code>Diffie-Hellman</code>进行密钥交换可以建立完全匿名的会话。 使用匿名<code>RSA</code>，客户端将从服务器密钥交换消息中提取的服务器未经认证的公钥，加密<code>pre_master_secret</code>后结果放在客户端密钥交换消息中发送给服务端。 由于窃听者不知道服务器的私有密钥，因此他们对<code>pre_master_secret</code>进行解码是不可行的。 （请注意，本文档中未定义匿名<code>RSA</code>加密组件）。</p><p>使用<code>Diffie-Hellman</code>，服务器的公共参数包含在服务器密钥交换消息中，客户端的公共参数在客户端密钥交换消息中发送。 不知道私钥的窃听者不能找到<code>Diffie-Hellman</code>的结果（即<code>pre_master_secret</code>）。</p><p>警告：完全匿名连接仅提供防范被动窃听的保护。 除非使用独立的防篡改信道来验证已完成的消息未被攻击者替代，否则在需要主动中间人攻击的环境中需要进行服务器认证。</p><h5 id="f112-rsa密钥交换和认证"><a class="markdownIt-Anchor" href="#f112-rsa密钥交换和认证"></a> F.1.1.2 RSA密钥交换和认证</h5><p>  使用<code>RSA</code>，合并了密钥交换和服务器认证。公钥可以包含在服务器的证书中，也可以是在服务器密钥交换消息中发送的临时<code>RSA</code>密钥。当使用临时RSA密钥时，它们由服务器的<code>RSA</code>或<code>DSS</code>证书签名。签名包括当前的<code>ClientHello.random</code>，所以老签名和临时密钥不能被重播。服务器可以使用单个临时<code>RSA</code>密钥进行多个协商会话。</p><p>注意：如果服务器需要大型证书但必须符合用于密钥交换的密钥的政府规定的大小限制，则临时<code>RSA</code>密钥选项很有用。</p><p>验证服务器的证书后，客户端使用服务器的公钥加密<code>pre_master_secret</code>。通过成功地解码<code>pre_master_secret</code>并产生正确的完成的消息，服务器证明它知道与服务器证书相对应的私钥。</p><p>当<code>RSA</code>用于密钥交换时，客户端将使用证书验证消息进行身份验证（请参见第<code>7.4.8</code>节）。客户端签署从<code>master_secret</code>派生值和所有先前握手消息。这些握手消息包括将签名绑定到服务器的服务器证书以及将签名绑定到当前握手过程的<code>ServerHello.random</code>。</p><h5 id="f113-diffie-hellman密钥交换认证"><a class="markdownIt-Anchor" href="#f113-diffie-hellman密钥交换认证"></a> F.1.1.3 Diffie-Hellman密钥交换认证</h5><p>  当使用<code>Diffie-Hellman</code>密钥交换时，服务器可以提供包含固定<code>Diffie-Hellman</code>参数的证书，或者可以使用服务器密钥交换消息发送一组使用<code>DSS</code>或<code>RSA</code>证书签名的临时<code>Diffie-Hellman</code>参数。临时参数在签名前使用<code>hello.random</code>值进行散列，以确保攻击者不会重播旧参数。在任一情况下，客户端都可以验证证书或签名，以确保参数属于服务器。</p><p>如果客户端具有包含固定<code>Diffie-Hellman</code>参数的证书，则其证书包含完成密钥交换所需的信息。请注意，在这种情况下，客户端和服务器将在每次通信时生成相同的<code>Diffie-Hellman</code>结果（即<code>pre_master_secret</code>）。为了防止<code>pre_master_secret</code>不再需要在内存中，应尽快将其转换为<code>master_secret</code>。客户端<code>Diffie-Hellman</code>参数必须与由服务器提供的密钥交换工作的那些参数兼容。</p><p>如果客户端具有标准的<code>DSS</code>或<code>RSA</code>证书或未经身份验证，则会在客户端密钥交换消息中向服务器发送一组临时参数，然后可选地使用证书验证消息进行身份验证。</p><h4 id="f12-版本回滚攻击"><a class="markdownIt-Anchor" href="#f12-版本回滚攻击"></a> F.1.2 版本回滚攻击</h4><p>  由于<code>TLS</code>包括对<code>SSL 2.0</code>版本的实质性改进，因此攻击者可能会尝试使具有<code>TLS</code>功能的客户端和服务器可以退回到<code>2.0</code>版本。如果（且只有）两个支持<code>TLS</code>的方使用<code>SSL 2.0</code>握手，则可能会发生此攻击。</p><p>  虽然使用非随机<code>PKCS＃1</code>块类型<code>2</code>消息填充的解决方案是不合适的，但它为<code>3.0</code>版服务器提供了一种合理的安全方式来检测攻击。在应用程序指定的等待阈值已过期之前，此解决方案不会对攻击者施加强制，并替换包含相同密钥（但具有正常填充）的新的<code>ENCRYPTED-KEY-DATA</code>消息。关注这种规模的攻击的各方不应该使用40位加密密钥。更改<code>PKCS</code>填充的最低有效8字节的填充不会影响协议中使用的带符号散列和<code>RSA</code>密钥长度的大小的安全性，因为这基本上等同于将输入块大小增加8个字节。</p><h4 id="f13-检测对握手协议的攻击"><a class="markdownIt-Anchor" href="#f13-检测对握手协议的攻击"></a> F.1.3 检测对握手协议的攻击</h4><p>  攻击者可能会尝试影响握手交换，使各方选择不同于通常选择的加密算法。 因为许多实现将支持40位可出口加密，有些甚至可以支持空加密或<code>MAC</code>算法，这种攻击是特别关注的。</p><p>  对于这种攻击，攻击者必须主动更改一个或多个握手信息。 如果发生这种情况，客户端和服务器将为握手消息散列计算不同的值。 结果，双方不会接受彼此的完成信息。 没有<code>master_secret</code>，攻击者无法修复完成的消息，所以攻击将被发现。</p><h4 id="f14-恢复会话"><a class="markdownIt-Anchor" href="#f14-恢复会话"></a> F.1.4 恢复会话</h4><p>  当通过恢复会话建立连接时，新的<code>ClientHello.random</code>和<code>ServerHello.random</code>值将与会话的<code>master_secret</code>进行散列。如果<code>master_secret</code>没有被泄露，并且用于产生加密密钥和<code>MAC secrets</code>的安全哈希操作是安全的，则连接应该是安全的并且有效地独立于先前的连接。攻击者无法使用已知的加密密钥或<code>MAC secret</code>来破坏<code>master_secret</code>，而不会破坏安全的哈希操作（使用<code>SHA</code>和<code>MD5</code>）。</p><p>  会话无法恢复，除非客户端和服务器同意。如果任何一方怀疑会话可能已被泄密，或者证书可能已经过期或被撤销，则应强制进行完全握手。建议会话<code>ID</code>生存期限为24小时的上限，因为获取<code>master_secret</code>的攻击者可能会模仿受感染方，直到相应的会话<code>ID</code>退出。可能在相对不安全的环境中运行的应用程序不应将会话<code>ID</code>写入稳定的存储。</p><h4 id="f15-md5和sha"><a class="markdownIt-Anchor" href="#f15-md5和sha"></a> F.1.5 MD5和SHA</h4><p><code>TLS</code>非常保守地使用散列函数。 在可能的情况下，<code>MD5</code>和<code>SHA</code>一起使用，以确保一个算法中的非灾难性缺陷不会破坏整体协议。</p><h3 id="f2-保护应用程序数据"><a class="markdownIt-Anchor" href="#f2-保护应用程序数据"></a> F.2 保护应用程序数据</h3><p><code>master_secret</code>与<code>ClientHello.random</code>和<code>ServerHello.random</code>进行散列，为每个连接生成唯一的数据加密密钥和<code>MAC secret</code>。</p><p>传输数据在发送前用<code>MAC</code>保护。 为了防止消息重放或修改攻击，<code>MAC</code>从<code>MAC secret</code>、序列号、消息长度、消息内容和两个固定字符串计算。 消息类型字段是必需的，以确保一个<code>TLS</code>记录层客户端的消息不被重定向到另一个。 序列号确保检测到删除或重新排序消息的尝试。 由于序列号是<code>64</code>位长，它们不应该溢出。 来自一方的消息无法插入对方的输出，因为它们使用独立的<code>MAC secret</code>。 类似地，服务器写入和客户端写入密钥是独立的，因此流加密密钥仅使用一次。</p><p>如果攻击者确实破解加密密钥，则可以读取该密钥加密的所有消息。 类似地，<code>MAC</code>密钥的妥协可以使消息修改攻击成为可能。 由于<code>MAC</code>也被加密，消息改变攻击通常需要打破加密算法以及<code>MAC</code>。</p><p>注意：<code>MAC secrets</code>可能大于加密密钥，因此即使加密密钥被破坏，消息也可以保持防篡改。</p><h3 id="f3-最后的注意事项"><a class="markdownIt-Anchor" href="#f3-最后的注意事项"></a> F.3 最后的注意事项</h3><p>为了能够提供安全连接的<code>TLS</code>，客户端和服务器系统，密钥和应用程序都必须是安全的。 此外，实现必须没有安全错误。</p><p>该系统对最弱和最强的密钥交换和认证一样支持，只能使用可靠的加密功能。 使用短公钥、<code>40</code>位批量加密密钥和匿名服务器必须特别谨慎。 在决定哪些证书和认证机构可以接受时，实施和使用者必须小心; 不诚实的认证机构可以造成巨大的损失。</p><hr><h2 id="g-专利声明"><a class="markdownIt-Anchor" href="#g-专利声明"></a> G 专利声明</h2><p>提出用于本协议的一些加密算法具有专利权利要求。 此外，<code>Netscape Communications Corporation</code>在本标准基于的安全套接字层（<code>SSL</code>）工作方面拥有专利权。 <code>RFC 2026</code>中定义的互联网标准流程要求从专利持有人那里获得一份声明，表明许可证将在合理的条件和条件下提供给申请人。</p><p>马萨诸塞理工学院已授予<code>RSA Data Security</code>公司对美国发行的以下专利的独家次级许可权：</p><blockquote><p>加密通信系统和方法（“<code>RSA</code>”），第<code>4,405,829</code>号</p></blockquote><p><code>Netscape Communications Corporation</code>已在美国发行以下专利：</p><blockquote><p>安全套接字层应用程序设备和方法（“<code>SSL</code>”），第<code>5,657,390</code>号</p></blockquote><p><code>Netscape Communications</code>发布了以下声明：</p><p>知识产权</p><p>安全链路层</p><p>美国专利商标局（“<code>PTO</code>”）最近向<code>Netscape</code>发布了美国专利号<code>5,657,390</code>（“<code>SSL</code>专利”），用于发明，称为安全套接字层（“<code>SSL</code>”）。 <code>IETF</code>正在考虑采用<code>SSL</code>作为具有安全特性的传输协议。 <code>Netscape</code>在以下条款和条件下鼓励免版税的采用和使用<code>SSL</code>协议：</p><ul><li><p>如果您今天已经有一个有效的<code>SSL Ref</code>许可证，其中包括<code>Netscape</code>的源代码，则不需要<code>SSL</code>专利下的附加专利许可。</p></li><li><p>如果您没有<code>SSL Ref</code>许可证，您可以拥有免版税许可证，以构建<code>SSL</code>专利权利要求或<code>IETF TLS</code>规范所涵盖的实施，只要您不为<code>Netscape</code>或其他公司声明任何专利权实施<code>SSL</code>或<code>IETF TLS</code>建议。</p></li></ul><p>什么是“专利权利要求书”：</p><p>专利权利要求书是在已发行的外国或国内专利中提出的：</p><p>1）为了实施<code>IETF TLS</code>规范的方法或构建产品，必须被侵害; 要么</p><p>2）要求<code>SSL</code>专利权利要求的要素和/或其等同物被侵害的专利权利要求。</p><p>互联网协会，互联网建筑委员会，互联网工程指导小组和国家研究计划公司对专利和专利申请的有效性或范围，以及保证条款的适用性均不承担任何责任。 上述互联网协会和其他团体对于可能适用于本标准实践的任何其他知识产权没有作出任何决定。 进一步考虑这些事项是用户自己的责任。</p><p>安全注意事项</p><p>在本备忘录中讨论安全问题。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><p>[3DES] W. Tuchman, “Hellman Presents No Shortcut Solutions To DES,” IEEE Spectrum, v. 16, n. 7, July 1979, pp40-41.</p></li><li><p>[BLEI] Bleichenbacher D., “Chosen Ciphertext Attacks against Protocols Based on RSA Encryption Standard PKCS #1” in Advances in Cryptology – CRYPTO’98, LNCS vol. 1462, pages: 1–12, 1998.</p></li><li><p>[DES] ANSI X3.106, “American National Standard for Information Systems-Data Link Encryption,” American National Standards Institute, 1983.</p></li><li><p>[DH1] W. Diffie and M. E. Hellman, “New Directions in Cryptography,” IEEE Transactions on Information Theory, V. IT-22, n. 6, Jun 1977, pp. 74-84.</p></li><li><p>[DSS] NIST FIPS PUB 186, “Digital Signature Standard,” National Institute of Standards and Technology, U.S. Department of Commerce, May 18, 1994.</p></li><li><p>[FTP] Postel J., and J. Reynolds, “File Transfer Protocol”, STD 9, RFC 959, October 1985.</p></li><li><p>[HTTP] Berners-Lee, T., Fielding, R., and H. Frystyk, “Hypertext Transfer Protocol – HTTP/1.0”, RFC 1945, May 1996.</p></li><li><p>[HMAC] Krawczyk, H., Bellare, M., and R. Canetti, “HMAC: Keyed- Hashing for Message Authentication,” RFC 2104, February 1997.</p></li><li><p>[IDEA] X. Lai, “On the Design and Security of Block Ciphers,” ETH Series in Information Processing, v. 1, Konstanz: Hartung-Gorre Verlag, 1992.</p></li><li><p>[MD2] Kaliski, B., “The MD2 Message Digest Algorithm”, RFC 1319, April 1992.</p></li><li><p>[MD5] Rivest, R., “The MD5 Message Digest Algorithm”, RFC 1321, April 1992.</p></li><li><p>[PKCS1] RSA Laboratories, “PKCS #1: RSA Encryption Standard,” version 1.5, November 1993.</p></li><li><p>[PKCS6] RSA Laboratories, “PKCS #6: RSA Extended Certificate Syntax Standard,” version 1.5, November 1993.</p></li><li><p>[PKCS7] RSA Laboratories, “PKCS #7: RSA Cryptographic Message Syntax Standard,” version 1.5, November 1993.</p></li><li><p>[PKIX] Housley, R., Ford, W., Polk, W. and D. Solo, “Internet Public Key Infrastructure: Part I: X.509 Certificate and CRL Profile”, RFC 2459, January 1999.</p></li><li><p>[RC2] Rivest, R., “A Description of the RC2® Encryption Algorithm”, RFC 2268, January 1998.</p></li><li><p>[RC4] Thayer, R. and K. Kaukonen, A Stream Cipher Encryption Algorithm, Work in Progress.</p></li><li><p>[RSA] R. Rivest, A. Shamir, and L. M. Adleman, “A Method for Obtaining Digital Signatures and Public-Key Cryptosystems,” Communications of the ACM, v. 21, n. 2, Feb 1978, pp. 120- 126.</p></li><li><p>[RSADSI] Contact RSA Data Security, Inc., Tel: 415-595-8782</p></li><li><p>[SCH] B. Schneier. Applied Cryptography: Protocols, Algorithms, and Source Code in C, Published by John Wiley &amp; Sons, Inc. 1994.</p></li><li><p>[SHA] NIST FIPS PUB 180-1, “Secure Hash Standard,” National Institute of Standards and Technology, U.S. Department of Commerce, Work in Progress, May 31, 1994.</p></li><li><p>[SSL2] Hickman, Kipp, “The SSL Protocol”, Netscape Communications Corp., Feb 9, 1995.</p></li><li><p>[SSL3] A. Frier, P. Karlton, and P. Kocher, “The SSL 3.0 Protocol”, Netscape Communications Corp., Nov 18, 1996.</p></li><li><p>[TCP] Postel, J., “Transmission Control Protocol,” STD 7, RFC 793, September 1981.</p></li><li><p>[TEL] Postel J., and J. Reynolds, “Telnet Protocol Specifications”, STD 8, RFC 854, May 1993.</p></li><li><p>[TEL] Postel J., and J. Reynolds, “Telnet Option Specifications”, STD 8, RFC 855, May 1993.</p></li><li><p>[X509] CCITT. Recommendation X.509: “The Directory - Authentication Framework”. 1988.</p></li><li><p>[XDR] R. Srinivansan, Sun Microsystems, RFC-1832: XDR: External Data Representation Standard, August 1995.</p></li></ul><p>完整版权声明</p><p>版权所有（C）互联网协会（1999）。版权所有。</p><p>本文件及其翻译可能会复制和提供给他人，对其作出任何评论或解释或协助实施的衍生作品，可以全部或部分内容，不受任何形式的限制，制作，复制，发布和分发条件是上述版权声明和本段都包含在所有这些副本和衍生作品中。但是，本文档本身不得以任何方式进行修改，例如删除版权声明或引用互联网协会或其他互联网组织，除非为制定互联网标准而需要，否则版权定义在必须遵循互联网标准过程，或按照要求将其翻译成英语以外的语言。</p><p>上述授予的有限权限是永久性的，不会被互联网协会或其继承人或受让人撤销。</p><p>本文档和本文档所包含的信息以“按原样”提供，互联网协会和互联网工程任务组织不承担任何明示或默示的担保，包括但不限于使用本文信息的任何担保侵犯任何权利或任何暗示的适销性或适用于特定用途的担保。</p><p>本文转载于 <a target="_blank" rel="noopener" href="http://kipway.com/kipway_TSL.html#__RefHeading___Toc2321_2423411238">The TLS Protocol V1.0 - RFC 2246 中文版</a></p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" class="category-chain-item">密码学</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%8E%9F%E5%88%9B/">#原创</a> <a href="/tags/TLS1-0/">#TLS1.0</a></div></div><div class="license-box my-3"><div class="license-title"><div>tls1.0协议原理</div><div>http://example.com/2023/08/16/tls/protocol/tls1_0/085550/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>EtcFly</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年8月16日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2024年3月5日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2023/08/16/mbedtls/cipher-performance/085708/" title="mbedtls算法性能测试"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">mbedtls算法性能测试</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2023/08/16/tls/protocol/tls1_2/085339/" title="tls1.2协议原理"><span class="hidden-mobile">tls1.2协议原理</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="waline"></div><script type="text/javascript">Fluid.utils.loadComments("#waline",(function(){Fluid.utils.createCssLink("https://lib.baomitu.com/waline/2.14.1/waline.min.css"),Fluid.utils.createScript("https://lib.baomitu.com/waline/2.14.1/waline.min.js",(function(){var i=Object.assign({serverURL:"https://etcfly.top:14000/",path:"window.location.pathname",meta:["nick","mail","link"],requiredMeta:["nick"],lang:"zh-CN",emoji:["https://unpkg.com/@waline/emojis@1.1.0/qq"],dark:'html[data-user-color-scheme="dark"]',wordLimit:0,pageSize:10},{el:"#waline",path:window.location.pathname});Waline.init(i),Fluid.utils.waitElementVisible("#waline .vcontent",()=>{var i="#waline .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://github.com/EtcFly" target="_blank" rel="nofollow noopener"><span>Copyright</span></a> <i class="iconfont icon-copyright"></i> <a href="https://etcfly.top:14100/share/yqTLFDlP/%E4%BB%97%E5%89%91%E8%B5%B0%E5%A4%A9%E6%B6%AF" target="_blank" rel="nofollow noopener"><span>2018-2024 EtcFly</span></a><div style="font-size:.85rem"><span>总访问量 <span style="color:#000" id="PVstatic">0</span> 次&nbsp</span> <span>总访客数 <span style="color:#000" id="UVstatic">0</span> 人&nbsp</span> <span>当前在线 <span style="color:#000" id="ACTstatic">0</span> 人&nbsp</span><script src="https://etcfly.top:14200/statistics" defer></script></div><div style="font-size:.85rem"><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="js/duration.js"></script></div></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener"></a> </span><span><a href="http://beian.miit.gov.cn/2023000858" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" alt="police-icon"> <span>浙ICP备2023000858号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/jquery.min.js"></script><script src="/live2d-widget/autoload.js"></script><script src="/js/star.js"></script><script src="/js/ribbon.min.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>