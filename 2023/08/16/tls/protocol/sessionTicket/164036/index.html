<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="EtcFly"><meta name="keywords" content=""><meta name="description" content="版权归作者所有, 转载请保留该部分声明。本文作者：EtcFly原文地址：https:&#x2F;&#x2F;etcfly.top              1. 为什么 ticket给TLS提供一个不需要在server存储会话状态(session)的机制来恢复会话。适用于TLS1.0, 1.1, 1.2。在以下情况下很有用:  server需要处理大量不同用户的session; server"><meta property="og:type" content="article"><meta property="og:title" content="tls快速会话恢复之sessionticket"><meta property="og:url" content="http://example.com/2023/08/16/tls/protocol/sessionTicket/164036/"><meta property="og:site_name" content="仗剑走天涯"><meta property="og:description" content="版权归作者所有, 转载请保留该部分声明。本文作者：EtcFly原文地址：https:&#x2F;&#x2F;etcfly.top              1. 为什么 ticket给TLS提供一个不需要在server存储会话状态(session)的机制来恢复会话。适用于TLS1.0, 1.1, 1.2。在以下情况下很有用:  server需要处理大量不同用户的session; server"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/chipher.png"><meta property="article:published_time" content="2023-08-16T16:40:36.000Z"><meta property="article:modified_time" content="2024-03-05T03:41:03.000Z"><meta property="article:author" content="EtcFly"><meta property="article:tag" content="原创"><meta property="article:tag" content="TLS"><meta property="article:tag" content="SessionTicket"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/img/chipher.png"><title>tls快速会话恢复之sessionticket 仗剑走天涯</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/fluid-extention.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:4},web_analytics:{enable:!0,follow_dnt:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"3AEufnWAJdp8cFODp1DXvrQU-MdYXbMMI",app_key:"mGJiL6xVvYv21ygqfynJoCyO",server_url:null,path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Strive For Dream</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="tls快速会话恢复之sessionticket"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-08-16 16:40" pubdate>2023年8月16日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 9.7k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 81 分钟 </span><span id="vvdpost_container_page_pvuv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="vvdpost_value_page_pv">0</span> 次&nbsp&nbsp <i class="iconfont icon-users" aria-hidden="true"></i> <span id="vvdpost_value_page_uv">0</span> 人</span><script>console.log(window.location.pathname);var httpRequest=new XMLHttpRequest;httpRequest.open("POST","https://etcfly.top:14200/poststats",!0),httpRequest.setRequestHeader("Content-type","application/json"),httpRequest.send(JSON.stringify(window.location.pathname)),httpRequest.onreadystatechange=function(){if(4==httpRequest.readyState&&200==httpRequest.status){var e=httpRequest.responseText,t=JSON.parse(e);console.log(t.pv);var o=document.querySelector("#vvdpost_container_page_pvuv");if(console.log(o),o){var n=document.querySelector("#vvdpost_value_page_pv");console.log(n);var s=document.querySelector("#vvdpost_value_page_uv");console.log(s),s&&s&&(n.innerText=t.pv,s.innerText=t.uv,o.style.display="inline")}}}</script></div></div></div></div></div></div><script async src="https://etcfly.top:14100/script.js" data-website-id="1a5c096d-21e5-4556-99b0-28c810c9c868"></script></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">tls快速会话恢复之sessionticket</h1><p class="note note-info">本文最后更新于：2024年3月5日 凌晨</p><div class="markdown-body"><div class="note note-success"><p>版权归作者所有, 转载请保留该部分声明。<br>本文作者：EtcFly<br>原文地址：<a target="_blank" rel="noopener" href="https://etcfly.top">https://etcfly.top</a></p></div><hr><h2 id="1-为什么"><a class="markdownIt-Anchor" href="#1-为什么"></a> 1. 为什么</h2><p><code>ticket</code>给TLS提供一个不需要在<code>server</code>存储会话状态(<code>session</code>)的机制来恢复会话。适用于<code>TLS1.0, 1.1, 1.2</code>。在以下情况下很有用:</p><ol><li><code>server</code>需要处理大量不同用户的<code>session</code>;</li><li><code>server</code>希望长时间存储<code>session</code>;</li><li>需要使用跨<code>server</code>的负载均衡;</li><li>在内存很少的嵌入式的<code>server</code>上。</li></ol><p>之前使用<code>session ID</code>的方法需要<code>server</code>将各种加密参数保存在本地，<code>client</code>下次希望恢复<code>session</code>的时候，就将<code>session ID</code>一并带上，<code>server</code>根据<code>session ID</code>查找本地缓存，找到对应的参数，然后直接建立握手。</p><p>对照上面几个情况，看<code>session ID</code>为什么不适用：</p><ol><li><code>server</code>处理大量会话需要在本地保存很多加密参数，内存占用和查找效率都会受影响；</li><li>长时间存储<code>session</code>导致长时间占用内存；</li><li><code>session</code>通常保存在一个<code>server</code>上，如果跨<code>server</code>负载均衡，需要将<code>session</code>统一存储，或支持跨<code>server</code>查询；</li><li>内存占用。</li></ol><hr><h2 id="2-是什么"><a class="markdownIt-Anchor" href="#2-是什么"></a> 2. 是什么</h2><h3 id="21-主要流程"><a class="markdownIt-Anchor" href="#21-主要流程"></a> 2.1. 主要流程</h3><ol><li>第一次完整握手，<code>client</code>在<code>ClientHello</code>中发送一个空的<code>session_ticket</code>扩展，表示<code>client</code>支持<code>ticket</code>会话恢复机制，</li><li><code>server</code>回复一个空的<code>session_ticket</code>扩展，表示自己将会发送一个新的<code>ticket</code>。<code>server</code>会在发送<code>CCS</code>之前发送一个<code>NewSessionTicket</code>的消息，里边存放着用于会话恢复的各种参数，并加密。</li><li><code>client</code>收到后将<code>ticket</code>和本地的<code>session</code>一并存储。</li><li>第二次会话恢复，<code>client</code>在<code>ClientHello</code>中发送不为空的<code>session_ticket</code>扩展，表示<code>client</code>希望进行会话恢复；</li><li><code>server</code>收到后，解密校验，如果校验正确，就使用该<code>session</code>参数进行会话恢复。</li><li>不管<code>server</code>接受不接受<code>client</code>发送的<code>ticket</code>，只要<code>server</code>觉得需要签发一个新的<code>ticket</code>，都要发送<code>session_ticket</code>扩展，也就是说，<code>ServerHello</code>中的<code>session_ticket</code>就是指示<code>server</code>是否发送<code>NewSessionTicket</code>的。</li></ol><p><code>server</code>签发<code>ticket</code>的过程如下：</p><p><img src="/2023/08/16/tls/protocol/sessionTicket/164036/ticket%E7%AD%BE%E5%8F%91%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt="ticket签发流程.png"></p><hr><h3 id="22-ticket的生命周期"><a class="markdownIt-Anchor" href="#22-ticket的生命周期"></a> 2.2. ticket的生命周期</h3><p>开始：</p><ol><li><code>client</code>从<code>server</code>接收新签发的<code>ticket</code>，保存到本地。</li></ol><p>结束：</p><ol><li><code>ticket</code>在<code>client</code>的缓存中超时；</li><li><code>ticket</code>由<code>client</code>的本地策略提前结束使用；</li><li><code>server</code>新签发了<code>ticket</code>，需要更新本地的<code>ticket</code>；</li><li>会话恢复时出错的时，需要删除<code>ticket</code>。</li></ol><hr><h3 id="23-ticket的相关结构"><a class="markdownIt-Anchor" href="#23-ticket的相关结构"></a> 2.3. ticket的相关结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    HandshakeType msg_type;<br>    uint24 length;<br>    select (HandshakeType) &#123;<br>        <span class="hljs-keyword">case</span> hello_request: HelloRequest;<br>        <span class="hljs-keyword">case</span> client_hello: ClientHello;<br>        <span class="hljs-keyword">case</span> server_hello: ServerHello;<br>        <span class="hljs-keyword">case</span> certificate: Certificate;<br>        <span class="hljs-keyword">case</span> server_key_exchange: ServerKeyExchange;<br>        <span class="hljs-keyword">case</span> certificate_request: CertificateRequest;<br>        <span class="hljs-keyword">case</span> server_hello_done: ServerHelloDone;<br>        <span class="hljs-keyword">case</span> certificate_verify: CertificateVerify;<br>        <span class="hljs-keyword">case</span> client_key_exchange: ClientKeyExchange;<br>        <span class="hljs-keyword">case</span> finished: Finished;<br>        <span class="hljs-keyword">case</span> session_ticket: NewSessionTicket; <span class="hljs-comment">/* NEW */</span><br>    &#125; body;<br>&#125; Handshake;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    uint32 ticket_lifetime_hint;<br>    opaque ticket&lt;<span class="hljs-number">0.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>&#125; NewSessionTicket;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    opaque key_name[<span class="hljs-number">16</span>];<br>    opaque iv[<span class="hljs-number">16</span>];<br>    opaque encrypted_state&lt;<span class="hljs-number">0.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>    opaque mac[<span class="hljs-number">32</span>];<br>&#125; ticket;<br></code></pre></td></tr></table></figure><p>其中:</p><ul><li><code>ticket_lifetime_hint</code>: <code>server</code>签发的该<code>ticket</code>的存活时间，从<code>client</code>收到<code>NewSessionTicket</code>开始计算，<code>client</code>以此判断该<code>ticket</code>的超时时间，单位是秒。</li><li><code>ticket</code>: <code>server</code>签发的<code>ticket</code>的具体内容，包含加密的一些参数。</li><li><code>key_name</code>: 表示该<code>ticket</code>用的是哪组秘钥加密认证的，通过该参数，<code>server</code>能很容易判断该<code>ticket</code>是不是自己签发的。通常是在<code>server</code>启动时随机生成的。</li><li><code>iv</code>: <code>server</code>使用<code>AES128-CBC</code>模式去加密<code>encrypted_state</code>，用到的<code>IV</code>保存在这里，<code>IV</code>每次签发<code>ticket</code>的时候都随机生成，每个<code>ticket</code>都不一样。</li><li><code>encrypted_state</code>：使用<code>AES128-CBC</code>和<code>iv</code>加密的实际<code>session</code>参数。</li><li><code>mac</code>: <code>server</code>使用<code>HMAC-SHA256</code>生成消息认证码<code>MAC</code>，认证的消息为: <code>key_name + iv + encrypted_state_len + encrypted_state</code>。</li><li><code>server</code>加密需要两个秘钥——<code>AES128-CBC</code>使用的加密秘钥，<code>HMAC-SHA256</code>使用的认证秘钥。</li></ul><p>其中<code>encrypted_state</code>中没有规定，建议是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ProtocolVersion protocol_version;<br>    CipherSuite cipher_suite;<br>    CompressionMethod compression_method;<br>    opaque master_secret[<span class="hljs-number">48</span>];<br>    ClientIdentity client_identity;<br>    uint32 timestamp;<br>&#125; StatePlaintext;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    anonymous(<span class="hljs-number">0</span>),<br>    certificate_based(<span class="hljs-number">1</span>),<br>    psk(<span class="hljs-number">2</span>)<br>&#125; ClientAuthenticationType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ClientAuthenticationType client_authentication_type;<br>    select (ClientAuthenticationType) &#123;<br>        <span class="hljs-keyword">case</span> anonymous: <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>&#125;;<br>        <span class="hljs-keyword">case</span> certificate_based:<br>            ASN<span class="hljs-number">.1</span>Cert certificate_list&lt;<span class="hljs-number">0.</span><span class="hljs-number">.2</span>^<span class="hljs-number">24</span><span class="hljs-number">-1</span>&gt;;<br>        <span class="hljs-keyword">case</span> psk:<br>            opaque psk_identity&lt;<span class="hljs-number">0.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;; <span class="hljs-comment">/* from [RFC4279] */</span><br>    &#125;;<br>&#125; ClientIdentity;<br></code></pre></td></tr></table></figure><p>其中:</p><ul><li><code>protocol_version</code>: 签发该<code>ticket</code>时候使用的协议版本。</li><li><code>cipher_suite</code>: 签发该<code>ticket</code>时候使用的加密套件。</li><li><code>master_secret</code>: 签发该<code>ticket</code>时候使用的主秘钥。</li><li><code>timestamp</code>: <code>server</code>用来判断<code>ticket</code>是否超时的。</li><li><code>client_identity</code>: 如果进行了<code>client</code>认证，这里会包含一些对<code>client</code>认证的消息。</li><li><code>certificate_based</code>: <code>client</code>认证使用了证书，这里就包含<code>client</code>的证书列表</li><li><code>psk_identity</code>: <code>client</code>使用了<code>PSK</code>认证，这里就包含了<code>psk</code>的<code>id</code>，用该<code>id</code>可以查找到<code>psk</code>的相关信息。</li></ul><h3 id="24-ticket跟原有的session-id机制的交互使用"><a class="markdownIt-Anchor" href="#24-ticket跟原有的session-id机制的交互使用"></a> 2.4. ticket跟原有的session ID机制的交互使用</h3><ol><li>第一次握手，如果<code>server</code>表示会签发新的<code>ticket</code>，<code>session ID</code>就为空；</li><li>第二次握手，<code>server</code>拒绝使用<code>ticket</code>，可以发送非空的<code>session ID</code>表示自己支持有状态的会话恢复；</li><li><code>client</code>收到<code>NewSessionTicket</code>的话，就丢掉任何从<code>ServerHello</code>中获取的<code>session ID</code>；</li><li><code>client</code>发送<code>ticket</code>的时候，也可以生成一个<code>session ID</code>放在<code>CH</code>中； <code>server</code>如果接受<code>ticket</code>，也可以在SH中返回同样的<code>session ID</code>，这样，<code>client</code>就能区分<code>server</code>什么时候在进行会话恢复，什么时候回退到完整握手——<code>server</code>接受了<code>ticket</code>，就使用<code>ticket</code>进行会话恢复，此时<code>session ID</code>跟<code>client</code>发送的一样，<code>server</code>不接受<code>ticket</code>，如果返回跟<code>client</code>一样的<code>session ID</code>，就表示自己支持有状态的会话恢复，如果返回空，就表示自己不支持会话恢复，会回退到完整握手。同时，因为这个<code>session ID</code>是<code>client</code>自己生成的，所以<code>server</code>不接受<code>ticket</code>的话，也查不到<code>session</code>，只能回复空的<code>session ID</code>，<code>client</code>就能根据<code>session ID</code>是否为空，来判断是否进行会话恢复。</li><li><code>client</code>发送<code>ticket</code>的时候，<code>server</code>禁止使用<code>session ID</code>进行有状态的恢复；</li></ol><p>总结起来就是：有限使用<code>ticket</code>机制。如果<code>client</code>自己生成了<code>session ID</code>，同时又发送了<code>ticket</code>，<code>server</code>也表示要用该<code>ticket</code>恢复，就返回同样的<code>session ID</code>。</p><hr><h2 id="3-安全性"><a class="markdownIt-Anchor" href="#3-安全性"></a> 3. 安全性</h2><ol><li>恢复失败的<code>session</code>会同时将<code>ticket</code>失效。</li><li>被盗的<code>ticket</code>也无所谓，因为<code>ticket</code>是加密的</li><li>伪造的<code>ticket</code>会导致握手失败</li><li><code>DoS</code>攻击的话，使用<code>key_name</code>可以抵御一部分，另外对<code>ticket</code>的解密校验尽量轻量化，比如使用对称加密算法。</li><li>加密<code>ticket</code>的<code>key</code>的管理建议：<ol><li><code>key</code>需要随机生成；</li><li><code>key</code>最少<code>128</code>位；</li><li><code>key</code>除了加密和校验<code>ticket</code>，不能用作他用；</li><li><code>key</code>应该周期性更新；</li><li><code>ticket</code>格式或加密算法更新的话，<code>key</code>需要同时更新。</li></ol></li><li><code>ticket</code>的有效时间可能超过<code>24</code>小时；</li></ol><hr><h2 id="4-tls13的ticket机制"><a class="markdownIt-Anchor" href="#4-tls13的ticket机制"></a> 4. TLS1.3的ticket机制</h2><p><code>TLS1.3</code>将有状态和无状态的会话恢复机制都整合到<code>PSK</code>机制中，当然，<code>PSK</code>也跟最开始诞生的功能有些不一样了，所以<code>TLS1.3</code>的<code>PSK</code>集中了原有的<code>PSK</code>功能、有状态的会话恢复功能(<code>session ID</code>)、无状态的会话恢复功能(<code>ticket</code>)。现在只简单说下<code>PSK</code>的会话恢复功能，<code>TLS1.3</code>的<code>PSK</code>的完整介绍后续再说。</p><p><code>TLS1.3</code>的会话恢复完全抛弃了<code>CH</code>和<code>SH</code>中<code>session_id</code>字段的功能，但为了兼容考虑，还会在会话恢复的时候进行相应的设置——<code>TLS1.3</code>的<code>client</code>跟<code>TLS1.2</code>的<code>server</code>协商的时候。</p><h3 id="41-主要流程"><a class="markdownIt-Anchor" href="#41-主要流程"></a> 4.1. 主要流程</h3><ol><li>第一次握手，<code>server</code>如果支持会话恢复，就在握手完成后，发送<code>NewSessionTicket</code>消息；</li><li><code>client</code>如果收到<code>NewSessionTicket</code>消息，就将当前<code>session</code>和其中的<code>ticket</code>存储到一起；</li><li>第二次握手，<code>client</code>在CH中发送<code>pre_shared_key</code>扩展项，其中携带<code>ticket</code>。</li><li><code>server</code>收到<code>psk</code>扩展后，先解密校验<code>ticket</code>，然后用<code>ticket</code>中的<code>PSK</code>相关<code>key</code>去校验<code>psk</code>。</li><li><code>server</code>在握手完成后，还可能再签发一个新的<code>NewSessionTicket</code>用于替换之前的。</li></ol><h3 id="42-消息格式"><a class="markdownIt-Anchor" href="#42-消息格式"></a> 4.2. 消息格式</h3><p><code>server</code>新签发的<code>ticket</code>的<code>NewSessionTicket</code>的消息格式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    uint32 ticket_lifetime;<br>    uint32 ticket_age_add;<br>    opaque ticket_nonce&lt;<span class="hljs-number">0.</span><span class="hljs-number">.255</span>&gt;;<br>    opaque ticket&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>    Extension extensions&lt;<span class="hljs-number">0.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-2</span>&gt;;<br>&#125; NewSessionTicket;<br></code></pre></td></tr></table></figure><p>其中:</p><ul><li><code>ticket_lifetime</code>: <code>ticket</code>从签发开始的有效时间，单位是秒。<code>server</code>不能签发超过7天(<code>604800s</code>)的<code>ticket</code>。为0表示该<code>ticket</code>应该立即丢掉。由于往返时间，<code>server</code>可以认为稍微超过一段有效时间的过期<code>ticket</code>仍然有效；</li><li><code>ticket_age_add</code>: 每次签发<code>ticket</code>都生成的一个随机数。用于隐藏CH中<code>pre_shared_key</code>扩展项中的<code>ticket</code>的有效时间，防止攻击者关联起多个连接。</li></ul><blockquote><p><code>psk</code>中的有效时间 = (<code>client</code>自己保存的<code>ticket</code>有效时间(单位毫秒) + <code>ticket_age_add</code> ) <code>module 2^32</code>。</p></blockquote><ul><li><code>ticket_nonce</code>: 该连接上签发的<code>ticket</code>的唯一标识，从0开始依次递增；</li><li><code>ticket</code>：用做CH中<code>psk</code>的<code>identity</code>，可以是一个索引(类似<code>session ID</code>一样的，这时候就是有状态的会话恢复)或者加密签名后的数据(类似原始的<code>ticket</code>，这时候就是无状态的会话恢复)。无状态的数据结构类似<code>TLS1.2</code>的<code>ticket</code>。</li><li><code>extensions</code>：<code>TLS1.3</code>现在只定义了一个扩展项——<code>early_data</code>，用于表示<code>server</code>最大能接受的早期数据大小(未加密的明文数据，不包括填充等，纯用户数据长度)。</li></ul><hr><h4 id="421-psk扩展项"><a class="markdownIt-Anchor" href="#421-psk扩展项"></a> 4.2.1. PSK扩展项</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    opaque identity&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>    uint32 obfuscated_ticket_age;<br>&#125; PskIdentity;<br><br>opaque PskBinderEntry&lt;<span class="hljs-number">32.</span><span class="hljs-number">.255</span>&gt;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    PskIdentity identities&lt;<span class="hljs-number">7.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>    PskBinderEntry binders&lt;<span class="hljs-number">33.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>&#125; OfferedPsks;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    select (Handshake.msg_type) &#123;<br>        <span class="hljs-keyword">case</span> client_hello: OfferedPsks;<br>        <span class="hljs-keyword">case</span> server_hello: uint16 selected_identity;<br>    &#125;;<br>&#125; PreSharedKeyExtension;<br></code></pre></td></tr></table></figure><p>其中:</p><ul><li><code>identity</code>: 就是<code>NewSessionTicket.ticket</code>。</li><li><code>obfuscated_ticket_age</code>：隐藏的<code>ticket</code>有效时间，外部导入的<code>PSK</code>该值是0，上次会话建立的<code>PSK</code>的有效时间 = (<code>client</code>自己保存的<code>ticket</code>有效时间(单位毫秒) + <code>ticket_age_add</code> ) <code>module 2^32</code>。注意该值是以<code>ms</code>为单位。</li><li><code>identities</code>： <code>cilent</code>希望用的一个<code>identity</code>列表，要是有<code>0-RTT</code>数据，必须用第一个<code>identity</code>(序号是0);</li><li><code>binders</code>: 一列<code>HMAC</code>的值，按照<code>identities</code>的顺序依次排列。目的是将<code>psk</code>(<code>ticket</code>或者<code>sesssion ID</code>或者外部导入的<code>PSK</code>)跟当前握手绑定。</li><li><code>selected_identity</code>: <code>server</code>如果使用<code>psk</code>会话恢复，返回选择的<code>identity</code>的序号(从0开始)。</li></ul><h3 id="43-tls13中ticket的安全性考虑"><a class="markdownIt-Anchor" href="#43-tls13中ticket的安全性考虑"></a> 4.3. TLS1.3中ticket的安全性考虑</h3><p>具体跟<code>0-RTT</code>的早期数据相关，后续再补。</p><hr><h2 id="5-openssl中关于ticket的相关接口"><a class="markdownIt-Anchor" href="#5-openssl中关于ticket的相关接口"></a> 5. openssl中关于ticket的相关接口</h2><h3 id="51-处理ticket中的加密数据"><a class="markdownIt-Anchor" href="#51-处理ticket中的加密数据"></a> 5.1. 处理ticket中的加密数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;openssl/tls1.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">SSL_CTX_set_tlsext_ticket_key_evp_cb</span><span class="hljs-params">(SSL_CTX sslctx,</span><br><span class="hljs-params">     <span class="hljs-type">int</span> (*cb)(SSL *s, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> key_name[<span class="hljs-number">16</span>],</span><br><span class="hljs-params">               <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> iv[EVP_MAX_IV_LENGTH],</span><br><span class="hljs-params">               EVP_CIPHER_CTX *ctx, EVP_MAC_CTX *hctx, <span class="hljs-type">int</span> enc))</span>;<br><span class="hljs-comment">// OpenSSL 3.0引入</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">SSL_CTX_set_tlsext_ticket_key_cb</span><span class="hljs-params">(SSL_CTX sslctx,</span><br><span class="hljs-params">     <span class="hljs-type">int</span> (*cb)(SSL *s, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> key_name[<span class="hljs-number">16</span>],</span><br><span class="hljs-params">               <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> iv[EVP_MAX_IV_LENGTH],</span><br><span class="hljs-params">               EVP_CIPHER_CTX *ctx, HMAC_CTX *hctx, <span class="hljs-type">int</span> enc))</span>;<br><span class="hljs-comment">// OpenSSL 3.0中被废除</span><br></code></pre></td></tr></table></figure><p>因为没有必要为每一个<code>session</code>都维护一个单独的加密状态，所以就交给用户去维护，然后用户负责<code>ticket</code>中部分参数的生成和和状态维护。</p><p><code>server</code>收到<code>client</code>发来的空的<code>session_ticket</code>扩展项，<code>enc</code>参数为1，表示这是要签发一个新的<code>ticket</code>，应用需要设置<code>key_name</code>, <code>iv</code>, <code>ctx</code>, <code>hctx</code> 给<code>lib</code>，<code>lib</code>会使用这些信息去创建并加密<code>ticket</code>。<code>server</code>收到<code>client</code>发来的非空的<code>session_ticket</code>扩展项，<code>enc</code>参数为0， 表示这是要解析一个<code>ticket</code>，<code>lib</code>会传给应用<code>key_name</code>, <code>iv</code>，应用需要设置<code>ctx</code>, <code>hctx</code>给<code>lib</code>，用以解密校验<code>ticket</code>。返回值表示应用是否希望签发使用新的ticket:</p><ul><li>2: 表示应用已经设置了<code>ctx</code>, <code>hctx</code>，可以继续处理当前收到的<code>ticket</code>，另外需要重新签发一个<code>ticket</code>，该cb会在签发新<code>ticket</code>的时候再被调用一次，这次<code>enc</code>会被设为1.</li><li>1: <code>ctx</code>, <code>hctx</code>已经设置了，可以继续按默认情况处理。</li><li>0: 表示应用无法处理该<code>ticket</code>，需要进行完整握手或者使用<code>session ID</code>会话恢复机制。</li><li>小于0: 出错了。</li></ul><hr><h3 id="52-设置签发和校验ticket时候的用户接口和数据"><a class="markdownIt-Anchor" href="#52-设置签发和校验ticket时候的用户接口和数据"></a> 5.2. 设置签发和校验ticket时候的用户接口和数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*SSL_CTX_generate_session_ticket_fn)</span><span class="hljs-params">(SSL *s, <span class="hljs-type">void</span> *arg)</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">SSL_TICKET_RETURN</span> <span class="hljs-params">(*SSL_CTX_decrypt_session_ticket_fn)</span><span class="hljs-params">(SSL *s, SSL_SESSION *ss, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *keyname, <span class="hljs-type">size_t</span> keyname_len, SSL_TICKET_STATUS status, <span class="hljs-type">void</span> *arg)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">SSL_CTX_set_session_ticket_cb</span><span class="hljs-params">(SSL_CTX *ctx, SSL_CTX_generate_session_ticket_fn gen_cb, SSL_CTX_decrypt_session_ticket_fn dec_cb, <span class="hljs-type">void</span> *arg)</span>;<br></code></pre></td></tr></table></figure><p><code>gen_cb()</code>是给应用提供的在生成<code>ticket</code>的时候进行的回调，在回调中应用可以调用<code>SSL_SESSION_set1_ticket_appdata()</code>在<code>ticket</code>中设置用户数据。<code>gen_cb()</code>中的参数<code>arg</code>就是<code>SSL_CTX_set_session_ticket_cb()</code>中的<code>arg</code>。</p><p>默认情况下，会话恢复的时候，<code>TLS1.2</code>不会再签发新的<code>ticket</code>，<code>TLS1.3</code>每次会话恢复都会签发新的<code>ticket</code>，可以用<code>SSL_CTX_set_tlsext_ticket_key_cb()</code>改变这个行为。</p><p><code>dec_cb()</code>是在库尝试解密<code>ticket</code>之后，给应用提供的回调。如果解密成功，<code>ss</code>中存放的是<code>session</code>，<code>keyname</code>和<code>keyname_len</code>是解密<code>ticket</code>使用的秘钥标识，<code>status</code>是解密是否成功，<code>arg</code>就是<code>SSL_CTX_set_session_ticket_cb()</code>中的<code>arg</code>。</p><p>该回调被调用的时候，<code>sessionss</code>还没绑定到<code>SSLs</code>上。做任何操作前， 都要先检查<code>status</code>：</p><ul><li><code>SSL_TICKET_EMPTY</code>: 空的<code>ticket</code>数据，就是<code>CH</code>中发送了空的<code>session_ticket</code>扩展，表示<code>client</code>支持<code>ticket</code>机制。只在<code>TLS1.2</code>之前使用，<code>TLS1.3</code>没意义。</li><li><code>SSL_TICKET_NO_DECRYPT</code>: 无法解密<code>ticket</code>，没有<code>ticket</code>数据可用，且应该给<code>client</code></li><li>发送新的<code>ticket</code>。</li><li><code>SSL_TICKET_SUCCESS</code>: <code>ticket</code>解密成功，可以使用应用数据，不应该发送新的<code>ticket</code>。</li><li><code>SSL_TICKET_SUCCESS_RENEW</code>: 跟<code>SSL_TICKET_SUCCESS</code>一样，但要发送新的<code>ticket</code>。</li></ul><p><code>dec_cb()</code>的返回值可以是：</p><ul><li><code>SSL_TICKET_RETURN_ABORT</code>: 应用判断需要中止握手，可能是由于检测<code>ticket</code>相关数据失败了。注意，<code>TLS1.3</code>一次握手可能会签发多个<code>ticket</code>，一个<code>ticket</code>失效不代表其他也失效，需要小心使用该返回值。</li><li><code>SSL_TICKET_RETURN_IGNORE</code>: 不使用该<code>ticket</code>，也不要签发新的<code>ticket</code>。</li><li><code>SSL_TICKET_RETURN_IGNORE_RENEW</code>:不使用该<code>ticket</code>，但签发一个新的<code>ticket</code>。</li><li><code>SSL_TICKET_RETURN_USE</code>: 使用<code>ticket</code>，但不签发新的<code>ticket</code>。</li><li><code>SSL_TICKET_RETURN_USE_RENEW</code>: 使用<code>ticket</code>，签发新的<code>ticket</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">SSL_SESSION_set1_ticket_appdata</span><span class="hljs-params">(SSL_SESSION *ss, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data, <span class="hljs-type">size_t</span> len)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">SSL_SESSION_get0_ticket_appdata</span><span class="hljs-params">(SSL_SESSION *ss, <span class="hljs-type">void</span> **data, <span class="hljs-type">size_t</span> *len)</span>;<br></code></pre></td></tr></table></figure><p><code>SSL_SESSION_set1_ticket_appdata()</code>可以将用户数据存入<code>ticket</code>发送给<code>client</code>。</p><hr><h3 id="53-设置tls13中ticket签发个数"><a class="markdownIt-Anchor" href="#53-设置tls13中ticket签发个数"></a> 5.3. 设置TLS1.3中ticket签发个数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">SSL_set_num_tickets</span><span class="hljs-params">(SSL *s, <span class="hljs-type">size_t</span> num_tickets)</span>;<br><span class="hljs-type">size_t</span> <span class="hljs-title function_">SSL_get_num_tickets</span><span class="hljs-params">(SSL *s)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">SSL_CTX_set_num_tickets</span><span class="hljs-params">(SSL_CTX *ctx, <span class="hljs-type">size_t</span> num_tickets)</span>;<br><span class="hljs-type">size_t</span> <span class="hljs-title function_">SSL_CTX_get_num_tickets</span><span class="hljs-params">(SSL_CTX *ctx)</span>;<br></code></pre></td></tr></table></figure><p>设置<code>TLS1.3</code>完整握手后，<code>server</code>可以发送多少个<code>ticket</code>。默认是2个，也可以是0个。会话恢复之后默认发送1个新的<code>ticket</code>，会话恢复后发送的个数不能用这些函数改变，可以用<code>SSL_CTX_set_tlsext_ticket_key_cb</code>改变。</p><p><code>TLS1.3</code>中，<code>server</code>使用<code>SSL_verify_client_post_handshake()</code>进行握手后认证，<code>client</code>发来证书后，还会签发新的<code>ticket</code>，这个<code>ticket</code>个数跟开始的握手时签发的个数一样，如果开始的是完整握手，那也可以在调用<code>SSL_verify_client_post_handshake()</code>之前调用<code>SSL_set_num_tickets</code>重新设置签发个数。</p><hr><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a target="_blank" rel="noopener" href="http://suntus.github.io/2020/03/14/ticket%E7%9B%B8%E5%85%B3/">ticket相关</a></li><li><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc8446">RFC8446-TLS1.3 PSK,ticket</a></li><li><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc5246">RFC5246-TLS1.2 session ID</a></li><li><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc5077">RFC5077-Transport Layer Security (TLS) Session Resumption without Server-Side State)</a></li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" class="category-chain-item">密码学</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%8E%9F%E5%88%9B/">#原创</a> <a href="/tags/TLS/">#TLS</a> <a href="/tags/SessionTicket/">#SessionTicket</a></div></div><div class="license-box my-3"><div class="license-title"><div>tls快速会话恢复之sessionticket</div><div>http://example.com/2023/08/16/tls/protocol/sessionTicket/164036/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>EtcFly</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年8月16日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2024年3月5日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2023/08/18/linux/http-optimise/145045/" title="http协议之优化技术"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">http协议之优化技术</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2023/08/16/tls/protocol/psk/163823/" title="tls加密之psk原理分析"><span class="hidden-mobile">tls加密之psk原理分析</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="waline"></div><script type="text/javascript">Fluid.utils.loadComments("#waline",(function(){Fluid.utils.createCssLink("https://lib.baomitu.com/waline/2.14.1/waline.min.css"),Fluid.utils.createScript("https://lib.baomitu.com/waline/2.14.1/waline.min.js",(function(){var i=Object.assign({serverURL:"https://etcfly.top:14000/",path:"window.location.pathname",meta:["nick","mail","link"],requiredMeta:["nick"],lang:"zh-CN",emoji:["https://unpkg.com/@waline/emojis@1.1.0/qq"],dark:'html[data-user-color-scheme="dark"]',wordLimit:0,pageSize:10},{el:"#waline",path:window.location.pathname});Waline.init(i),Fluid.utils.waitElementVisible("#waline .vcontent",()=>{var i="#waline .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://github.com/EtcFly" target="_blank" rel="nofollow noopener"><span>Copyright</span></a> <i class="iconfont icon-copyright"></i> <a href="https://etcfly.top:14100/share/yqTLFDlP/%E4%BB%97%E5%89%91%E8%B5%B0%E5%A4%A9%E6%B6%AF" target="_blank" rel="nofollow noopener"><span>2018-2024 EtcFly</span></a><div style="font-size:.85rem"><span>总访问量 <span style="color:#000" id="PVstatic">0</span> 次&nbsp</span> <span>总访客数 <span style="color:#000" id="UVstatic">0</span> 人&nbsp</span> <span>当前在线 <span style="color:#000" id="ACTstatic">0</span> 人&nbsp</span><script src="https://etcfly.top:14200/statistics" defer></script></div><div style="font-size:.85rem"><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="js/duration.js"></script></div></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener"></a> </span><span><a href="http://beian.miit.gov.cn/2023000858" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" alt="police-icon"> <span>浙ICP备2023000858号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/jquery.min.js"></script><script src="/live2d-widget/autoload.js"></script><script src="/js/star.js"></script><script src="/js/ribbon.min.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>