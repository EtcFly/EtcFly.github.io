<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="EtcFly"><meta name="keywords" content=""><meta name="description" content="版权归作者所有, 转载请保留该部分声明。本文作者：EtcFly原文地址：https:&#x2F;&#x2F;etcfly.top              介绍  一、TLS 协议的目的 TLS 的主要目标是为通信的双方提供一个安全的通道。对下层传输的唯一要求是一个可靠的有序的数据流。   认证： 通道的 Server 端应该总是被认证的；Client 端是可选的被认证。认证可以通过非对称算"><meta property="og:type" content="article"><meta property="og:title" content="tls1.3协议原理"><meta property="og:url" content="http://example.com/2023/08/16/tls/protocol/tls1_3/085339/"><meta property="og:site_name" content="仗剑走天涯"><meta property="og:description" content="版权归作者所有, 转载请保留该部分声明。本文作者：EtcFly原文地址：https:&#x2F;&#x2F;etcfly.top              介绍  一、TLS 协议的目的 TLS 的主要目标是为通信的双方提供一个安全的通道。对下层传输的唯一要求是一个可靠的有序的数据流。   认证： 通道的 Server 端应该总是被认证的；Client 端是可选的被认证。认证可以通过非对称算"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/chipher.png"><meta property="article:published_time" content="2023-08-16T08:53:39.000Z"><meta property="article:modified_time" content="2024-03-05T03:41:03.000Z"><meta property="article:author" content="EtcFly"><meta property="article:tag" content="原创"><meta property="article:tag" content="TLS1.3"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/img/chipher.png"><title>tls1.3协议原理 仗剑走天涯</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/fluid-extention.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:4},web_analytics:{enable:!0,follow_dnt:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"3AEufnWAJdp8cFODp1DXvrQU-MdYXbMMI",app_key:"mGJiL6xVvYv21ygqfynJoCyO",server_url:null,path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Strive For Dream</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="tls1.3协议原理"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-08-16 08:53" pubdate>2023年8月16日 早上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 68k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 564 分钟 </span><span id="vvdpost_container_page_pvuv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="vvdpost_value_page_pv">0</span> 次&nbsp&nbsp <i class="iconfont icon-users" aria-hidden="true"></i> <span id="vvdpost_value_page_uv">0</span> 人</span><script>console.log(window.location.pathname);var httpRequest=new XMLHttpRequest;httpRequest.open("POST","https://etcfly.top:14200/poststats",!0),httpRequest.setRequestHeader("Content-type","application/json"),httpRequest.send(JSON.stringify(window.location.pathname)),httpRequest.onreadystatechange=function(){if(4==httpRequest.readyState&&200==httpRequest.status){var e=httpRequest.responseText,t=JSON.parse(e);console.log(t.pv);var o=document.querySelector("#vvdpost_container_page_pvuv");if(console.log(o),o){var n=document.querySelector("#vvdpost_value_page_pv");console.log(n);var s=document.querySelector("#vvdpost_value_page_uv");console.log(s),s&&s&&(n.innerText=t.pv,s.innerText=t.uv,o.style.display="inline")}}}</script></div></div></div></div></div></div><script async src="https://etcfly.top:14100/script.js" data-website-id="1a5c096d-21e5-4556-99b0-28c810c9c868"></script></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">tls1.3协议原理</h1><p class="note note-info">本文最后更新于：2024年3月5日 凌晨</p><div class="markdown-body"><div class="note note-success"><p>版权归作者所有, 转载请保留该部分声明。<br>本文作者：EtcFly<br>原文地址：<a target="_blank" rel="noopener" href="https://etcfly.top">https://etcfly.top</a></p></div><hr><h1 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h1><h2 id="一-tls-协议的目的"><a class="markdownIt-Anchor" href="#一-tls-协议的目的"></a> 一、TLS 协议的目的</h2><p>TLS 的主要目标是为通信的双方提供一个安全的通道。对下层传输的唯一要求是一个可靠的有序的数据流。</p><ul><li><p>认证： 通道的 Server 端应该总是被认证的；Client 端是可选的被认证。认证可以通过非对称算法（例如，RSA, 椭圆曲线数字签名算法(ECDSA)，或 Edwards 曲线数字签名算法(EdDSA)）完成，或通过一个对称的预共享密钥（PSK)。</p></li><li><p>机密性：在建立完成的通道上发送的数据只能对终端是可见的。TLS 协议并不能隐藏它传输的数据的长度，但是终端能够通过填充 TLS 记录来隐藏长度，以此来提升针对流量分析技术的防护。</p></li><li><p>完整性：在建立完成的通道上面发送数据，不可能存在数据被篡改还没有发现的情况。即数据一旦被修改，对端会立即发现这个篡改。</p></li></ul><blockquote><p>以上 3 点是必须要保证的，即使网络攻击者已经完全掌握了网络，发生了 RFC 3552 中发生的情况。关于 TLS 安全问题，下面有单独的文章专门再讨论。</p></blockquote><h2 id="二-tls-协议的组成"><a class="markdownIt-Anchor" href="#二-tls-协议的组成"></a> 二、TLS 协议的组成</h2><p>TLS 协议主要由 2 大组件组成：</p><ul><li><p>握手协议<br>握手协议主要需要处理在通信双方之间进行认证的所有流程。包括密钥协商，参数协商，建立共享密钥。握手协议被设计用来抵抗篡改；如果连接未受到攻击，则活动攻击者不应该强制对等方协商不同的参数。</p></li><li><p>记录协议<br>使用由握手协议建立的参数来保护通信双方的流量。记录协议将流量分为一系列记录，每个记录独立地使用密钥来保护机密性。</p></li></ul><p>TLS 是一个独立的协议；高层协议可以透明地位于 TLS 之上。然而，TLS 标准并未指定协议如何增强 TLS 的安全，如何发起 TLS 握手以及如何理解认证证书交换，这些都留给运行在 TLS 之上的协议的设计者和实现者来判断。</p><p>本文档定义了 TLS 1.3 版。虽然 TLS 1.3 不是直接的与之前的版本兼容，所有版本的TLS都包含一个版本控制机制，即允许客户端和服务器通过协商，选出通信过程中采用的 TLS 版本。</p><p>TLS 1.3 的标准中取代和废除了以前版本的 TLS，包括 1.2 版本<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5246">RFC5246 The Transport Layer Security (TLS) Protocol Version 1.2</a>。也废除了在 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5077">RFC5077 Transport Layer Security (TLS) Session Resumption without Server-Side State</a> 里面定义的 TLS ticket 机制，并用 Pre-Shared Key (PSK) 机制取代它。由于 TLS 1.3 改变了密钥的导出方式，它更新了<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5705">RFC5705 Keying Material Exporters for Transport Layer Security (TLS)</a>。它也改变了在线证书状态协议（OCSP）消息的传输方式，因此更新了<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6066">RFC6066 https://tools.ietf.org/html/rfc6066</a>，废除了<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6961">RFC6961 he Transport Layer Security (TLS) Multiple Certificate Status Request Extension</a>，如 OCSP Status and SCT Extensions 这一章节所述。</p><h2 id="三-tls-13-和-tls-12-主要的不同"><a class="markdownIt-Anchor" href="#三-tls-13-和-tls-12-主要的不同"></a> 三、TLS 1.3 和 TLS 1.2 主要的不同</h2><p>下面描述了 TLS 1.2 和 TLS 1.3 的主要的差异。除去这些主要的差别以外，还有很多细微的不同。</p><ul><li><p>已支持的对称算法的列表已经去除了已经不再安全的算法了。列表保留了所有使用“带关联数据的认证加密”（AEAD）算法。 加密套件概念已经被改变，从记录保护算法（包括密钥长度）和一个用于密钥生成函数的 hash 和 HMAC 中分离为：认证、密钥交换机制。</p></li><li><p>增加了一个 0-RTT 模式，为一些应用数据在连接建立阶段节省了一次往返，这是以牺牲一定的安全特性为代价的。<strong>关于 0-RTT 的安全问题，下面会专门讨论</strong>。</p></li><li><p>静态 RSA 和 Diffie-Hellman 密码套件已经被删除；所有基于公钥的密钥交换算法现在都能提供前向安全。</p></li><li><p>所有 ServerHello 之后的握手消息现在都已经加密。新引入的 EncryptedExtension 消息允许之前在 ServerHello 中以明文发送的各种扩展同样享有保密性。</p></li><li><p>密钥导出函数被重新设计。新的设计使得密码学家能够通过改进的密钥分离特性进行更容易的分析。基于 HMAC 的提取 — 扩展密钥导出函数（HMAC-based Extract-and-Expand Key Derivation Function，HKDF）被用作一个基础的原始组件（primitive）。</p></li><li><p><strong>握手状态机已经进行了重大调整</strong>，以便更具一致性，删除多余的消息如 ChangeCipherSpec (除了由于中间件兼容性被需要时)。</p></li><li><p>椭圆曲线算法已经属于基本的规范，且包含了新的签名算法，如 EdDSA。TLS 1.3 删除了点格式协商以利于每个曲线使用单点格式。</p></li><li><p>其它的密码学改进包括改变 RSA 填充以使用 RSA 概率签名方案（RSASSA-PSS），删除压缩，DSA，和定制 DHE 组。</p></li><li><p>TLS1.2 的版本协商机制被废弃。支持在扩展中使用版本列表。这增加了与不正确地实现版本协商的 Server 的兼容性。</p></li><li><p>带有和不带 Server 端状态的会话恢复以及 TLS 早期版本的基于 PSK 密码套件已经被一个单独的新 PSK 交换所取代。</p></li><li><p>酌情更新引用以指向最新版本的 RFC（例如，RFC 5280 而不是 RFC 3280）。</p></li></ul><h2 id="四-对-tls-12-产生影响的改进"><a class="markdownIt-Anchor" href="#四-对-tls-12-产生影响的改进"></a> 四、对 TLS 1.2 产生影响的改进</h2><p>TLS 1.3 规范中还定义了一些可选的针对 TLS 1.2 的实现，包括那些不支持 TLS 1.3 的实现。</p><ul><li>TLS 1.3 中定义的版本降级保护机制</li><li>RSASSA-PSS 签名方案</li><li>ClientHello 中 “supported_versions” 的扩展可以被用于协商 TLS 使用的版本，它优先于 ClientHello 中的 legacy_version 域。</li><li>“signature_algorithms_cert” 扩展允许一个 Client 显示它使用哪种签名算法验证 X.509 证书。</li></ul><h2 id="五-tls-13-协议概览"><a class="markdownIt-Anchor" href="#五-tls-13-协议概览"></a> 五、TLS 1.3 协议概览</h2><p>安全通道所使用的密码参数由 TLS 握手协议生成。这个 TLS 的子协议，握手协议在 Client 和 Server 第一次通信时使用。握手协议允许两端协商一个协议版本，选择密码算法，选择性互相认证，并建立共享的密钥数据。一旦握手完成，双方就会使用建立好的密钥保护应用层数据。</p><p>一个失败的握手或其它的协议错误会触发连接的中止，在这之前可以有选择地发送一个警报消息，遵循 Alert Protocol 协议。</p><p>TLS 1.3 支持 3 种基本密钥交换模式：</p><ul><li>(EC)DHE (基于有限域或椭圆曲线的 Diffie-Hellman)</li><li>PSK - only</li><li>PSK with (EC)DHE</li></ul><p>下图显示了 TLS 握手的全部流程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">       Client                                           Server<br><br>Key  ^ ClientHello<br>Exch | + key_share*<br>     | + signature_algorithms*<br>     | + psk_key_exchange_modes*<br>     v + pre_shared_key*       --------&gt;<br>                                                  ServerHello  ^ Key<br>                                                 + key_share*  | Exch<br>                                            + pre_shared_key*  v<br>                                        &#123;EncryptedExtensions&#125;  ^  Server<br>                                        &#123;CertificateRequest*&#125;  v  Params<br>                                               &#123;Certificate*&#125;  ^<br>                                         &#123;CertificateVerify*&#125;  | Auth<br>                                                   &#123;Finished&#125;  v<br>                               &lt;--------  [Application Data*]<br>     ^ &#123;Certificate*&#125;<br>Auth | &#123;CertificateVerify*&#125;<br>     v &#123;Finished&#125;              --------&gt;<br>       [Application Data]      &lt;-------&gt;  [Application Data]<br><br></code></pre></td></tr></table></figure><p>+ 表示的是在以前标注的消息中发送的值得注意的扩展<br>* 表示可选的或者依赖一定条件的消息/扩展，它们不总是发送<br>() 表示消息由从 Client_early_traffic_secret 导出的密钥保护<br>{} 表示消息使用从一个 [sender]_handshake_traffic_secret 导出的密钥保护<br>[] 表示消息使用从 [sender]_application_traffic_secret_N 导出的密钥保护</p><p>握手可以被认为有三个阶段（见上图）：</p><ul><li>密钥交换：建立共享密钥数据并选择密码参数。在这个阶段之后所有的数据都会被加密。</li><li>Server 参数：建立其它的握手参数（Client 是否被认证，应用层协议支持等）。</li><li>认证：认证 Server（并且选择性认证 Client），提供密钥确认和握手完整性。</li></ul><p>在密钥交换阶段，Client 会发送 ClientHello 消息，其中包含了一个随机 nonce(ClientHello.random)；它提供了协议版本，一个对称密码/HKDF hash 对的列表；一个 Diffie-Hellman 密钥共享集合或一个预共享密钥标签（在 “key_share” 扩展中）集合，或二者都有；和可能的其它扩展。</p><p>Server 处理 ClientHello 并为连接确定合适的密码参数。然后它会以自己的 ServerHello 作为响应，其中表明了协商好的连接参数。ClientHello 和 ServerHello 合在一起来确定共享密钥。如果已经建立的 (EC)DHE 密钥正在被使用，则 ServerHello 中会包含一个 ”key_share” 扩展，和这个扩展一起的还有 Server 的临时 Diffie-Hellman 共享参数，这个共享参数必须与 Client 的一个共享参数在相同的组里。如果使用的是 PSK 密钥，则 ServerHello 中会包含一个 “pre_shared_key” 扩展以表明 Client 提供的哪一个 PSK 被选中。需要注意的是实现上可以将 (EC)DHE 和 PSK 一起使用，这种情况下两种扩展都需要提供。</p><p>随后 Server 会发送两个消息来建立 Server 参数：</p><ul><li>EncryptedExtensions: 对 ClientHello 扩展的响应，不需要确定加密参数，而不是特定于各个证书的加密参数。</li><li>CertificateRequest: 如果需要基于证书的客户端身份验证，则所需参数是证书。 如果不需要客户端认证，则省略此消息。</li></ul><p>最后，Client 和 Server 交换认证消息。TLS 在每次基于证书的认证时使用相同的消息集，(基于 PSK 的认证是密钥交换中的一个副作用)特别是：</p><ul><li><p>Certificate: 终端的证书和每个证书的扩展。 服务器如果不通过证书进行身份验证，并且如果服务器没有发送CertificateRequest（由此指示客户端不应该使用证书进行身份验证），客户端将忽略此消息。 请注意，如果使用原始公钥 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7250">[RFC7250]</a> 或缓存信息扩展 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7924">[RFC7924]</a>，则此消息将不包含证书，而是包含与服务器长期密钥相对应的其他值。</p></li><li><p>CertificateVerify: 使用与证书消息中的公钥配对的私钥对整个握手消息进行签名。如果终端没有使用证书进行验证则此消息会被忽略。</p></li><li><p>Finished: 对整个握手消息的 MAC(消息认证码)。这个消息提供了密钥确认，将终端身份与交换的密钥绑定在一起，这样在 PSK 模式下也能认证握手。</p></li></ul><p>接收到 Server 的消息之后，Client 会响应它的认证消息，即 Certificate，CertificateVerify (如果需要), 和 Finished。</p><p>这时握手已经完成，client 和 server 会提取出密钥用于记录层交换应用层数据，这些数据需要通过认证的加密来保护。应用层数据不能在 Finished 消息之前发送数据，必须等到记录层开始使用加密密钥之后才可以发送。需要注意的是 server 可以在收到 client 的认证消息之前发送应用数据，任何在这个时间点发送的数据，当然都是在发送给一个未被认证的对端。</p><h3 id="1-错误的-dhe-共享"><a class="markdownIt-Anchor" href="#1-错误的-dhe-共享"></a> 1. 错误的 DHE 共享</h3><p>如果 client 没有提供一个充分的 ”key_share” 扩展（例如，它只包含 server 不接受或不支持的 DHE 或 ECDHE 组），server 会使用一个 HelloRetryRequest 来纠正这个不匹配问题，client 需要使用一个合适的 ”key_share” 扩展来重启握手，如下图所示。如果没有通用的密码参数能够协商，server 必须发出一个适当的警报来中止握手。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">Client                                               Server<br><br>ClientHello<br>+ key_share             --------&gt;<br>                                          HelloRetryRequest<br>                        &lt;--------               + key_share<br>ClientHello<br>+ key_share             --------&gt;<br>                                                ServerHello<br>                                                + key_share<br>                                      &#123;EncryptedExtensions&#125;<br>                                      &#123;CertificateRequest*&#125;<br>                                             &#123;Certificate*&#125;<br>                                       &#123;CertificateVerify*&#125;<br>                                                 &#123;Finished&#125;<br>                        &lt;--------       [Application Data*]<br>&#123;Certificate*&#125;<br>&#123;CertificateVerify*&#125;<br>&#123;Finished&#125;              --------&gt;<br>[Application Data]      &lt;-------&gt;        [Application Data]<br><br></code></pre></td></tr></table></figure><p>如上图，一个带有不匹配参数的完整握手过程的消息流程</p><blockquote><p>注意，这个握手过程包含初始的 ClientHello/HelloRetryRequest 交换；它不能被新的 ClientHello 重置。</p></blockquote><p>TLS还允许基本握手的几种优化变体，如以下部分所述。</p><h3 id="2-复用和预共享密钥pre-shared-keypsk"><a class="markdownIt-Anchor" href="#2-复用和预共享密钥pre-shared-keypsk"></a> 2. 复用和预共享密钥（Pre-Shared Key，PSK）</h3><p>虽然 TLS 预共享密钥（PSK）能够在带外建立，预共享密钥也能在一个之前的连接中建立然后重用（会话恢复）。一旦一次握手完成，server 就能给 client 发送一个与一个独特密钥对应的 PSK 密钥，这个密钥来自初次握手。然后 client 能够使用这个 PSK 密钥在将来的握手中协商相关 PSK 的使用。如果 server 接受它，新连接的安全上下文在密码学上就与初始连接关联在一起，从初次握手中得到的密钥就会用于装载密码状态来替代完整的握手。在 TLS 1.2 以及更低的版本中，这个功能由 “session IDs” 和 “session tickets” <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5077">[RFC5077]</a>来提供。这两个机制在 TLS 1.3 中都被废除了。</p><p>PSK 可以与 (EC)DHE 密钥交换算法一同使用以便使共享密钥具备前向安全，或者 PSK 可以被单独使用，这样是以丢失了应用数据的前向安全为代价。</p><p>下图显示了两次握手，第一次建立了一个 PSK，第二次时使用它：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c">       Client                                               Server<br><br>Initial Handshake:<br>       ClientHello<br>       + key_share               --------&gt;<br>                                                       ServerHello<br>                                                       + key_share<br>                                             &#123;EncryptedExtensions&#125;<br>                                             &#123;CertificateRequest*&#125;<br>                                                    &#123;Certificate*&#125;<br>                                              &#123;CertificateVerify*&#125;<br>                                                        &#123;Finished&#125;<br>                                 &lt;--------     [Application Data*]<br>       &#123;Certificate*&#125;<br>       &#123;CertificateVerify*&#125;<br>       &#123;Finished&#125;                --------&gt;<br>                                 &lt;--------      [NewSessionTicket]<br>       [Application Data]        &lt;-------&gt;      [Application Data]<br><br><br>Subsequent Handshake:<br>       ClientHello<br>       + key_share*<br>       + pre_shared_key          --------&gt;<br>                                                       ServerHello<br>                                                  + pre_shared_key<br>                                                      + key_share*<br>                                             &#123;EncryptedExtensions&#125;<br>                                                        &#123;Finished&#125;<br>                                 &lt;--------     [Application Data*]<br>       &#123;Finished&#125;                --------&gt;<br>       [Application Data]        &lt;-------&gt;      [Application Data]<br><br></code></pre></td></tr></table></figure><p>当 server 通过一个 PSK 进行认证时，它不会发送一个 Certificate 或一个 CertificateVerify 消息。当一个 client 通过 PSK 想恢复会话的时候，它也应当提供一个 “key_share” 给 server，以允许 server 拒绝恢复会话的时候降级到重新回答一个完整的握手流程中。Server 响应 “pre_shared_key” 扩展，使用 PSK 密钥协商建立连接，同时响应 “key_share” 扩展来进行 (EC)DHE 密钥建立，由此提供前向安全。</p><p>当 PKS 在带外提供时，PSK 密钥和与 PSK 一起使用的 KDF hash 算法也必须被提供。</p><blockquote><p>注意：当使用一个带外提供的预共享密钥时，一个关键的考虑是在密钥生成时使用足够的熵，就像 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc4086">[RFC4086]</a> 中讨论的那样。从一个口令或其它低熵源导出的一个共享密钥并不安全。一个低熵密码，或口令，易遭受基于 PSK 绑定器的字典攻击。指定的 PSK 密钥并不是一个基于强口令的已认证的密钥交换，即使使用了 Diffie-Hellman 密钥建立方法。具体来说，它不会阻止可以观察到握手过程的攻击者对密码/预共享密钥进行暴力攻击。</p></blockquote><h3 id="3-0-rtt-数据"><a class="markdownIt-Anchor" href="#3-0-rtt-数据"></a> 3. 0-RTT 数据</h3><p>当 client 和 server 共享一个 PSK（从外部获得或通过一个以前的握手获得）时，TLS 1.3 允许 client 在第一个发送出去的消息中携带数据（“early data”）。Client 使用这个 PSK 来认证 server 并加密 early data。</p><p>如下图所示，0-RTT 数据在第一个发送的消息中被加入到 1-RTT 握手过程中。握手的其余消息与带 PSK 会话恢复的 1-RTT 握手消息相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">Client                                               Server<br><br>ClientHello<br>+ early_data<br>+ key_share*<br>+ psk_key_exchange_modes<br>+ pre_shared_key<br>(Application Data*)     --------&gt;<br>                                                ServerHello<br>                                           + pre_shared_key<br>                                               + key_share*<br>                                      &#123;EncryptedExtensions&#125;<br>                                              + early_data*<br>                                                 &#123;Finished&#125;<br>                        &lt;--------       [Application Data*]<br>(EndOfEarlyData)<br>&#123;Finished&#125;              --------&gt;<br>[Application Data]      &lt;-------&gt;        [Application Data]<br></code></pre></td></tr></table></figure><p>上图是 0-RTT 的信息流</p><p>+ 标明是在以前标注的消息中发送的值得注意的扩展<br>* 表示可选的或者依赖一定条件的消息/扩展，它们不总是发送<br>() 表示消息由从client_early_traffic_secret导出的密钥保护<br>{} 表示消息使用从一个[sender]_handshake_traffic_secret导出的密钥保护<br>[]表示消息使用从[sender]_application_traffic_secret_N导出的密钥保护</p><p>0-RTT 数组安全性比其他类型的 TLS 数据要弱一些，特别是：</p><ol><li>0-RTT 的数据是没有前向安全性的，它使用的是被提供的 PSK 中导出的密钥进行加密的。</li><li>在多个连接之间不能保证不存在重放攻击。普通的 TLS 1.3 1-RTT 数据为了防止重放攻击的保护方法是使用 server 下发的随机数，现在 0-RTT 不依赖于 ServerHello 消息，因此保护措施更差。如果数据与 TLS client 认证或与应用协议里一起验证，这一点安全性的考虑尤其重要。这个警告适用于任何使用 early_exporter_master_secret 的情况。</li></ol><p>0-RTT 数据不能在连接中被复制（即 server 不会为同一连接处理相同的数据两次），并且攻击者将无法使 0-RTT 数据伪装起来像 1-RTT数据（因为它受不同的密钥保护）。</p><p>关于 0-RTT 的安全性，会单独有一篇文章来讨论。</p><hr><h1 id="握手协议"><a class="markdownIt-Anchor" href="#握手协议"></a> 握手协议</h1><p>握手协议用于协商连接的安全参数。握手消息被提供给 TLS 记录层，在记录层它们被封装到一个或多个 TLSPlaintext 或 TLSCiphertext 中，它们按照当前活动连接状态进行处理和传输。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    client_hello(<span class="hljs-number">1</span>),<br>    server_hello(<span class="hljs-number">2</span>),<br>    new_session_ticket(<span class="hljs-number">4</span>),<br>    end_of_early_data(<span class="hljs-number">5</span>),<br>    encrypted_extensions(<span class="hljs-number">8</span>),<br>    certificate(<span class="hljs-number">11</span>),<br>    certificate_request(<span class="hljs-number">13</span>),<br>    certificate_verify(<span class="hljs-number">15</span>),<br>    finished(<span class="hljs-number">20</span>),<br>    key_update(<span class="hljs-number">24</span>),<br>    message_hash(<span class="hljs-number">254</span>),<br>    (<span class="hljs-number">255</span>)<br>&#125; HandshakeType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    HandshakeType msg_type;    <span class="hljs-comment">/* handshake type */</span><br>    uint24 length;             <span class="hljs-comment">/* remaining bytes in message */</span><br>    select (Handshake.msg_type) &#123;<br>        <span class="hljs-keyword">case</span> client_hello:          ClientHello;<br>        <span class="hljs-keyword">case</span> server_hello:          ServerHello;<br>        <span class="hljs-keyword">case</span> end_of_early_data:     EndOfEarlyData;<br>        <span class="hljs-keyword">case</span> encrypted_extensions:  EncryptedExtensions;<br>        <span class="hljs-keyword">case</span> certificate_request:   CertificateRequest;<br>        <span class="hljs-keyword">case</span> certificate:           Certificate;<br>        <span class="hljs-keyword">case</span> certificate_verify:    CertificateVerify;<br>        <span class="hljs-keyword">case</span> finished:              Finished;<br>        <span class="hljs-keyword">case</span> new_session_ticket:    NewSessionTicket;<br>        <span class="hljs-keyword">case</span> key_update:            KeyUpdate;<br>    &#125;;<br>&#125; Handshake;<br></code></pre></td></tr></table></figure><p>协议消息必须按照一定顺序发送(顺序见下文)。如果对端发现收到的握手消息顺序不对，必须使用 “unexpected_message” alert 消息来中止握手。</p><p>另外 IANA 分配了新的握手消息类型，见<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8446#section-11">第 11 章</a></p><h2 id="一-key-exchange-messages"><a class="markdownIt-Anchor" href="#一-key-exchange-messages"></a> 一. Key Exchange Messages</h2><p>密钥交换消息用于确保 Client 和 Server 的安全性和建立用于保护握手和数据的通信密钥的安全性。</p><h3 id="1-cryptographic-negotiation"><a class="markdownIt-Anchor" href="#1-cryptographic-negotiation"></a> 1. Cryptographic Negotiation</h3><p>在 TLS 协议中，密钥协商的过程中，Client 在 ClientHello 中可以提供以下 4 种 options。</p><ul><li>Client 支持的加密套件列表。密码套件里面中能体现出 Client 支持的 AEAD 算法或者 HKDF 哈希对。</li><li>“supported_groups” 的扩展 和 “key_share” 扩展。“supported_groups” 这个扩展表明了 Client 支持的 (EC)DHE groups，“key_share” 扩展表明了 Client 是否包含了一些或者全部的（EC）DHE共享。</li><li>“signature_algorithms” 签名算法和 “signature_algorithms_cert” 签名证书算法的扩展。“signature_algorithms” 这个扩展展示了 Client 可以支持了签名算法有哪些。“signature_algorithms_cert” 这个扩展展示了具体证书的签名算法。</li><li>“pre_shared_key” 预共享密钥和 “psk_key_exchange_modes” 扩展。预共享密钥扩展包含了 Client 可以识别的对称密钥标识。“psk_key_exchange_modes” 扩展表明了可能可以和 psk 一起使用的密钥交换模式。</li></ul><p>如果 Server 不选择 PSK，那么上面 4 个 option 中的前 3 个是正交的， Server 独立的选择一个加密套件，独立的选择一个 (EC)DHE 组，独立的选择一个用于建立连接的密钥共享，独立的选择一个签名算法/证书对用于给 Client 验证 Server 。如果 Server 收到的 “supported_groups” 中没有 Server 能支持的算法，那么就必须返回 “handshake_failure” 或者 “insufficient_security” 的 alert 消息。</p><p>如果 Server 选择了 PSK，它必须从 Client 的 “psk_key_exchange_modes” 扩展消息中选择一个密钥建立模式。这个时候 PSK 和 (EC)DHE 是分开的。在 PSK 和 (EC)DHE 分开的基础上，即使，“supported_groups” 中不存在 Server 和 Client 相同的算法，也不会终止握手。</p><p>如果 Server 选择了 (EC)DHE 组，并且 Client 在 ClientHello 中没有提供合适的 “key_share” 扩展， Server 必须用 HelloRetryRequest 消息作为回应。</p><p>如果 Server 成功的选择了参数，也就不需要 HelloRetryRequest 消息了。 Server 将发送 ServerHello 消息，它包含以下几个参数：</p><ul><li>如果正在使用 PSK， Server 将发送 “pre_shared_key” 扩展，里面包含了选择的密钥。</li><li>如果没有使用 PSK，选择的 (EC)DHE， Server 将会提供一个 “key_share” 扩展。通常，如果 PSK 没有使用，就会使用 (EC)DHE 和基于证书的认证。</li><li>当通过证书进行认证的时候， Server 会发送 Certificate 和 CertificateVerify 消息。在 TLS 1.3 的官方规定中，PSK 和 证书通常被用到，但是不是一起使用，未来的文档可能会定义如何同时使用它们。</li></ul><p>如果 Server 不能协商出可支持的参数集合，即在 Client 和 Server 各自支持的参数集合中没有重叠，那么 Server 必须发送 “handshake_failure” 或者 “insufficient_security” 消息来中止握手。</p><h3 id="2-client-hello"><a class="markdownIt-Anchor" href="#2-client-hello"></a> 2. Client Hello</h3><p>当一个 Client 第一次连接一个 Server 时，它需要在发送第一条 TLS 消息的时候，发送 ClientHello 消息。当 Server 发送 HelloRetryRequest 消息的时候，Client 收到了以后也需要回应一条 ClientHello 消息。在这种情况下，Client 必须发送相同的无修改的 ClientHello 消息，除非以下几种情况：</p><ul><li>如果 HelloRetryRequest 消息中包含了 “key_share” 扩展，则将共享列表用包含了单个来自表明的组中的 KeyShareEntry 代替。</li><li>如果存在 “early_data” 扩展则将其移除。 “early_data” 不允许出现在 HelloRetryRequest 之后。</li><li>如果 HelloRetryRequest 中包含了 cookie 扩展，则需要包含一个。</li><li>如果重新计算了 “obfuscated_ticket_age” 和绑定值，同时(可选地)删除了任何不兼容 Server 展示的密码族的 PSK，则更新 “pre_shared_key” 扩展。</li><li>选择性地增加，删除或更改 ”padding” 扩展<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7685">RFC 7685</a>的长度。</li><li>可能被允许的一些其他的修改。例如未来指定的一些扩展定义和 HelloRetryRequest 。</li></ul><p>由于 TLS 1.3 <strong>严禁重协商</strong>，如果 Server 已经完成了 TLS 1.3 的协商了，在未来某一时刻又收到了 ClientHello ，Server 不应该理会这条消息，必须立即断开连接，并发送 “unexpected_message” alert 消息。</p><p>如果一个 Server 建立了一个 TLS 以前版本的 TLS 连接，并在重协商的时候收到了 TLS 1.3 的 ClientHello ，这个时候，Server 必须继续保持之前的版本，严禁协商 TLS 1.3 。</p><p>ClientHello 消息的结构是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">uint16 ProtocolVersion;<br>opaque Random[<span class="hljs-number">32</span>];<br><br>uint8 CipherSuite[<span class="hljs-number">2</span>];    <span class="hljs-comment">/* Cryptographic suite selector */</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ProtocolVersion legacy_version = <span class="hljs-number">0x0303</span>;    <span class="hljs-comment">/* TLS v1.2 */</span><br>    Random random;<br>    opaque legacy_session_id&lt;<span class="hljs-number">0.</span><span class="hljs-number">.32</span>&gt;;<br>    CipherSuite cipher_suites&lt;<span class="hljs-number">2.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-2</span>&gt;;<br>    opaque legacy_compression_methods&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">8</span><span class="hljs-number">-1</span>&gt;;<br>    Extension extensions&lt;<span class="hljs-number">8.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>&#125; ClientHello;<br></code></pre></td></tr></table></figure><p>关于结构体的一些说明：</p><ul><li><p>legacy_version:<br>在 TLS 以前的版本里，这个字段被用来版本协商和表示 Client 所能支持的 TLS 最高版本号。经验表明，<strong>很多 Server 并没有正确的实现版本协商</strong>，导致了 “version intolerance” —— Sever 拒绝了一些本来可以支持的 ClientHello 消息，只因为这些消息的版本号高于 Server 能支持的版本号。在 TLS 1.3 中，Client 在 “supported_versions” 扩展中表明了它的版本。并且legacy_version 字段必须设置成 0x0303，这是 TLS 1.2 的版本号。在 TLS 1.3 中的 ClientHello 消息中的 legacy_version 都设置成 0x0303，supported_versions 扩展设置成 0x0304。更加详细的信息见附录 D。</p></li><li><p>random:<br>由一个安全随机数生成器产生的32字节随机数。额外信息见附录 C。</p></li><li><p>legacy_session_id:<br>TLS 1.3 版本之前的版本支持会话恢复的特性。在 TLS 1.3 的这个版本中，这一特性已经和预共享密钥 PSK 合并了。如果 Client 有 TLS 1.3 版本之前的 Server 设置的缓存 Session ID，那么这个字段要填上这个 ID 值。在兼容模式下，这个值必须是非空的，所以一个 Client 要是不能提供 TLS 1.3 版本之前的 Session 的话，就必须生成一个新的 32 字节的值。这个值不要求是随机值，但必须是一个不可预测的值，防止实现上固定成了一个固定的值了。否则，这个字段必须被设置成一个长度为 0 的向量。（例如，一个0字节长度域）</p></li><li><p>cipher_suites:<br>这个列表是 Client 所支持对称加密选项的列表，特别是记录保护算法(包括密钥长度) 和 HKDF 一起使用的 hash 算法。以 Client 的偏好降序排列。如果列表包含的密码套件是 Server 不能识别的或者是不能支持的，或者是希望使用的，Server 必须忽略这些密码套件，照常处理剩下来的密码套件。如果 Client 尝试建立 PSK 密钥，则它应该至少包含一个与 PSK 相关的哈希加密套件。</p></li><li><p>legacy_compression_methods:<br>TLS 1.3 之前的 TLS 版本支持压缩，在这个字段中发送支持的压缩方法列表。对于每个 ClientHello，该向量必须包含一个设置为 0 的一个字节，它对应着 TLS 之前版本中的 null 压缩方法。如果 TLS 1.3 中的 ClientHello 中这个字段包含有值，Server 必须立即发送 “illegal_parameter” alert 消息中止握手。注意，TLS 1.3 Server 可能接收到 TLS 1.2 或者之前更老版本的 ClientHellos，其中包含了其他压缩方法。如果正在协商这些之前的版本，那么必须遵循 TLS 之前版本的规定。</p></li><li><p>extensions:<br>Client 通过在扩展字段中发送数据，向 Server 请求扩展功能。“Extension” 遵循格式定义。在 TLS 1.3 中，使用确定的扩展项是强制的。因为功能被移动到了扩展中以保持和之前 TLS 版本的 ClientHello 消息的兼容性。Server 必须忽略不能识别的 extensions。</p></li></ul><p>所有版本的 TLS 都允许可选的带上 compression_methods 这个扩展字段。TLS 1.3 ClientHello 消息通常包含扩展消息(至少包含 “supported_versions”，否则这条消息会被解读成 TLS 1.2 的 ClientHello 消息)然而，TLS 1.3 Server 也有可能收到之前 TLS 版本发来的不带扩展字段的 ClientHello 消息。扩展是否存在，可以通过检测 ClientHello 结尾的 compression_methods 字段内是否有字节来确定。请注意，这种检测可选数据的方法与具有可变长度字段的普通 TLS 方法不同，但是在扩展被定义之前，这种方法可以用来做兼容。TLS 1.3 Server 需要首先执行此项检查，并且仅当存在 “supported_versions” 扩展时才尝试协商 TLS 1.3。如果协商的是 TLS 1.3 之前的版本，Server 必须做 2 项检查：legacy_compression_methods 字段后面是否还有数据；有效的 extensions block 后没有数据跟随。如果上面这 2 项检查都不通过，需要立即发送 “decode_error” alert 消息中止握手。</p><p>如果 Client 通过扩展请求额外功能，但是这个功能 Server 并不提供，则 Client 可以中止握手。</p><p>发送 ClientHello 消息后，Client 等待 ServerHello 或者 HelloRetryRequest 消息。如果 early data 在使用中，Client 在等待下一条握手消息期间，可以先发送 early Application Data。</p><h3 id="3-server-hello"><a class="markdownIt-Anchor" href="#3-server-hello"></a> 3. Server Hello</h3><p>如果 Server 和 Client 可以在 ClientHello 消息中协商出一套双方都可以接受的握手参数的话，那么 Server 会发送 Server Hello 消息回应 ClientHello 消息。</p><p>消息的结构体是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ProtocolVersion legacy_version = <span class="hljs-number">0x0303</span>;    <span class="hljs-comment">/* TLS v1.2 */</span><br>    Random random;<br>    opaque legacy_session_id_echo&lt;<span class="hljs-number">0.</span><span class="hljs-number">.32</span>&gt;;<br>    CipherSuite cipher_suite;<br>    uint8 legacy_compression_method = <span class="hljs-number">0</span>;<br>    Extension extensions&lt;<span class="hljs-number">6.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>&#125; ServerHello;<br></code></pre></td></tr></table></figure><ul><li><p>legacy_version:<br>在 TLS 1.3 之前的版本，这个字段被用来版本协商和标识建立连接时候双方选择的版本号。不幸的是，一些中间件在给这个字段赋予新值的时候可能会失败。在 TLS 1.3 中，Server 用 “supported_versions” 扩展字段来标识它支持的版本，legacy_version 字段必须设置为 0x0303(这个值代表的 TLS 1.2)。（有关向后兼容性的详细信息，请参阅附录D.）</p></li><li><p>random:<br>由安全随机数生成器生成的随机 32 字节。如果协商的是 TLS 1.1 或者 TLS 1.2 ，那么最后 8 字节必须被重写，其余的 24 字节必须是随机的。这个结构由 Server 生成并且必须独立于 ClientHello.random。</p></li><li><p>legacy_session_id_echo:<br>Client 的 legacy_session_id 字段的内容。请注意，即使 Server 决定不再恢复 TLS 1.3 之前的会话，Client 的 legacy_session_id 字段缓存的是 TLS 1.3 之前的值，这个时候 legacy_session_id_echo 字段也会被 echoed。Client 收到的 legacy_session_id_echo 值和它在 ClientHello 中发送的值不匹配的时候，必须立即用 “illegal_parameter” alert 消息中止握手。</p></li><li><p>cipher_suite:<br>Server 从 ClientHello 中的 cipher_suites 列表中选择的一个加密套件。Client 如果接收到并没有提供的密码套件，此时应该立即用 “illegal_parameter” alert 消息中止握手。</p></li><li><p>legacy_compression_method:<br>必须有 0 值的单一字节。</p></li><li><p>extensions:<br>扩展列表。ServerHello 中必须仅仅只能包括建立加密上下文和协商协议版本所需的扩展。<strong>所有 TLS 1.3 的 ServerHello 消息必须包含 “supported_versions” 扩展</strong>。当前的 ServerHello 消息还另外包含 “pre_shared_key” 扩展或者 “key_share” 扩展，或者两个扩展都有(当使用 PSK 和 (EC)DHE 建立连接的时候)。其他的扩展会在 EncryptedExtensions 消息中分别发送。</p></li></ul><p>出于向后兼容中间件的原因，HelloRetryRequest 消息和 ServerHello 消息采用相同的结构体，但需要随机设置 HelloRetryRequest 的 SHA-256 特定值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">CF <span class="hljs-number">21</span> AD <span class="hljs-number">74</span> E5 <span class="hljs-number">9</span>A <span class="hljs-number">61</span> <span class="hljs-number">11</span> BE <span class="hljs-number">1</span>D <span class="hljs-number">8</span>C <span class="hljs-number">02</span> <span class="hljs-number">1</span>E <span class="hljs-number">65</span> B8 <span class="hljs-number">91</span><br>C2 A2 <span class="hljs-number">11</span> <span class="hljs-number">16</span> <span class="hljs-number">7</span>A BB <span class="hljs-number">8</span>C <span class="hljs-number">5</span>E <span class="hljs-number">07</span> <span class="hljs-number">9</span>E <span class="hljs-number">09</span> E2 C8 A8 <span class="hljs-number">33</span> <span class="hljs-number">9</span>C<br></code></pre></td></tr></table></figure><p>当收到 server_hello 消息以后，实现必须首先检查这个随机值是不是和上面这个值匹配。如果和上面这个值是一致的，再继续处理。</p><p>TLS 1.3 具有降级保护机制，这种机制是通过嵌入在 Server 的随机值实现的。TLS 1.3 Server 协商 TLS 1.2 或者更老的版本，为了响应 ClientHello ，ServerHello 消息中必须在最后 8 个字节中填入特定的随机值。</p><p>如果协商的 TLS 1.2 ，TLS 1.3 Server 必须把 ServerHello 中的 Random 字段的最后 8 字节设置为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">44</span> <span class="hljs-number">4F</span> <span class="hljs-number">57</span> <span class="hljs-number">4</span>E <span class="hljs-number">47</span> <span class="hljs-number">52</span> <span class="hljs-number">44</span> <span class="hljs-number">01</span><br>D  O  W  N  G  R  D<br></code></pre></td></tr></table></figure><p>如果协商的 TLS 1.1 或者更老的版本，TLS 1.3 Server 和 TLS 1.2 Server 必须把 ServerHello 中的 Random 字段的最后 8 字节的值改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">44</span> <span class="hljs-number">4F</span> <span class="hljs-number">57</span> <span class="hljs-number">4</span>E <span class="hljs-number">47</span> <span class="hljs-number">52</span> <span class="hljs-number">44</span> <span class="hljs-number">00</span><br>D  O  W  N  G  R  D<br></code></pre></td></tr></table></figure><p>TLS 1.3 Client 接收到 TLS 1.2 或者 TLS 更老的版本的 ServerHello 消息以后，必须要检查 ServerHello 中的 Random 字段的最后 8 字节不等于上面 2 个值才对。TLS 1.2 的 Client 也需要检查最后 8 个字节，如果协商的是 TLS 1.1 或者是更老的版本，那么 Random 值也不应该等于上面第二个值。如果都没有匹配上，那么 Client 必须用 “illegal_parameter” alert 消息中止握手。这种机制提供了有限的保护措施，抵御降级攻击。通过 Finished exchange ，能超越保护机制的保护范围：因为在 TLS 1.2 或更低的版本上，ServerKeyExchange 消息包含 2 个随机值的签名。只要使用了临时的加密方式，攻击者就不可能在不被发现的情况下，修改随机值。所以对于静态的 RSA，是无法提供降级攻击的保护。</p><blockquote><p>请注意，上面这些改动在 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5246">RFC5246</a> 中说明的，实际上许多 TLS 1.2 的 Client 和 Server 都没有按照上面的规定来实践。</p></blockquote><p>如果 Client 在重新协商 TLS 1.2 或者更老的版本的时候，协商过程中收到了 TLS 1.3 的 ServerHello，这个时候 Client 必须立即发送 “protocol_version” alert 中止握手。请注意，<strong>一旦 TLS 1.3 协商完成，就无法再重新协商了，因为 TLS 1.3 严禁重新协商</strong>。</p><h3 id="4-hello-retry-request"><a class="markdownIt-Anchor" href="#4-hello-retry-request"></a> 4. Hello Retry Request</h3><p>如果在 Client 发来的 ClientHello 消息中能够找到一组可以相互支持的参数，但是 Client 又不能为接下来的握手提供足够的信息，这个时候 Server 就需要发送 HelloRetryRequest 消息来响应 ClientHello 消息。在上一节中，谈到 HelloRetryRequest 和 ServerHello 消息是有相同的数据结构，legacy_version, legacy_session_id_echo, cipher_suite, legacy_compression_method 这些字段的含义也是一样的。为了讨论的方便，下文中，我们讨论 HelloRetryRequest 消息都当做不同的消息来对待。</p><p>Server 的扩展集中必须包含 “supported_versions”。另外，它还需要包含最小的扩展集，能让 Client 生成正确的 ClientHello 对。相比 ServerHello 而言，HelloRetryRequest 只能包含任何在第一次 ClientHello 中出现过的扩展，除了可选的 “cookie” 以外。</p><p>Client 接收到 HelloRetryRequest 消息以后，必须要先校验 legacy_version, legacy_session_id_echo, cipher_suite, legacy_compression_method 这四个参数。先从 “supported_versions” 开始决定和 Server 建立连接的版本，然后再处理扩展。如果 HelloRetryRequest 不会导致 ClientHello 的任何更改，Client 必须用 “illegal_parameter” alert 消息中止握手。如果 Client 在一个连接中收到了第 2 个 HelloRetryRequest 消息( ClientHello 本身就是响应 HelloRetryRequest 的)，那么必须用 “unexpected_message” alert 消息中止握手。</p><p>否则，Client 必须处理 HelloRetryRequest 中所有的扩展，并且发送第二个更新的 ClientHello。在本规范中定义的 HelloRetryRequest 扩展名是：</p><ul><li>supported_versions</li><li>cookie</li><li>key_share</li></ul><p>Client 在接收到自己并没有提供的密码套件的时候必须立即中止握手。Server 必须确保在接收到合法并且更新过的 ClientHello 时，它们在协商相同的密码套件(如果 Server 把选择密码套件作为协商的第一步，那么这一步会自动发送)。Client 收到 ServerHello 后必须检查 ServerHello 中提供的密码套件是否与 HelloRetryRequest 中的密码套件相同，否则将以 “illegal_parameter” alert 消息中止握手。</p><p>此外，Client 在其更新的 ClientHello 中，Client 不能提供任何与所选密码套件以外的预共享密钥(与哈希相关联的)。这允许 Client 避免在第二个 ClientHello 中计算多个散列的部分哈希转录。</p><p>在 HelloRetryRequest 的 “support_versions” 扩展中的 selected_version 字段的值必须被保留在 ServerHello 中，如果这个值变了，Client 必须用 “illegal_parameter” alert 消息中止握手。</p><h2 id="二-extensions"><a class="markdownIt-Anchor" href="#二-extensions"></a> 二. Extensions</h2><p>许多 TLS 的消息都包含 tag-length-value 编码的扩展数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ExtensionType extension_type;<br>    opaque extension_data&lt;<span class="hljs-number">0.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>&#125; Extension;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    server_name(<span class="hljs-number">0</span>),                             <span class="hljs-comment">/* RFC 6066 */</span><br>    max_fragment_length(<span class="hljs-number">1</span>),                     <span class="hljs-comment">/* RFC 6066 */</span><br>    status_request(<span class="hljs-number">5</span>),                          <span class="hljs-comment">/* RFC 6066 */</span><br>    supported_groups(<span class="hljs-number">10</span>),                       <span class="hljs-comment">/* RFC 8422, 7919 */</span><br>    signature_algorithms(<span class="hljs-number">13</span>),                   <span class="hljs-comment">/* RFC 8446 */</span><br>    use_srtp(<span class="hljs-number">14</span>),                               <span class="hljs-comment">/* RFC 5764 */</span><br>    heartbeat(<span class="hljs-number">15</span>),                              <span class="hljs-comment">/* RFC 6520 */</span><br>    application_layer_protocol_negotiation(<span class="hljs-number">16</span>), <span class="hljs-comment">/* RFC 7301 */</span><br>    signed_certificate_timestamp(<span class="hljs-number">18</span>),           <span class="hljs-comment">/* RFC 6962 */</span><br>    client_certificate_type(<span class="hljs-number">19</span>),                <span class="hljs-comment">/* RFC 7250 */</span><br>    server_certificate_type(<span class="hljs-number">20</span>),                <span class="hljs-comment">/* RFC 7250 */</span><br>    padding(<span class="hljs-number">21</span>),                                <span class="hljs-comment">/* RFC 7685 */</span><br>    pre_shared_key(<span class="hljs-number">41</span>),                         <span class="hljs-comment">/* RFC 8446 */</span><br>    early_data(<span class="hljs-number">42</span>),                             <span class="hljs-comment">/* RFC 8446 */</span><br>    supported_versions(<span class="hljs-number">43</span>),                     <span class="hljs-comment">/* RFC 8446 */</span><br>    cookie(<span class="hljs-number">44</span>),                                 <span class="hljs-comment">/* RFC 8446 */</span><br>    psk_key_exchange_modes(<span class="hljs-number">45</span>),                 <span class="hljs-comment">/* RFC 8446 */</span><br>    certificate_authorities(<span class="hljs-number">47</span>),                <span class="hljs-comment">/* RFC 8446 */</span><br>    oid_filters(<span class="hljs-number">48</span>),                            <span class="hljs-comment">/* RFC 8446 */</span><br>    post_handshake_auth(<span class="hljs-number">49</span>),                    <span class="hljs-comment">/* RFC 8446 */</span><br>    signature_algorithms_cert(<span class="hljs-number">50</span>),              <span class="hljs-comment">/* RFC 8446 */</span><br>    key_share(<span class="hljs-number">51</span>),                              <span class="hljs-comment">/* RFC 8446 */</span><br>    (<span class="hljs-number">65535</span>)<br>&#125; ExtensionType;<br></code></pre></td></tr></table></figure><p>这里：</p><ul><li>“extension_type” 标识特定的扩展状态。</li><li>“extension_data” 包含特定于该特定扩展类型的信息。</li></ul><p>所有的扩展类型由 IANA 维护，具体的见附录。</p><p>扩展通常以请求/响应方式构建，虽然有些扩展只是一些标识，并不会有任何响应。Client 在 ClientHello 中发送其扩展请求，Server 在 ServerHello, EncryptedExtensions, HelloRetryRequest,和 Certificate 消息中发送对应的扩展响应。Server 在 CertificateRequest 消息中发送扩展请求，Client 可能回应 Certificate 消息。Server 也有可能不请自来的在 NewSessionTicket 消息中直接发送扩展请求，Client 可以不用直接响应这条消息。</p><p>如果远端没有发送相应的扩展请求，除了 HelloRetryRequest 消息中的 “cookie” 扩展以外，实现方不得发送扩展响应。在接收到这样的扩展以后，端点必须用 “unsupported_extension” alert 消息中止握手。</p><p>下表给出了可能出现的消息的扩展名，使用以下表示法：CH (ClientHello), SH (ServerHello), EE (EncryptedExtensions), CT (Certificate), CR (CertificateRequest), NST (NewSessionTicket), 和 HRR (HelloRetryRequest) 。当实现方在接收到它能识别的消息，并且并没有为出现的消息做规定的话，它必须用 “illegal_parameter” alert 消息中止握手。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c">+--------------------------------------------------+-------------+<br>| Extension                                        |     TLS <span class="hljs-number">1.3</span> |<br>+--------------------------------------------------+-------------+<br>| server_name [RFC6066]                            |      CH, EE |<br>|                                                  |             |<br>| max_fragment_length [RFC6066]                    |      CH, EE |<br>|                                                  |             |<br>| status_request [RFC6066]                         |  CH, CR, CT |<br>|                                                  |             |<br>| supported_groups [RFC7919]                       |      CH, EE |<br>|                                                  |             |<br>| signature_algorithms (RFC <span class="hljs-number">8446</span>)                  |      CH, CR |<br>|                                                  |             |<br>| use_srtp [RFC5764]                               |      CH, EE |<br>|                                                  |             |<br>| heartbeat [RFC6520]                              |      CH, EE |<br>|                                                  |             |<br>| application_layer_protocol_negotiation [RFC7301] |      CH, EE |<br>|                                                  |             |<br>| signed_certificate_timestamp [RFC6962]           |  CH, CR, CT |<br>|                                                  |             |<br>| client_certificate_type [RFC7250]                |      CH, EE |<br>|                                                  |             |<br>| server_certificate_type [RFC7250]                |      CH, EE |<br>|                                                  |             |<br>| padding [RFC7685]                                |          CH |<br>|                                                  |             |<br>| key_share (RFC <span class="hljs-number">8446</span>)                             | CH, SH, HRR |<br>|                                                  |             |<br>| pre_shared_key (RFC <span class="hljs-number">8446</span>)                        |      CH, SH |<br>|                                                  |             |<br>| psk_key_exchange_modes (RFC <span class="hljs-number">8446</span>)                |          CH |<br>|                                                  |             |<br>| early_data (RFC <span class="hljs-number">8446</span>)                            | CH, EE, NST |<br>|                                                  |             |<br>| cookie (RFC <span class="hljs-number">8446</span>)                                |     CH, HRR |<br>|                                                  |             |<br>| supported_versions (RFC <span class="hljs-number">8446</span>)                    | CH, SH, HRR |<br>|                                                  |             |<br>| certificate_authorities (RFC <span class="hljs-number">8446</span>)               |      CH, CR |<br>|                                                  |             |<br>| oid_filters (RFC <span class="hljs-number">8446</span>)                           |          CR |<br>|                                                  |             |<br>| post_handshake_auth (RFC <span class="hljs-number">8446</span>)                   |          CH |<br>|                                                  |             |<br>| signature_algorithms_cert (RFC <span class="hljs-number">8446</span>)             |      CH, CR |<br>+--------------------------------------------------+-------------+<br></code></pre></td></tr></table></figure><p>当存在多种不同类型的扩展的时候，除了 “pre_shared_key” 必须是 ClientHello 的最后一个扩展，其他的扩展间的顺序可以是任意的。(“pre_shared_key” 可以出现在 ServerHello 中扩展块中的任何位置)。不能存在多个同一个类型的扩展。</p><p>在 TLS 1.3 中，与 TLS 1.2 不同，即使是恢复 PSK 模式，每次握手都需要协商扩展。然而，0-RTT 的参数是在前一次握手中协商的。如果参数不匹配，需要拒绝 0-RTT。</p><p>在 TLS 1.3 中新特性和老特性之间存在微妙的交互，这可能会使得整体安全性显著下降。下面是设计新扩展的时候需要考虑的因素：</p><ul><li><p>Server 不同意扩展的某些情况是错误的(例如握手不能继续)，有些情况只是简单的不支持特定的功能。一般来说，前一种情况应该用错误的 alert，后一种情况应该用 Server 的扩展响应中的一个字段来处理。</p></li><li><p>扩展应尽可能设计为防止能通过人为操纵握手信息，从而强制使用（或不使用）特定功能的攻击。不管这个功能是否会引起安全问题，这个原则都必须遵守。通常，包含在 Finished 消息的哈希输入中的扩展字段是不用担心的，但是在握手阶段，扩展试图改变了发送消息的含义，这种情况需要特别小心。设计者和实现者应该意识到，在握手完成身份认证之前，攻击者都可以修改消息，插入、删除或者替换扩展。</p></li></ul><h3 id="1-supported-versions"><a class="markdownIt-Anchor" href="#1-supported-versions"></a> 1. Supported Versions</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    select (Handshake.msg_type) &#123;<br>        <span class="hljs-keyword">case</span> client_hello:<br>             ProtocolVersion versions&lt;<span class="hljs-number">2.</span><span class="hljs-number">.254</span>&gt;;<br><br>        <span class="hljs-keyword">case</span> server_hello: <span class="hljs-comment">/* and HelloRetryRequest */</span><br>             ProtocolVersion selected_version;<br>    &#125;;<br>&#125; SupportedVersions;<br><br></code></pre></td></tr></table></figure><p>“supported_versions” 对于 Client 来说，Client 用它来标明它所能支持的 TLS 版本，对于 Server 来说，Server 用它来标明正在使用的 TLS 版本。这个扩展包含一个按照优先顺序排列的，能支持的版本列表。最优先支持的版本放在第一个。TLS 1.3 这个版本的规范是必须在发送 ClientHello 消息时候带上这个扩展，扩展中包含所有准备协商的 TLS 版本。(对于这个规范来说，这意味着最低是 0x0304，但是如果要协商 TLS 的以前的版本，那么这个扩展必须要带上)</p><p>如果不存在 “supported_versions” 扩展，满足 TLS 1.3 并且也兼容 TLS 1.2 规范的 Server 需要协商 TLS 1.2 或者之前的版本，即使 ClientHello.legacy_version 是 0x0304 或者更高的版本。Server 在接收到 ClientHello 中的 legacy_version 的值是 0x0304 或者更高的版本的时候，Server 可能需要立刻中止握手。</p><p>如果 ClientHello 中存在 “supported_versions” 扩展，Server 禁止使用 ClientHello.legacy_version 的值作为版本协商的值，只能使用 “supported_versions” 决定 Client 的偏好。Server 必须只选择该扩展中存在的 TLS 版本，并且必须要忽略任何未知版本。注意，如果通信的一方支持稀疏范围，这种机制使得可以在 TLS 1.2 之前的版本间进行协商。选择支持 TLS 的以前版本的 TLS 1.3 的实现应支持 TLS 1.2。Server 应准备好接收包含此扩展名的 ClientHellos 消息，但不要在 viersions 列表中包含 0x0304。</p><p>Server 在协商 TLS 1.3 之前的版本，必须要设置 ServerHello.version，不能发送 “supported_versions” 扩展。Server 在协商 TLS 1.3 版本时候，必须发送 “supported_versions” 扩展作为响应，并且扩展中要包含选择的 TLS 1.3 版本号(0x0304)。还要设置 ServerHello.legacy_version 为 0x0303(TLS 1.2)。Client 必须在处理 ServerHello 之前检查此扩展(尽管需要先解析 ServerHello 以便读取扩展名)。如果 “supported_versions” 扩展存在，Client 必须忽略 ServerHello.legacy_version 的值，只使用 “supported_versions” 中的值确定选择的版本。如果 ServerHello 中的 “supported_versions” 扩展包含了 Client 没有提供的版本，或者是包含了 TLS 1.3 之前的版本(本来是协商 TLS 1.3 的，却又包含了 TLS 1.3 之前的版本)，Client 必须立即发送 “illegal_parameter” alert 消息中止握手。</p><h3 id="2-cookie"><a class="markdownIt-Anchor" href="#2-cookie"></a> 2. Cookie</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    opaque cookie&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>&#125; Cookie;<br></code></pre></td></tr></table></figure><p>Cookies 有 2 大主要目的：</p><ul><li><p>允许 Server 强制 Client 展示网络地址的可达性(因此提供了一个保护 Dos 的度量方法)，这主要是面向无连接的传输(参考 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6347">RFC 6347</a> 中的例子)</p></li><li><p>允许 Server 卸载状态。从而允许 Server 在向 Client 发送 HelloRetryRequest 消息的时候，不存储任何状态。为了实现这一点，可以通过 Server 把 ClientHello 的哈希存储在 HelloRetryRequest 的 cookie 中(用一些合适的完整性算法保护)。</p></li></ul><p>当发送 HelloRetryRequest 消息时，Server 可以向 Client 提供 “cookie” 扩展(这是常规中的一个例外，常规约定是：只能是可能被发送的扩展才可以出现在 ClientHello 中)。当发送新的 ClientHello 消息时，Client 必须将 HelloRetryRequest 中收到的扩展的内容复制到新 ClientHello 中的 “cookie” 扩展中。Client 不得在后续连接中使用首次 ClientHello 中的 Cookie。</p><p>当 Server 在无状态运行的时候，在第一个和第二个 ClientHello 之间可能会收到不受保护的 change_cipher_spec 消息。由于 Server 没有存储任何状态，它会表现出像到达的第一条消息一样。无状态的 Server 必须忽略这些记录。</p><h3 id="3-signature-algorithms"><a class="markdownIt-Anchor" href="#3-signature-algorithms"></a> 3. Signature Algorithms</h3><p>TLS 1.3 提供了 2 种扩展来标明在数字签名中可能用到的签名算法。“signature_algorithms_cert” 扩展提供了证书里面的签名算法。“signature_algorithms” 扩展(TLS 1.2 中就有这个扩展了)，提供了 CertificateVerify 消息中的签名算法。证书中的密钥必须要根据所用的签名算法匹配合适的类型。对于 RSA 密钥和 PSS 签名，这是一个特殊问题，描述如下：如果没有 “signature_algorithms_cert” 扩展，则 “signature_algorithms” 扩展同样适用于证书中的签名。Client 想要 Server 通过证书来认证自己，则必须发送 “signature_algorithms” 扩展。如果 Server 正在进行证书的认证，这个时候 Client 又没有提供 &quot;signature_algorithms&quot;扩展，Server 必须 发送 “missing_extension” 消息中止握手。</p><p>加入 “signature_algorithms_cert” 扩展的意图是为了让已经支持了证书的不同算法集的实现方，能明确的标识他们的能力。TLS 1.2 实现应该也应该处理这个扩展。在两种情况下具有相同策略的实现可以省略 “signature_algorithms_cert” 扩展名。</p><p>这些扩展中的 “extension_data” 字段包含一个 SignatureSchemeList 值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>          <span class="hljs-comment">/* RSASSA-PKCS1-v1_5 algorithms */</span><br>          rsa_pkcs1_sha256(<span class="hljs-number">0x0401</span>),<br>          rsa_pkcs1_sha384(<span class="hljs-number">0x0501</span>),<br>          rsa_pkcs1_sha512(<span class="hljs-number">0x0601</span>),<br><br>          <span class="hljs-comment">/* ECDSA algorithms */</span><br>          ecdsa_secp256r1_sha256(<span class="hljs-number">0x0403</span>),<br>          ecdsa_secp384r1_sha384(<span class="hljs-number">0x0503</span>),<br>          ecdsa_secp521r1_sha512(<span class="hljs-number">0x0603</span>),<br><br>          <span class="hljs-comment">/* RSASSA-PSS algorithms with public key OID rsaEncryption */</span><br>          rsa_pss_rsae_sha256(<span class="hljs-number">0x0804</span>),<br>          rsa_pss_rsae_sha384(<span class="hljs-number">0x0805</span>),<br>          rsa_pss_rsae_sha512(<span class="hljs-number">0x0806</span>),<br><br>          <span class="hljs-comment">/* EdDSA algorithms */</span><br>          ed25519(<span class="hljs-number">0x0807</span>),<br>          ed448(<span class="hljs-number">0x0808</span>),<br><br>          <span class="hljs-comment">/* RSASSA-PSS algorithms with public key OID RSASSA-PSS */</span><br>          rsa_pss_pss_sha256(<span class="hljs-number">0x0809</span>),<br>          rsa_pss_pss_sha384(<span class="hljs-number">0x080a</span>),<br>          rsa_pss_pss_sha512(<span class="hljs-number">0x080b</span>),<br><br>          <span class="hljs-comment">/* Legacy algorithms */</span><br>          rsa_pkcs1_sha1(<span class="hljs-number">0x0201</span>),<br>          ecdsa_sha1(<span class="hljs-number">0x0203</span>),<br><br>          <span class="hljs-comment">/* Reserved Code Points */</span><br>          private_use(<span class="hljs-number">0xFE00</span>.<span class="hljs-number">.0</span>xFFFF),<br>          (<span class="hljs-number">0xFFFF</span>)<br>      &#125; SignatureScheme;<br><br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>          SignatureScheme supported_signature_algorithms&lt;<span class="hljs-number">2.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-2</span>&gt;;<br>      &#125; SignatureSchemeList;<br><br></code></pre></td></tr></table></figure><p>请注意：这个枚举之所以名为 “SignatureScheme”，是因为在 TLS 1.2中已经存在了 “SignatureAlgorithm” 类型，取而代之。在本篇文章中，我们都使用术语 “签名算法”。</p><p>每一个列出的 SignatureScheme 的值是 Client 想要验证的单一签名算法。这些值按照优先级降序排列。请注意，签名算法以任意长度的消息作为输入，而不是摘要作为输入。传统上用于摘要的算法应该在 TLS 中定义，首先使用指定的哈希算法对输入进行哈希计算，然后再进行常规处理。上面列出的代码具有以下含义：</p><ul><li><p>RSASSA-PKCS1-v1_5 algorithms:<br>表示使用 RSASSA-PKCS1-v1_5 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8017">RFC8017</a> 和定义在 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8446#ref-SHS">SHS</a> 中对应的哈希算法的签名算法。这些值仅指，出现在证书中又没有被定义用于签名 TLS 握手消息的签名。这些值会出现在 “signature_algorithms” 和 “signature_algorithms_cert” 中，因为需要向后兼容 TLS 1.2 。</p></li><li><p>ECDSA algorithms:<br>表示签名算法使用 ECDSA，对应的曲线在 ANSI X9.62 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8446#ref-ECDSA">ECDSA</a> 和 FIPS 186-4 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8446#ref-DSS">DSS</a> 中定义了，对应的哈希算法在 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8446#ref-SHS">SHS</a> 中定义了。签名被表示为 DER 编码的 ECDSA-Sig-Value 结构。</p></li><li><p>RSASSA-PSS RSAE algorithms:<br>表示使用带有掩码生成函数 1 的 RSASSA-PSS 签名算法。在掩码生成函数中使用的摘要和被签名的摘要都是在 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8446#ref-SHS">SHS</a> 中定义的相应的哈希算法。盐的长度必须等于摘要算法输出的长度。如果公钥在 X.509 证书中，则必须使用 rsaEncryption OID <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5280">RFC5280</a>。</p></li><li><p>EdDSA algorithms:<br>表示使用定义在 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8032">RFC 8032</a> 中的 EdDSA 算法或者其后续改进算法。请注意，这些相应算法是 “PureEdDSA” 算法，而不是 “prehash” 变种算法。</p></li><li><p>RSASSA-PSS PSS algorithms:<br>表示使用带有掩码生成函数 1 的 RSASSA-PSS <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8017">RFC 8017</a> 签名算法。在掩码生成函数中使用的摘要和被签名的摘要都是在 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8446#ref-SHS">SHS</a> 中定义的相应的哈希算法。盐的长度必须等于摘要算法的长度。如果公钥在 X.509 证书中，则必须使用 RSASSA-PSS OID <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5756">RFC5756</a>。当它被用在证书签名中，算法参数必须是 DER 编码。如果存在相应的公钥参数，则签名中的参数必须与公钥中的参数相同。</p></li><li><p>Legacy algorithms:<br>表示使用正在被废弃中的算法，因为这些算法有已知的缺点。特别是 SHA-1 配合上文提到的 RSASSA-PKCS1-v1_5 和 ECDSA 算法一起使用。这些值仅指，出现在证书中又没有被定义用于签名 TLS 握手消息的签名。这些值会出现在 “signature_algorithms” 和 “signature_algorithms_cert” 中，因为需要向后兼容 TLS 1.2 。终端不应该协商这些算法，但允许这样做只是为了向后兼容。提供这些值的 Client 必须把他们列在最低优先级的位置上(在 SignatureSchemeList 中的所有其他算法之后列出)。TLS 1.3 Server 绝不能提供 SHA-1 签名证书，除非没有它就无法生成有效的证书链。</p></li></ul><p>自签名证书上的签名或信任锚的证书不能通过校验，因为它们开始了一个认证路径(见 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5280#section-3.2">RFC 5280</a>)。开始认证路径的证书可以使用 “signature_algorithms” 扩展中不建议支持的签名算法。</p><p>请注意，TLS 1.2 中这个扩展的定义和 TLS 1.3 的定义不同。在协商 TLS 1.2 版本时，愿意协商 TLS 1.2 的 TLS 1.3 实现必须符合 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5246">RFC5246</a> 的要求，尤其是：</p><ul><li><p>TLS 1.2 ClientHellos 可以忽略此扩展。</p></li><li><p>在 TLS 1.2 中，扩展包含 hash/signature pairs。这些 pairs 被编码为两个八位字节，所以已经分配空间的 SignatureScheme 值与 TLS 1.2 的编码对齐。 一些传统的 pairs 保留未分配。这些算法已被 TLS 1.3 弃用。它们不得在任何实现中被提供或被协商。 特别是，不得使用 MD5 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8446#ref-SLOTH">[SLOTH]</a> 、SHA-224 和 DSA。</p></li><li><p>ECDSA 签名方案和 TLS 1.2 的 hash/signature pairs 一致。然而，旧的语义并没有限制签名曲线。如果 TLS 1.2 被协商了，实现方必须准备接受在 “supported_groups” 扩展中使用任何曲线的签名。</p></li><li><p>即使协商了 TLS 1.2，支持了 RSASSA-PSS（在TLS 1.3中是强制性的）的实现方也准备接受该方案的签名。在TLS 1.2中，RSASSA-PSS 与 RSA 密码套件一起使用。</p></li></ul><h3 id="4-certificate-authorities"><a class="markdownIt-Anchor" href="#4-certificate-authorities"></a> 4. Certificate Authorities</h3><p>“certificate_authorities” 扩展用于表示终端支持的 CA, 并且接收的端点应该使用它来指导证书的选择。</p><p>“certificate_authorities” 扩展的主体包含了一个 CertificateAuthoritiesExtension 结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">opaque DistinguishedName&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    DistinguishedName authorities&lt;<span class="hljs-number">3.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>&#125; CertificateAuthoritiesExtension;<br></code></pre></td></tr></table></figure><ul><li>authorities:<br>可接受证书颁发机构的一个可分辨名字 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8446#ref-X501">X501</a> 的列表	，这个列表是以 DER <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8446#ref-X690">X690</a> 编码格式表示的。这些可分辨的名称为，信任锚或从属的 CA 指定所需的可分辨的名称。因此，可以使用此消息描述已知的信任锚以及所需的授权空间。</li></ul><p>Client 可能会在 ClientHello 消息中发送 “certificate_authorities” 扩展，Server 可能会在 CertificateRequest 消息中发送 “certificate_authorities” 扩展。</p><p>“trusted_ca_keys” 扩展和 “certificate_authorities” 扩展有相同的目的，但是更加复杂。“trusted_ca_keys” 扩展不能在 TLS 1.3 中使用，但是它在 TLS 1.3 之前的版本中，可能出现在 Client 的 ClientHello 消息中。</p><h3 id="5-oid-filters"><a class="markdownIt-Anchor" href="#5-oid-filters"></a> 5. OID Filters</h3><p>“oid_filters” 扩展允许 Server 提供一组 OID/value 对，用来匹配 Client 的证书。如果 Server 想要发送这个扩展，有且仅有在 CertificateRequest 消息中才能发送。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    opaque certificate_extension_oid&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">8</span><span class="hljs-number">-1</span>&gt;;<br>    opaque certificate_extension_values&lt;<span class="hljs-number">0.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>&#125; OIDFilter;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    OIDFilter filters&lt;<span class="hljs-number">0.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>&#125; OIDFilterExtension;<br></code></pre></td></tr></table></figure><ul><li>filters:<br>一个有允许值的证书扩展 OID <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5280">RFC 5280</a> 列表，以 DER 编码 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8446#ref-X690">X690</a> 格式表示。一些证书扩展 OID 允许多个值(例如，Extended Key Usage)。如果 Server 包含非空的 filters 列表，则响应中包含的 Client 证书必须包含 Client 识别的所有指定的扩展 OID。对于 Client 识别的每个扩展 OID，所有指定的值必须存在于 Client 证书中（但是证书也可以具有其他值）。然而，Client 必须忽略并跳过任何无法识别的证书扩展 OID。如果 Client 忽略了一些所需的证书扩展 OID 并提供了不满足请求的证书。Server 可以自行决定是继续与没有身份认证的 Client 保持连接，还是用 “unsupported_certificate” alert 消息中止握手。任何给定的 OID 都不能在 filters 列表中出现多次。</li></ul><p>PKIX RFC 定义了各种证书扩展 OID 及其对应的值类型。根据类型，匹配的证书扩展值不一定是按位相等的。期望 TLS 实现将依靠它们的 PKI 库，使用证书扩展 OID 来做证书的选择。</p><p>本文档定义了 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5280">RFC5280</a> 中定义的两个标准证书扩展的匹配规则：</p><ul><li><p>当请求中声明的所有 Key Usage 位也同样在 Key Usage 证书扩展声明了，那么证书中的 Key Usage 扩展匹配了请求。</p></li><li><p>当请求中所有的密钥 OIDs 在 Extended Key Usage 证书扩展中也存在，那么证书中的 Extended Key Usage 匹配了请求。特殊的 anyExtendedKeyUsage OID 一定不能在请求中使用。</p></li></ul><p>单独的规范可以为其他证书扩展的规则定义匹配规则。</p><h3 id="6-post-handshake-client-authentication"><a class="markdownIt-Anchor" href="#6-post-handshake-client-authentication"></a> 6. Post-Handshake Client Authentication</h3><p>“post_handshake_auth” 扩展用于表明 Client 愿意握手后再认证。Server 不能向没有提供此扩展的 Client 发送握手后再认证的 CertificateRequest 消息。Server 不能发送此扩展。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>&#125; PostHandshakeAuth;<br></code></pre></td></tr></table></figure><p>“post_handshake_auth” 扩展名中的 “extension_data” 字段为零长度。</p><h3 id="7-supported-groups"><a class="markdownIt-Anchor" href="#7-supported-groups"></a> 7. Supported Groups</h3><p>当 Client 发送 “supported_groups” 扩展的时候，这个扩展表明了 Client 支持的用于密钥交换的命名组。按照优先级从高到低。</p><p>请注意：在 TLS 1.3 之前的版本中，这个扩展原来叫 “elliptic_curves”，并且只包含椭圆曲线组。具体请参考 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8422">RFC8422</a> 和 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7919">RFC7919</a>。这个扩展同样可以用来协商 ECDSA 曲线。签名算法现在独立协商了。</p><p>这个扩展中的 “extension_data” 字段包含一个 “NamedGroupList” 值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br><br>    <span class="hljs-comment">/* Elliptic Curve Groups (ECDHE) */</span><br>    secp256r1(<span class="hljs-number">0x0017</span>), secp384r1(<span class="hljs-number">0x0018</span>), secp521r1(<span class="hljs-number">0x0019</span>),<br>    x25519(<span class="hljs-number">0x001D</span>), x448(<span class="hljs-number">0x001E</span>),<br><br>    <span class="hljs-comment">/* Finite Field Groups (DHE) */</span><br>    ffdhe2048(<span class="hljs-number">0x0100</span>), ffdhe3072(<span class="hljs-number">0x0101</span>), ffdhe4096(<span class="hljs-number">0x0102</span>),<br>    ffdhe6144(<span class="hljs-number">0x0103</span>), ffdhe8192(<span class="hljs-number">0x0104</span>),<br><br>    <span class="hljs-comment">/* Reserved Code Points */</span><br>    ffdhe_private_use(<span class="hljs-number">0x01FC</span>.<span class="hljs-number">.0</span>x01FF),<br>    ecdhe_private_use(<span class="hljs-number">0xFE00</span>.<span class="hljs-number">.0</span>xFEFF),<br>    (<span class="hljs-number">0xFFFF</span>)<br>&#125; NamedGroup;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    NamedGroup named_group_list&lt;<span class="hljs-number">2.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>&#125; NamedGroupList;<br></code></pre></td></tr></table></figure><ul><li><p>Elliptic Curve Groups (ECDHE):<br>表示支持在 FIPS 186-4 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8446#ref-DSS">[DSS]</a> 或者 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7748">[RFC7748]</a> 中定义的对应命名的曲线。0xFE00 到 0xFEFF 的值保留使用<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8126">[RFC8126]</a>。</p></li><li><p>Finite Field Groups (DHE):<br>表示支持相应的有限域组，相关定义可以参考 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7919">[RFC7919]</a>。0x01FC 到 0x01FF 的值保留使用。</p></li></ul><p>named_group_list 中的项根据发送者的优先级排序(最好是优先选择的)。</p><p>在 TLS 1.3 中，Server 允许向 Client 发送 “supported_groups” 扩展。Client 不能在成功完成握手之前，在 “supported_groups” 中找到的任何信息采取行动，但可以使用从成功完成的握手中获得的信息来更改在后续连接中的 “key_share” 扩展中使用的组。如果 Server 中有一个组，它更想接受 “key_share” 扩展中的那些值，但仍然愿意接受 ClientHello 消息，这时候它应该发送 “supported_groups” 来更新 Client 的偏好视图。无论 Client 是否支持它，这个扩展名都应该包含 Server 支持的所有组。</p><h3 id="8-key-share"><a class="markdownIt-Anchor" href="#8-key-share"></a> 8. Key Share</h3><p>“key_share” 扩展包含终端的加密参数。</p><p>Client 可能会发送空的 client_shares 向量，以额外的往返代价，向 Server 请求选择的组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    NamedGroup group;<br>    opaque key_exchange&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>&#125; KeyShareEntry;<br></code></pre></td></tr></table></figure><ul><li><p>group:<br>要交换的密钥的命名组。</p></li><li><p>key_exchange:<br>密钥交换信息。这个字段的内容由特定的组和相应的定义确定。有限域的 Diffie-Hellman 参数在下面会描述。椭圆曲线 Diffie-Hellman 参数也会下面会描述。</p></li></ul><p>在 ClientHello 消息中，“key_share” 扩展中的 “extension_data” 包含 KeyShareClientHello 值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    KeyShareEntry client_shares&lt;<span class="hljs-number">0.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>&#125; KeyShareClientHello;<br></code></pre></td></tr></table></figure><ul><li>client_shares:<br>按照 Client 偏好降序顺序提供的 KeyShareEntry 值列表。</li></ul><p>如果 Client 正在请求 HelloRetryRequest， 则这个向量可以为空。每个 KeyShareEntry 值必须对应一个在 “supported_groups” 扩展中提供的组，并且出现的顺序必须相同。然而，当优先级排名第一的组合是新的，并且不足以提供预生成 key shares 的时候，那么值可以是 “supported_groups” 扩展的非连续子集，并且可以省略最优选的组，这种情况是可能会出现的。</p><p>Client 可以提供与其提供的 support groups 一样多数量的 KeyShareEntry 的值。每个值都代表了一组密钥交换参数。例如，Client 可能会为多个椭圆曲线或者多个 FFDHE 组提供 shares。每个 KeyShareEntry 中的 key_exchange 值必须独立生成。Client 不能为相同的 group 提供多个 KeyShareEntry 值。Client 不能为，没有出现在 Client 的 “supported_group” 扩展中列出的 group 提供任何 KeyShareEntry 值。Server 会检查这些规则，如果违反了规则，立即发送 “illegal_parameter” alert 消息中止握手。</p><p>在 HelloRetryRequest 消息中，“key_share” 扩展中的 “extension_data” 字段包含 KeyShareHelloRetryRequest 值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    NamedGroup selected_group;<br>&#125; KeyShareHelloRetryRequest;<br></code></pre></td></tr></table></figure><ul><li>selected_group:<br>Server 打算协商的相互支持并且正在请求重试 ClientHello / KeyShare 的 group。</li></ul><p>在 HelloRetryRequest 消息中收到此扩展后，Client 必须要验证 2 点。第一点，selected_group 必须在原始的 ClientHello 中的 “supported_groups” 中出现过。第二点，selected_group 没有在原始的 ClientHello 中的 “key_share” 中出现过。如果上面 2 点检查都失败了，那么 Client 必须通过 “illegal_parameter” alert 消息来中止握手。否则，在发送新的 ClientHello 时，Client 必须将原始的 “key_share” 扩展替换为仅包含触发 HelloRetryRequest 的 selected_group 字段中指示的组,这个组中只包含新的 KeyShareEntry。</p><p>在 ServerHello 消息中，“key_share” 扩展中的 “extension_data” 字段包含 KeyShareServerHello 值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    KeyShareEntry server_share;<br>&#125; KeyShareServerHello;<br></code></pre></td></tr></table></figure><ul><li>server_share:<br>与 Client 共享的位于同一组的单个 KeyShareEntry 值。</li></ul><p>如果使用 (EC)DHE 密钥建立链接，Server 在 ServerHello 中只提供了一个 KeyShareEntry。这个值必须与，Server 为了协商密钥交换在 Client 提供的 KeyShareEntry 值中选择的值，在同一组中。Server 不能为 Client 的 “supported_groups” 扩展中指定的任何 group 发送 KeyShareEntry 值。Server 也不能在使用 “psk_ke” PskKeyExchangeMode 时候发送 KeyShareEntry 值。如果使用 (EC)DHE 建立链接，Client 收到了包含在 “key_share” 扩展中的 HelloRetryRequest 消息，Client 必须验证在 ServerHello 中选择的 NameGroup 与 HelloRetryRequest 中是否相同。如果不相同，Client 必须立即发送 “illegal_parameter” alert 消息中止握手。</p><h4 id="1-diffie-hellman-parameters"><a class="markdownIt-Anchor" href="#1-diffie-hellman-parameters"></a> (1) Diffie-Hellman Parameters</h4><p>Client 和 Server 两者的 Diffie-Hellman <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8446#ref-DH76">[DH76]</a> 参数都编码在 KeyShareEntry 中的 KeyShare 数据结构中 opaque 类型的 key_exchange 字段中。opaque 类型的值包含指定 group 的 Diffie-Hellman 公钥(Y = g^X mod p)，是用大端整数编码的。这个值大小为 p 字节，如果字节不够，需要在其左边添加 0 。</p><p>请注意：对于给定的 Diffie-Hellman 组，填充会导致所有的公钥具有相同的长度。</p><p>对端必须要相互验证对方的公钥，确保 1 &lt; Y &lt; p-1。此检查确保远程对端正常运行，也使得本地系统不会强制进入进入更小的 subgroup。</p><h4 id="2-ecdhe-parameters"><a class="markdownIt-Anchor" href="#2-ecdhe-parameters"></a> (2) ECDHE Parameters</h4><p>Client 和 Server 两者的 ECDHE 参数都编码在 KeyShareEntry 中的 KeyShare 数据结构中 opaque 类型的 key_exchange 字段中。</p><p>对于 secp256r1，secp384r1 和 secp521r1，内容是以下结构体的序列化值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    uint8 legacy_form = <span class="hljs-number">4</span>;<br>    opaque X[coordinate_length];<br>    opaque Y[coordinate_length];<br>&#125; UncompressedPointRepresentation;<br></code></pre></td></tr></table></figure><p>X 和 Y 分别是网络字节顺序中 X 和 Y 值的二进制表示。由于没有内部长度标记，所以每个数字占用曲线参数隐含的 8 位字节数。对于 P-256，这意味着 X 和 Y 中的每一个占用 32 个八位字节，如果需要，则在左侧填充零。对于 P-384，它们分别占用 48 个八位字节，对于 P-521，它们各占用 66 个八位字节。</p><p>对于曲线 secp256r1, secp384r1, 和 secp521r1，对端必须验证对方的的公钥 Q，以保证这个点是椭圆曲线上有效的点。合适的验证方法定义在 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8446#ref-ECDSA">[ECDSA]</a> 中或者 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8446#ref-KEYAGREEMENT">[KEYAGREEMENT]</a>。这个处理包括了 3 步。第一步：验证 Q 不是无穷大的点 (O)。第二步，验证 Q = (x, y) 中的两个整数 x，y 有正确的间隔。第三步，验证 (x, y) 是椭圆曲线方程的正确的解。对于这些曲线，实现方不需要再验证正确的 subgroup 中的成员身份。</p><p>对于 X25519 和 X448 来说，公共值的内容是 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7748">[RFC7748]</a> 中定义的相应函数的字节串输入和输出，X25519 的是 32 个字节， X448 的是 56 个字节。</p><p>请注意：<strong>TLS 1.3 之前的版本允许 point format 协商，TLS 1.3 移除了这个功能，以利于每个曲线的单独 point format</strong>。</p><h3 id="9-pre-shared-key-exchange-modes"><a class="markdownIt-Anchor" href="#9-pre-shared-key-exchange-modes"></a> 9. Pre-Shared Key Exchange Modes</h3><p>为了使用 PSK，Client 还必须发送一个 “psk_key_exchange_modes” 扩展。这个扩展语意是 Client 仅支持使用具有这些模式的 PSK。这就限制了在这个 ClientHello 中提供的 PSK 的使用，也限制了 Server 通过 NewSessionTicket 提供的 PSK 的使用。</p><p>如果 Client 提供了 “pre_shared_key” 扩展，那么它必须也要提供 “psk_key_exchange_modes” 扩展。如果 Client 发送不带 “psk_key_exchange_modes” 扩展名的 “pre_shared_key”，Server 必须立即中止握手。Server 不能选择一个 Client 没有列出的密钥交换模式。此扩展还限制了与 PSK 恢复使用的模式。Server 也不能发送与建议的 modes 不兼容的 NewSessionTicket。不过如果 Server 一定要这样做，影响的只是 Client 在尝试恢复会话的时候会失败。</p><p>Server 不能发送 “psk_key_exchange_modes” 扩展:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> psk_ke(<span class="hljs-number">0</span>), psk_dhe_ke(<span class="hljs-number">1</span>), (<span class="hljs-number">255</span>) &#125; PskKeyExchangeMode;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    PskKeyExchangeMode ke_modes&lt;<span class="hljs-number">1.</span><span class="hljs-number">.255</span>&gt;;<br>&#125; PskKeyExchangeModes;<br></code></pre></td></tr></table></figure><ul><li><p>psk_ke:<br>仅 PSK 密钥建立。在这种模式下，Server 不能提供 “key_share” 值。</p></li><li><p>psk_dhe_ke:<br>PSK 和 (EC)DHE 建立。在这种模式下，Client 和 Server 必须提供 “key_share” 值。</p></li></ul><p>未来分配的任何值都必须要能保证传输的协议消息可以明确的标识 Server 选择的模式。目前 Server 选择的值由 ServerHello 中存在的 “key_share” 表示。</p><h3 id="10-early-data-indication"><a class="markdownIt-Anchor" href="#10-early-data-indication"></a> 10. Early Data Indication</h3><p>当使用 PSK 并且 PSK 允许使用 early_data 的时候，Client 可以在其第一个消息中发送应用数据。如果 Client 选择这么做，则必须发送 “pre_shared_key” 和 “early_data” 扩展。</p><p>Early Data Indication 扩展中的 “extension_data” 字段包含了一个 EarlyDataIndication 值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>&#125; Empty;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    select (Handshake.msg_type) &#123;<br>        <span class="hljs-keyword">case</span> new_session_ticket:   uint32 max_early_data_size;<br>        <span class="hljs-keyword">case</span> client_hello:         Empty;<br>        <span class="hljs-keyword">case</span> encrypted_extensions: Empty;<br>    &#125;;<br>&#125; EarlyDataIndication;<br></code></pre></td></tr></table></figure><p>有关 max_early_data_size 字段的使用请看 <a target="_blank" rel="noopener" href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TLS_1.3_Handshake_Protocol.md#1-new-session-ticket-message">New Session Ticket Message</a> 章节。</p><p>0-RTT 数据(版本，对称加密套件，应用层协议协商协议<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7301">[RFC7301]</a>，等等)的参数与使用中的 PSK 参数相关。对于外部配置的 PSK，关联值是由密钥提供的。对于通过 NewSessionTicket 消息建立的 PSK，关联值是在建立 PSK 连接时协商的值。PSK 用来加密 early data 必须是 Client 在 “pre_shared_key” 扩展中列出的第一个 PSK。</p><p>对于通过 NewSessionTicket 提供的 PSK，Server 必须验证所选 PSK 标识中的 ticket age(从 PskIdentity.obfuscated_ticket_age 取 2^32 模中减去 ticket_age_add)距离 ticket 发出的时间是否有一个很小的公差。如果相差的时间很多，那么 Server 应该继续握手，但是要拒绝 0-RTT，并且还要假定这条 ClientHello 是新的，也不能采取任何其他措施。</p><p>在第一次 flight 中发送的 0-RTT 消息与其他 flight (握手和应用数据)中发送的相同类型的消息具有相同(加密)的内容类型，但受到不同密钥的保护。如果 Server 已经接收了 early data，Client 在收到 Server 的 Finished 消息以后，Client 则会发送 EndOfEarlyData 消息表示密钥更改。这条消息将会使用 0-RTT 的 traffic 密钥进行加密。</p><p>Server 接收 “early_data” 扩展必须以下面三种方式之一操作：</p><ul><li><p>忽略 “early_data” 扩展，并返回常规的 1-RTT 响应。Server 尝试通过用握手中的流量密钥(traffic key)解密收到的记录，并忽略掉 early data。丢弃解密失败的记录(取决于配置的 max_early_data_size)。一旦一个记录被解密成功，它将会被 Server 看做 Client 第二次 flight 的开始并且 Server 会把它当做普通的 1-RTT 来处理。</p></li><li><p>通过回应 HelloRetryRequest 来请求 Client 发送另外一个 ClientHello。Client 不能在这个 ClientHello 中包含 “early_data” 扩展。Server 通过跳过具有外部内容类型的 “application_data”(说明他们被加密了) 的所有记录来忽略 early data(同样取决于配置的 max_early_data_size)。</p></li><li><p>在 EncryptedExtensions 中返回自己的 “early_data” 扩展，表明它准备处理 early data。Server 不可能只接受 early data 消息中的一部分。即使 Server 发送了一条接收 early data 的消息，但是实际上 early data 可能在 Server 生成这条消息的时候已经在 flight 了。</p></li></ul><p>为了接受 early data，Server 必须已经接受了 PSK 密码套件并且选择了 Client 的 “pre_shared_key” 扩展中提供的第一个密钥。此外，Server 还需要验证以下的值和选择的 PSK 关联值一样：</p><ul><li>TLS 版本号</li><li>选择的密码套件</li><li>选择的 ALPN 协议，如果选择了的话</li></ul><p>这些要求是使用相关 PSK 执行 1-RTT 握手所需的超集。对于外部建立的 PSK，关联值是与密钥一起提供的值。对于通过 NewSessionTicket 消息建立的 PSK，关联值是在连接中协商的值，在这期间 ticket 被建立了。</p><p>未来的扩展必须定义它们与 0-RTT 的交互。</p><p>如果任何检查失败了，Server 不得在响应中附带扩展，并且必须使用上面列出的前两种机制中的一个，丢弃所有 first-flight 数据(因此回落到 1-RTT 或者 2-RTT)。如果 Client 尝试 0-RTT 握手但 Server 拒绝了它，则 Server 通常不会有 0-RTT 记录保护密钥，而必须使用试用解密（使用 1-RTT 握手密钥或者通过在有 HelloRetryRequest 消息的情况下查找明文 ClientHello）找到第一个非 0-RTT 消息。</p><p>如果 Server 选择接受 early_data 扩展，那么在处理 early data 记录的时候，Server 必须遵守用相同的标准(指定的相同错误处理要求)来处理所有记录。具体来说，如果 Server 无法解密已经接受的 “early_data” 扩展中的记录，则它必须发送 “bad_record_mac” alert 消息中止握手。</p><p>如果 Server 拒绝 “early_data” 扩展，则 Client 应用程序可以选择在握手完成后重新发送先前在 early data 中发送的应用数据。请注意，early data 的自动重传可能会导致关于连接状态的误判。例如，当协商连接从用于 early data 的协议中选择不同的 ALPN 协议时，应用程序可能需要构造不同的消息。同样，如果 early data 假定包含有关连接状态的任何内容，则在握手完成后可能会错误地发送这些内容。</p><p>TLS 的实现不应该自动重新发送 early data；应用程序可以很好的决定何时重传。除非协商连接选择相同的 ALPN 协议，否则 TLS 实现绝不能自动重新发送 early data。</p><h3 id="11-pre-shared-key-extension"><a class="markdownIt-Anchor" href="#11-pre-shared-key-extension"></a> 11. Pre-Shared Key Extension</h3><p>“pre_shared_key” 扩展用来协商标识的，这个标识是与 PSK 密钥相关联的给定握手所使用的预共享密钥的标识。</p><p>这个扩展中的 “extension_data” 字段包含一个 PreSharedKeyExtension 值:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    opaque identity&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>    uint32 obfuscated_ticket_age;<br>&#125; PskIdentity;<br><br>opaque PskBinderEntry&lt;<span class="hljs-number">32.</span><span class="hljs-number">.255</span>&gt;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    PskIdentity identities&lt;<span class="hljs-number">7.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>    PskBinderEntry binders&lt;<span class="hljs-number">33.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>&#125; OfferedPsks;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    select (Handshake.msg_type) &#123;<br>        <span class="hljs-keyword">case</span> client_hello: OfferedPsks;<br>        <span class="hljs-keyword">case</span> server_hello: uint16 selected_identity;<br>    &#125;;<br>&#125; PreSharedKeyExtension;<br></code></pre></td></tr></table></figure><ul><li><p>identity:<br>key 的标签。例如，一个 ticket 或者是一个外部建立的预共享密钥的标签。</p></li><li><p>obfuscated_ticket_age:<br>age of the key 的混淆版本。<a target="_blank" rel="noopener" href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TLS_1.3_Handshake_Protocol.md#1-ticket-age">这一章节</a>描述了通过 NewSessionTicket 消息建立，如何为标识(identities)生成这个值。对于外部建立的标识(identities)，应该使用 0 的 obfuscated_ticket_age，并且 Server 也必须忽略这个值。</p></li><li><p>identities:<br>Client 愿意和 Server 协商的 identities 列表。如果和 “early_data” 一起发送，第一个标识被用来标识 0-RTT 的。</p></li><li><p>binders:<br>一系列的 HMAC 值。和 identities 列表中的每一个值都一一对应，并且顺序一致。</p></li><li><p>selected_identity:<br>Server 选择的标识，这个标识是以 Client 列表中标识表示为基于 0 的索引。</p></li></ul><p>每一个 PSK 都和单个哈希算法相关联。对于通过 ticket 建立的 PSK，当 ticket 在连接中被建立，这时候用的哈希算法是 KDF 哈希算法。对于外部建立的 PSK，当 PSK 建立的时候，哈希算法必须设置，如果没有设置，默认算法是 SHA-256。Server 必须确保它选择的是兼容的 PSK (如果有的话) 和密钥套件。</p><p>在 TLS 1.3 之前的版本中，Server Name Identification (SNI) 的值旨在与会话相关联。Server 被强制要求，与会话关联的 SNI 值要和恢复握手中指定的 SNI 值相互匹配。然而事实上，实现方和他们使用的两个提供的 SNI 值是不一致的，这样就会导致 Client 需要执行一致性的要求。<strong>在 TLS 1.3 版本中，SNI 的值始终在恢复握手中被明确的指出，并且 Server 不需要将 SNI 值和 ticket 相关联</strong>。不过 Client 需要将 SNI 和 PSK 一起存储，以满足 <a target="_blank" rel="noopener" href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TLS_1.3_Handshake_Protocol.md#1-new-session-ticket-message">[4.6.1 章节]</a> 的要求。</p><p>实现者请注意：会话恢复是 PSK 最主要的用途，实现 PSK/密钥套件 匹配要求的最直接的方法是先协商密码套件，然后再排除任何不兼容的 PSK。任何未知的 PSK (例如：不在 PSK 数据库中，或者用未知的 key 进行编码的)都必须忽略。如果找不到可接受的 PSK，如果可能，Server 应该执行 non-PSK 握手。如果向后兼容性很重要，Client 提供的，外部建立的 PSK 应该影响密码套件的选择。</p><p>在接受PSK密钥建立之前，Server 必须先验证相应的 binder 值(见 <a target="_blank" rel="noopener" href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TLS_1.3_Handshake_Protocol.md#2-psk-binder">[4.2.11.2 节]</a>)。如果这个值不存在或着未验证，则 Server 必须立即中止握手。Server 不应该尝试去验证多个 binder，而应该选择单个 PSK 并且仅验证对应于该 PSK 的 binder。见 <a target="_blank" rel="noopener" href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TLS_1.3_Security_Properties.md#%E5%85%AD-psk-identity-exposure">Appendix E.6</a> 和 <a target="_blank" rel="noopener" href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TLS_1.3_0-RTT.md#%E4%BA%8C-client-hello-recording">[8.2 节]</a> 描述了针对这个要求的安全性解释。为了接受 PSK 密钥建立连接，Server 发送 “pre_shared_key” 扩展，标明它所选择的 identity。</p><p>Client 必须验证 Server 的 selected_identity 是否在 Client 提供的范围之内。Server 选择的加密套件标明了与 PSK 关联的哈希算法，如果 ClientHello “psk_key_exchange_modes” 有需要，Server 还应该发送 “key_share” 扩展。如果这些值不一致，Client 必须立即用 “illegal_parameter” alert 消息中止握手。</p><p>如果 Server 提供了 “early_data” 扩展，Client 必须验证 Server 的 selected_identity 是否为 0。如果返回任何其他值，Client 必须使用 “illegal_parameter” alert 消息中止握手。</p><p>“pre_shared_key” 扩展必须是 ClientHello 中的最后一个扩展(这有利于下面的描述的实现)。Server 必须检查它是最后一个扩展，否则用 “illegal_parameter” alert 消息中止握手。</p><h4 id="1-ticket-age"><a class="markdownIt-Anchor" href="#1-ticket-age"></a> (1) Ticket Age</h4><p>从 Client 的角度来看，ticket 的时间指的是，收到 NewSessionTicket 消息开始到当前时刻的这段时间。Client 决不能使用时间大于 ticket 自己标明的 “ticket_lifetime” 这个时间的 ticket。每个 PskIdentity 中的 “obfuscated_ticket_age” 字段都必须包含 ticket 时间的混淆版本，混淆方法是用 ticket 时间(毫秒为单位)加上 “ticket_age_add” 字段，最后对 2^32 取模。除非这个 ticket 被重用了，否则这个混淆就可以防止一些相关联连接的被动观察者。注意，NewSessionTicket 消息中的 “ticket_lifetime” 字段是秒为单位，但是 “obfuscated_ticket_age” 是毫秒为单位。因为 ticke lifetime 限制为一周，32 位就足够去表示任何合理的时间，即使是以毫秒为单位也可以表示。</p><h4 id="2-psk-binder"><a class="markdownIt-Anchor" href="#2-psk-binder"></a> (2) PSK Binder</h4><p>PSK binder 的值形成了 2 种绑定关系，一种是 PSK 和当前握手的绑定，另外一种是 PSK 产生以后(如果是通过 NewSessionTicket 消息)的握手和当前握手的绑定。每一个在 binder 列表中的条目都会根据有一部分 ClientHello 的哈希副本计算 HMAC，最终 HMAC 会包含 PreSharedKeyExtension.identities 字段。也就是说，HMAC 包含所有的 ClientHello，但是不包含 binder list 。如果存在正确长度的 binders，消息的长度字段（包括总长度，扩展块的长度和 “pre_shared_key” 扩展的长度）都被设置。</p><p>PskBinderEntry 的计算方法和 Finished 消息一样。但是 BaseKey 是派生的 binder_key，派生方式是通过提供的相应的 PSK 的密钥派生出来的。</p><p>如果握手包括 HelloRetryRequest 消息，则初始的 ClientHello 和 HelloRetryRequest 随着新的 ClientHello 一起被包含在副本中。例如，如果 Client 发送 ClientHello，则其 binder 将通过以下方式计算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Transcript-Hash(Truncate(ClientHello1))<br></code></pre></td></tr></table></figure><p>Truncate() 函数的作用是把 ClientHello 中的 binders list 移除。</p><p>如果 Server 响应了 HelloRetryRequest，那么 Client 会发送 ClientHello2，它的 binder 会通过以下方式计算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">Transcript-Hash(ClientHello1,<br>                HelloRetryRequest,<br>                Truncate(ClientHello2))<br></code></pre></td></tr></table></figure><p>完整的 ClientHello1/ClientHello2 都会包含在其他的握手哈希计算中。请注意，在第一次发送中，<code>Truncate(ClientHello1)</code> 是直接计算哈希的，但是在第二次发送中，ClientHello1 计算哈希，并且还会再注入一条 “message_hash” 消息。</p><h4 id="3-processing-order"><a class="markdownIt-Anchor" href="#3-processing-order"></a> (3) Processing Order</h4><p>Client 被允许流式的发送 0-RTT 数据，直到它收到 Server 的 Finished 消息。Client 收到 Finished 消息以后，需要在握手的末尾，发送 EndOfEarlyData 消息。为了防止死锁，当 Server 接收 “early_data” 消息的时候，Server 必须立即处理 Client 的 ClientHello 消息，然后立即回应 ServerHello，而不是等待收到 Client 的 EndOfEarlyData 消息以后再发送 ServerHello。</p><h2 id="三-server-parameters"><a class="markdownIt-Anchor" href="#三-server-parameters"></a> 三. Server Parameters</h2><p>Server 接下来的 2 条消息，EncryptedExtensions 和 CertificateRequest 消息，包含来自 Server 的消息，这个 Server 确定了握手的其余部分。这些消息是加密的，通过从 server_handshake_traffic_secret 中派生的密钥加密的。</p><h3 id="1-encrypted-extensions"><a class="markdownIt-Anchor" href="#1-encrypted-extensions"></a> 1. Encrypted Extensions</h3><p>在所有的握手中，Server 必须在 ServerHello 消息之后立即发送 EncryptedExtensions 消息。这是在从 server_handshake_traffic_secret 派生的密钥下加密的第一条消息。</p><p>EncryptedExtensions 消息包含应该被保护的扩展。即，任何不需要建立加密上下文但不与各个证书相互关联的扩展。Client 必须检查 EncryptedExtensions 消息中是否存在任何禁止的扩展，如果有发现禁止的扩展，必须立即用 “illegal_parameter” alert 消息中止握手。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">Structure of this message:<br><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>       Extension extensions&lt;<span class="hljs-number">0.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>   &#125; EncryptedExtensions;<br></code></pre></td></tr></table></figure><ul><li>extensions:<br>扩展列表。</li></ul><h3 id="2-certificate-request"><a class="markdownIt-Anchor" href="#2-certificate-request"></a> 2. Certificate Request</h3><p>使用证书进行身份验证的 Server 可以选择性的向 Client 请求证书，这条请求消息(如果发送了)要跟在 EncryptedExtensions 消息后面。</p><p>消息的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    opaque certificate_request_context&lt;<span class="hljs-number">0.</span><span class="hljs-number">.2</span>^<span class="hljs-number">8</span><span class="hljs-number">-1</span>&gt;;<br>    Extension extensions&lt;<span class="hljs-number">2.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>&#125; CertificateRequest;<br></code></pre></td></tr></table></figure><ul><li><p>certificate_request_context:<br>一个不透明的字符串，这个字符串用来标识证书请求，并在 Client 的 Certificate 消息中回显。certificate_request_context 必须在本次连接中必须是唯一的(从而防止 Client 的 CertificateVerify 重放攻击)。这个字段一般情况下都是 0 长度，除非用于 <a target="_blank" rel="noopener" href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TLS_1.3_Handshake_Protocol.md#2-post-handshake-authentication">[4.6.2]</a> 中描述的握手后身份验证交换。当请求握手后身份验证以后，Server 应该发送不可预测的上下文给 Client (例如，用随机数生成)，这样是为了防止攻击者破解。攻击者可以预先计算有效的 CertificateVerify 消息，从而获取临时的 Client 私钥的权限。</p></li><li><p>extensions:<br>一组描述正在请求的证书需要的参数扩展集。“signature_algorithms” 扩展必须是特定的，如果其他的扩展被这个消息所定义，那么其他扩展也可能可选的被包含进来。Client 必须忽略不能识别的扩展。</p></li></ul><p>在 TLS 1.3 之前的版本中，CertificateRequest 消息携带了签名算法列表和 Server 可接受的证书授权列表。在 TLS 1.3 中，签名算法列表可以通过 “signature_algorithms” 和可选的 “signature_algorithms_cert” 扩展来表示。而后者证书授权列表可以通过发送 “certificate_authorities” 扩展来表示。</p><p>通过 PSK 进行验证的 Server 不能在主握手中发送 CertificateRequest 消息，不过它们可能可以在握手后身份验证中发送 CertificateRequest 消息，前提是 Client 已经发送了 “post_handshake_auth” 扩展名。</p><h2 id="四-authentication-messages"><a class="markdownIt-Anchor" href="#四-authentication-messages"></a> 四. Authentication Messages</h2><p>正如我们在 <a target="_blank" rel="noopener" href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TLS_1.3.md#%E4%BA%94tls-13-%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%A7%88">section-2</a> 中讨论的，TLS 使用一组通用的消息用于身份验证，密钥确认和握手的正确性：Certificate, CertificateVerify 和 Finished。(PSK binders 也以类似的方式进行密钥确认)。这三条消息总是作为握手消息的最后三条消息。Certificate 和 CertificateVerify 消息如下面描述的那样，只在某些情况才会发送。Finished 的消息总是作为认证块的一部分发送。这些消息使用从 sender_handshake_traffic_secret 派生出来的密钥进行加密。</p><p>Authentication 消息的计算统一采用以下的输入方式：</p><ul><li>要使用证书和签名密钥</li><li>握手上下文由哈希副本中的一段消息集组成</li><li>Base key 用于计算 MAC 密钥</li></ul><p>基于这些输入，消息包含：</p><ul><li><p>Certificate：用于认证的证书和链中任何支持的证书。请注意，基于证书的 Client 身份验证在 PSK 握手流中不可用(包括 0-RTT)</p></li><li><p>CertificateVerify: 根据 Transcript-Hash(Handshake Context, Certificate)的值得出的签名</p></li><li><p>Finished: 根据 Transcript-Hash(Handshake Context, Certificate, CertificateVerify)的值得出的 MAC 。使用从 Base key 派生出来的 MAC key 计算的 MAC 值。</p></li></ul><p>对于每个场景，下表定义了握手上下文和 MAC Base Key</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">+-----------+-------------------------+-----------------------------+<br>| Mode      | Handshake Context       | Base Key                    |<br>+-----------+-------------------------+-----------------------------+<br>| Server    | ClientHello ... later   | server_handshake_traffic_   |<br>|           | of EncryptedExtensions/ | secret                      |<br>|           | CertificateRequest      |                             |<br>|           |                         |                             |<br>| Client    | ClientHello ... later   | client_handshake_traffic_   |<br>|           | of server               | secret                      |<br>|           | Finished/EndOfEarlyData |                             |<br>|           |                         |                             |<br>| Post-     | ClientHello ... client  | client_application_traffic_ |<br>| Handshake | Finished +              | secret_N                    |<br>|           | CertificateRequest      |                             |<br>+-----------+-------------------------+-----------------------------+<br></code></pre></td></tr></table></figure><h3 id="1-the-transcript-hash"><a class="markdownIt-Anchor" href="#1-the-transcript-hash"></a> 1. The Transcript Hash</h3><p>TLS 中的许多加密计算都使用了哈希副本。这个值是通过级联每个包含的握手消息的方式进来哈希计算的，它包含握手消息头部携带的握手消息类型和长度字段，但是不包括记录层的头部。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Transcript-Hash(M1, M2, ... Mn) = Hash(M1 || M2 || ... || Mn)<br></code></pre></td></tr></table></figure><p>作为此一般规则的例外，当 Server 用一条 HelloRetryRequest 消息来响应一条 ClientHello 消息时，ClientHello1 的值替换为包含 Hash(ClientHello1）的握手类型为 “message_hash” 的特殊合成握手消息。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">Transcript-Hash(ClientHello1, HelloRetryRequest, ... Mn) =<br>    Hash(message_hash ||        <span class="hljs-comment">/* Handshake type */</span><br>         <span class="hljs-number">00</span> <span class="hljs-number">00</span> Hash.length  ||  <span class="hljs-comment">/* Handshake message length (bytes) */</span><br>         Hash(ClientHello1) ||  <span class="hljs-comment">/* Hash of ClientHello1 */</span><br>         HelloRetryRequest  || ... || Mn)<br></code></pre></td></tr></table></figure><p>设计这种结构的原因是允许 Server 通过在 cookie 中仅存储 ClientHello1 的哈希值来执行无状态 HelloRetryRequest，而不是要求它导出整个中间哈希状态。</p><p>具体而言，哈希副本始终取自于下列握手消息序列，从第一个 ClientHello 开始，仅包括已发送的消息：ClientHello, HelloRetryRequest, ClientHello, ServerHello, EncryptedExtensions, server CertificateRequest, server Certificate, server CertificateVerify, server Finished, EndOfEarlyData, client Certificate, client CertificateVerify, client Finished。</p><p>通常上，实现方可以下面的方法来实现哈希副本：根据协商的哈希来维持一个动态的哈希副本。请注意，随后的握手后认证不会相互包含，只是通过主握手结束的消息。</p><h3 id="2-certificate"><a class="markdownIt-Anchor" href="#2-certificate"></a> 2. Certificate</h3><p>此消息将端点的证书链发给对端。</p><p>每当约定的密钥交换方法是用证书进行认证(这包括本文档中除了 PSK 以外定义的所有密钥交换方法)的时候，Server 就必须发送 Certificate 消息。</p><p>当且仅当 Server 通过发送 CertificateRequest 消息请求 Client 认证时，Client 必须发送 Certificate 消息。</p><p>如果 Server 请求 Client 认证但没有合适的证书可用，则 Client 必须发送不包含证书的证书消息(例如，具有长度为 0 的 “certificate_list” 字段)。Finished 消息必须发送，无论 Certificate 消息是否为空。</p><p>Certificate 消息的结构体是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    X509(<span class="hljs-number">0</span>),<br>    RawPublicKey(<span class="hljs-number">2</span>),<br>    (<span class="hljs-number">255</span>)<br>&#125; CertificateType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    select (certificate_type) &#123;<br>        <span class="hljs-keyword">case</span> RawPublicKey:<br>          <span class="hljs-comment">/* From RFC 7250 ASN.1_subjectPublicKeyInfo */</span><br>          opaque ASN1_subjectPublicKeyInfo&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">24</span><span class="hljs-number">-1</span>&gt;;<br><br>        <span class="hljs-keyword">case</span> X509:<br>          opaque cert_data&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">24</span><span class="hljs-number">-1</span>&gt;;<br>    &#125;;<br>    Extension extensions&lt;<span class="hljs-number">0.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>&#125; CertificateEntry;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    opaque certificate_request_context&lt;<span class="hljs-number">0.</span><span class="hljs-number">.2</span>^<span class="hljs-number">8</span><span class="hljs-number">-1</span>&gt;;<br>    CertificateEntry certificate_list&lt;<span class="hljs-number">0.</span><span class="hljs-number">.2</span>^<span class="hljs-number">24</span><span class="hljs-number">-1</span>&gt;;<br>&#125; Certificate;<br></code></pre></td></tr></table></figure><ul><li><p>certificate_request_context:<br>如果此消息是响应 CertificateRequest 消息的，则该消息中的 certificate_request_context 的值不为 0。否则(在 Server 认证的情况下)，该字段应为零长度。</p></li><li><p>certificate_list:<br>这是一个 CertificateEntry 结构的序列(链)，每个结构包含单个证书和一组扩展。</p></li><li><p>extensions:<br>CertificateEntry 的一组扩展值。“Extension” 的格式在 <a target="_blank" rel="noopener" href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TLS_1.3_Handshake_Protocol.md#%E4%BA%8C-extensions">[Section 4.2]</a> 中定义了。有效的扩展包括 OCSP 状态扩展 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6066">[RFC6066]</a> 和 SignedCertificateTimestamp <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6962">[RFC6962]</a> 扩展。未来可以为此消息定义一些新的扩展。Server 的 Certificate 消息中的扩展必须对应于 ClientHello 消息中的扩展。Client 的 Certificate 消息中的扩展必须对应于 Server 的 CertificateRequest 消息中的扩展。如果一个扩展适应用于整个链，它应该被包括在第一个 CertificateEntry 中。</p></li></ul><p>如果没有在 EncryptedExtensions 中协商相应的证书类型扩展名 (“server_certificate_type” 或 “client_certificate_type”)，或者协商了 X.509 证书类型，则每个 CertificateEntry 都要包含 DER 编码的 X.509 证书。发件者的证书必须位于列表中的第一个 CertificateEntry 中。之后的每个证书都应该直接证明其前面的证书。由于证书验证要求信任锚独立分发，因此可以从链中省略指定信任锚的证书(前提是已知支持的对等方拥有可省略的证书)。</p><p>注意：TLS 1.3 之前的版本，“certificate_list” 排序需要每个证书要证明紧接在其前面的证书，然而，一些实现允许一些灵活性。Server 有时为了过渡的目的而发送当前和已弃用的中间体，而其他的配置不正确，但这些情况仍然可以正确地验证。为了最大程度的兼容性，所有实现应该准备处理可能是无关紧要的证书和 TLS 版本的任意排序，但最终实体证书(排序的顺序)必须是第一个。</p><p>如果协商了 RawPublicKey 证书类型，则 certificate_list 必须包含不超过一个CertificateEntry，CertificateEntry 中包含定义在 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7250#section-3">[RFC7250], Section 3</a> 中的 ASN1_subjectPublicKeyInfo 值。</p><p>OpenPGP 证书类型禁止在 TLS 1.3 中使用。</p><p>Server 的 certificate_list 必须始终是非空的。如果 Client 没有适当的证书要发送以响应 Server 的身份验证请求，则会发送空的 certificate_list。</p><h4 id="1-ocsp-status-and-sct-extensions"><a class="markdownIt-Anchor" href="#1-ocsp-status-and-sct-extensions"></a> (1) OCSP Status and SCT Extensions</h4><p><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6066">[RFC6066]</a> 和 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6961">[RFC6961]</a> 提供了协商 Server 向 Client 发送 OCSP 响应的扩展。 在 TLS 1.2 及以下版本中，Server 回复空的扩展名以表示对此扩展的协商，并且在 CertificateStatus 消息中携带 OCSP 信息。在 TLS 1.3 中，Server 的 OCSP 信息在包含相关证书的 CertificateEntry 中的扩展中。特别的，来自 Server 的 “status_request” 扩展的主体必须是分别在 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6066">[RFC6066]</a> 和 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6960">[RFC6960]</a> 中定义的 CertificateStatus 结构。</p><p>注意：status_request_v2 扩展 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6961">[RFC6961]</a> 已经废弃了，TLS 1.3 不能根据它是否存在或者根据它的信息来出来 ClientHello 消息。特别是，禁止在 EncryptedExtensions, CertificateRequest 和 Certificate 消息中发送 status_request_v2 扩展。TLS 1.3 的 Server 必须要能够处理包含它的 ClientHello 消息，因为这条消息可能是由希望在早期协议版本中使用它的 Client 发送的。</p><p>Server 可以通过在其 CertificateRequest 消息中发送空的 “status_request” 扩展来请求 Client 使用其证书来做 OCSP 的响应。如果 Client 选择性的发送 OCSP 响应，则其 “status_request” 扩展的主体必须是在 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6966">[RFC6966]</a> 中定义的 CertificateStatus 结构。</p><p>类似地，<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6962">[RFC6962]</a> 为 Server 提供了一种机制，用在 TLS 1.2 及更低版本中的，可在 ServerHello 中发送签名证书时间戳 (SCT) 的扩展。 在 TLS 1.3 中，Server 的 SCT 信息在 CertificateEntry 的扩展中。</p><h4 id="2-server-certificate-selection"><a class="markdownIt-Anchor" href="#2-server-certificate-selection"></a> (2) Server Certificate Selection</h4><p>以下规则适用于 Server 发送的证书:</p><ul><li><p>证书类型必须是 X.509v3 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5280">[RFC5280]</a>，除非另有明确协商（例如，<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5081">[RFC5081]</a>）</p></li><li><p>Server 的终端实体证书的公钥（和相关限制）必须与 Client的 “signature_algorithms” 扩展(目前为RSA，ECDSA 或 EdDSA)中的所选认证算法兼容。</p></li><li><p>证书必须允许密钥用于签名（即，如果存在密钥用法扩展，则必须设置 digitalSignature 位），并在 Client 的&quot;signature_algorithms&quot;/“signature_algorithms_cert” 扩展中指示签名方案。</p></li><li><p>“server_name” <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6066">[RFC6066]</a> 和 “certificate_authorities” 扩展用于指导证书选择。由于 Server 可能需要存在 “server_name” 扩展名，因此 Client 应该在适用时发送此扩展名。</p></li></ul><p>如果 Server 能够提供证书链，Server 所有的证书都必须由 Client 提供的签名算法签名。自签名的证书或预期为信任锚的证书不会作为链的一部分进行验证，因此可以使用任何算法进行签名。</p><p>如果 Server 不能产生只通过所指示的支持的算法签名的证书链，则它应当通过向 Client 发送其选择的证书链来继续握手，该证书链可能会包括 Client 不知道能否支持的算法。这个回退链可以只在 Client 允许的情况下才可以使用已弃用的 SHA-1 哈希算法，其他情况都必须禁止使用 SHA-1 哈希算法。</p><p>如果 Client 无法使用提供的证书构造可接受的证书链，那么必须中止握手。中止握手并发送证书相关的 alert 消息(默认的，发送 “unsupported_certificate” alert 消息)</p><p>如果 Server 有多张证书，它会根据上述标准(除了其他标准以外，如传输层端点，本地配置和首选项)选择其中的一个证书。</p><h4 id="3-client-certificate-selection"><a class="markdownIt-Anchor" href="#3-client-certificate-selection"></a> (3) Client Certificate Selection</h4><p>以下的规则适用于 Client 发送的证书:</p><ul><li><p>证书类型必须是 X.509v3 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5280">[RFC5280]</a>，除非另有明确协商（例如，<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5081">[RFC5081]</a>）</p></li><li><p>如果 CertificateRequest 消息中 “certificate_authorities” 扩展不为空，则证书链中的至少一个证书应该由所列出的 CA 之一发布的。</p></li><li><p>证书必须使用可接受的签名算法签名，如第 4.3.2 节所述。注意，这放宽了在 TLS 的先前版本中发现的证书签名算法的约束。</p></li><li><p>如果 CertificateRequest 消息包含非空的 “oid_filters” 扩展，则终端实体证书必须匹配 Client 识别的扩展 OID，如第 4.2.5 节中所述。</p></li></ul><h4 id="4-receiving-a-certificate-message"><a class="markdownIt-Anchor" href="#4-receiving-a-certificate-message"></a> (4) Receiving a Certificate Message</h4><p>通常，详细的证书验证程序超出了 TLS 的范围(参见<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5280">[RFC5280]</a>)。 本节提供特定于 TLS 的要求。</p><p>如果 Server 提供空的证书消息，则 Client 必须使用 “decode_error” alert 消息中止握手。</p><p>如果 Client 没有发送任何证书(即，它发送一个空的证书消息)，Server 可以自行决定是否在没有 Client 认证的情况下继续握手，或者使用 “certificate_required” alert 消息中止握手。此外，如果证书链的某些方面是不可接受的(例如，它未由已知的可信 CA 签名)，则 Server 可以自行决定是继续握手(考虑 Client 还没有经过身份验证)还是中止握手。</p><p>任何端点接收任何需要使用任何签名算法使用 MD5 哈希验证的证书都必须使用 “bad_certificate” alert 消息中止握手。不推荐使用 SHA-1，并且建议任何接收任何使用 SHA-1 哈希使用任何签名算法验证的证书的端点都会使用 “bad_certificate” alert 消息中止握手。为清楚起见，这意味着端点可以接受这些算法用于自签名或信任锚的证书。</p><p>建议所有端点尽快转换为 SHA-256 或更好的算法，以保持与当前正在逐步淘汰 SHA-1 支持的实现的互操作性。</p><p>请注意，包含一个签名算法的密钥的证书可以使用不同的签名算法进行签名(例如，使用 ECDSA 密钥签名的 RSA 密钥)。</p><h3 id="3-certificate-verify"><a class="markdownIt-Anchor" href="#3-certificate-verify"></a> 3. Certificate Verify</h3><p>此消息用于提供端点拥有与其证书对应的私钥的明确证据。CertificateVerify 消息还为到此为止的握手提供完整性。Server 必须在通过证书进行身份验证时发送此消息。每当通过证书进行身份验证时(即，当证书消息非空时)，Client 必须发送此消息。发送时，此消息必须在 Certificate 消息之后立即出现，并且紧接在 Finished 消息之前。</p><p>这条消息的结构体是:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    SignatureScheme algorithm;<br>    opaque signature&lt;<span class="hljs-number">0.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>&#125; CertificateVerify;<br></code></pre></td></tr></table></figure><p>algorithm 字段指定使用的签名算法(有关此类型的定义，请参见第 4.2.3 节)。signature 字段是使用该算法的数字签名。签名中涵盖的内容是第 4.4.1 节中描述的哈希输出，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Transcript-Hash(Handshake Context, Certificate)<br></code></pre></td></tr></table></figure><p>计算数字签名是级联计算的：</p><ul><li>由八位字节32(0x20)组成的字符串重复 64 次</li><li>上下文字符串</li><li>用作分隔符的单个0字节</li><li>要签名的内容</li></ul><p>设计这个结构目的是为了防止对先前版本的 TLS 的攻击，其中 ServerKeyExchange 格式意味着攻击者可以获得具有所选 32 字节前缀(ClientHello.random)的消息的签名。 最初的 64 字节填充将清除 Server 控制的 ServerHello.random 中的前缀。</p><p>Server 签名的上下文字符串是 “TLS 1.3，Server CertificateVerify”。Client 签名的上下文字符串是 “TLS 1.3，Client CertificateVerify”。它用于在不同的上下文中提供签名之间的分离，帮助抵御潜在的跨协议攻击。</p><p>例如，如果 hash副本 是 32 字节 01(这个长度对 SHA-256 有意义)，Server 的 CertificateVerify 的数字签名所涵盖的内容将是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">2020202020202020202020202020202020202020202020202020202020202020</span><br><span class="hljs-number">2020202020202020202020202020202020202020202020202020202020202020</span><br><span class="hljs-number">544</span>c5320312e332c207365727665722043657274696669636174655665726966<br><span class="hljs-number">79</span><br><span class="hljs-number">00</span><br><span class="hljs-number">0101010101010101010101010101010101010101010101010101010101010101</span><br></code></pre></td></tr></table></figure><p>在发送方，用于计算 CertificateVerify 消息的签名字段的过程作为输入:</p><ul><li><p>数字签名算涵盖的内容</p></li><li><p>与上一条消息中发送的证书对应的私有签名密钥</p></li></ul><p>如果由 Server 发送 CertificateVerify 消息，则签名算法必须是 Client “signature_algorithms” 扩展中提供的，除非在没有不支持的算法的情况下不能生成有效的证书链(除非当前支持的算法都不能生成有效的证书链)。</p><p>如果由 Client 发送，则签名中使用的签名算法必须是 CertificateRequest 消息中 “signature_algorithms” 扩展的 supported_signature_algorithms 字段中存在的签名算法之一。</p><p>另外，签名算法必须与发送者的终端实体证书中的密钥兼容。无论 RSASSA-PKCS1-v1_5 算法是否出现在 “signature_algorithms” 中，RSA 签名都必须使用 RSASSA-PSS 算法。SHA-1 算法禁止用于 CertificateVerify 消息的任何签名。</p><p>本规范中的所有 SHA-1 签名算法仅定义用于旧证书，并且对 CertificateVerify 签名无效。</p><p>CertificateVerify 消息的接收者必须验证签名字段。验证过程作为输入：</p><ul><li><p>数字签名所涵盖的内容</p></li><li><p>在关联的证书消息中找到的最终实体证书中包含的公钥</p></li><li><p>在 CertificateVerify 消息的签名字段中收到的数字签名</p></li></ul><p>如果验证失败，接收方必须通过 “decrypt_error” 警报终止握手。</p><h3 id="4-finished"><a class="markdownIt-Anchor" href="#4-finished"></a> 4. Finished</h3><p>Finished 消息是认证块中的最后一条消息。它对提供握手和计算密钥的身份验证起了至关重要的作用。</p><p>Finished 消息的收件人必须验证内容是否正确，如果不正确，必须使用 “decrypt_error” alert 消息终止连接。</p><p>一旦一方已发送其 Finished 消息并已收到并验证来自其对端的 Finished 消息，它就可以开始通过该连接发送和接收应用数据。有两种设置允许在接收对端的 Finished 之前发送数据:</p><ol><li>如 <a target="_blank" rel="noopener" href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TLS_1.3_Handshake_Protocol.md#10-early-data-indication">Section 4.2.10</a> 中所述，Client 可以发送 0-RTT 数据。</li><li>Server 可以在第一个 flight 之后就发送数据，但是因为握手还没有完成，所以不能保证对端的身份正确性，以及对端是否还在线。(ClientHello 可能重播)</li></ol><p>用于计算 Finished 消息的密钥是使用 HKDF，它是从第 4.4 节中定义的 Base Key 计算而来的(参见第7.1节)。特别的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">finished_key =<br>    HKDF-Expand-Label(BaseKey, <span class="hljs-string">&quot;finished&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, Hash.length)<br></code></pre></td></tr></table></figure><p>这条消息的数据结构是:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    opaque verify_data[Hash.length];<br>&#125; Finished;<br></code></pre></td></tr></table></figure><p>verify_data 按照如下方法计算:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">verify_data =<br>    HMAC(finished_key,<br>         Transcript-Hash(Handshake Context,<br>                         Certificate*, CertificateVerify*))<br><br>* Only included <span class="hljs-keyword">if</span> present.<br></code></pre></td></tr></table></figure><p>HMAC <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2104">[RFC2104]</a> 使用哈希算法进行握手。如上所述，HMAC 输入通常是通过动态的哈希实现的，即，此时仅是握手的哈希。</p><p>在以前版本的 TLS 中，verify_data 的长度总是 12 个八位字节。在 TLS 1.3中，它是用来表示握手的哈希的 HMAC 输出的大小。</p><p><strong>注意：警报和任何其他非握手记录类型不是握手消息，并且不包含在哈希计算中</strong>。</p><p>Finished 消息之后的任何记录都必须在适当的应用程序流量密钥下加密，如第 7.2 节所述。特别是，这包括 Server 为了响应 Client 的 Certificate 消息和 CertificateVerify 消息而发送的任何 alert。</p><h3 id="5-end-of-early-data"><a class="markdownIt-Anchor" href="#5-end-of-early-data"></a> 5. End of Early Data</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>&#125; EndOfEarlyData;<br></code></pre></td></tr></table></figure><p>如果 Server 在 EncryptedExtensions 中发送了 “early_data” 扩展，则 Client 必须在收到 Server 的 Finished 消息后发送 EndOfEarlyData 消息。 如果 Server 没有在 EncryptedExtensions中发送 “early_data” 扩展，那么 Client 绝不能发送 EndOfEarlyData 消息。此消息表示已传输完了所有 0-RTT application_data消息(如果有)，并且接下来的记录受到握手流量密钥的保护。Server 不能发送此消息，Client 如果收到了这条消息，那么必须使用 “unexpected_message” alert 消息终止连接。这条消息使用从 client_early_traffic_secret 中派生出来的密钥进行加密保护。</p><h3 id="6-post-handshake-messages"><a class="markdownIt-Anchor" href="#6-post-handshake-messages"></a> 6. Post-Handshake Messages</h3><p>TLS 还允许在主握手后发送其他的消息。这些消息使用握手内容类型，并使用适当的应用程序流量密钥进行加密。</p><h4 id="1-new-session-ticket-message"><a class="markdownIt-Anchor" href="#1-new-session-ticket-message"></a> (1) New Session Ticket Message</h4><p>在 Server 接收到 Client 的 Finished 消息以后的任何时刻，它都可以发送 NewSessionTicket 消息。此消息在 ticket 值和从恢复主密钥派生出来的 PSK 之间创建了唯一的关联。</p><p>Client 在 ClientHello 消息中包含 “pre_shared_key” 扩展，并在扩展中包含 ticket ，那么 Client 就可能在未来的握手中使用 PSK。Server 可能在一个连接中发送多个 ticket，发送时机可能是一个接一个的立即发送，也可能是在某个特定事件以后发送。例如，Server 可能会在握手后身份验证之后发送新的 ticket，以封装其他 Client 身份验证状态。多个 ticket 对于 Client 来说，可用于各种目的，例如：</p><ul><li><p>打开多个并行的 HTTP 连接</p></li><li><p>通过(例如) Happy Eyeballs <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8305">[RFC8305]</a> 或相关的技术在接口和地址簇上进行连接竞争</p></li></ul><p>任何 ticket 必须只能使用与用于建立原始连接的 KDF 哈希算法相同的密码套件来恢复会话。</p><p>Client 必须只有在新的 SNI 值对原始会话中提供的 Server 证书有效时才能恢复，并且只有在 SNI 值与原始会话中使用的 SNI 值匹配时才应恢复。后者是性能优化：通常，没有理由期望单个证书所涵盖的不同 Server 之间能够相互接受彼此的 ticket；因此，在这种情况下尝试恢复会话将会浪费一次性的 ticket。如果提供了这种指示(外部或通过任何其他方式)，则 Client 可能可以使用不同的 SNI 值进行恢复会话。</p><p>在恢复会话时，如果向调用的应用程序报告 SNI 值，则实现方必须使用在恢复 ClientHello 中发送的值而不是在先前会话中发送的值。请注意，如果 Server 的实现拒绝了不同 SNI 值的所有 PSK 标识，则这两个值总是相同。</p><p>注意：虽然恢复主密钥取决于 Client 的第二次 flight，但是不请求 Client 身份验证的 Server 可以独立计算转录哈希的剩余部分，然后在发送 Finished 消息后立即发送 NewSessionTicket 而不是等待 Client 的 Finished 消息。这可能适用于 Client 需要并行打开多个 TLS 连接并且可以从减少恢复握手的开销中受益的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    uint32 ticket_lifetime;<br>    uint32 ticket_age_add;<br>    opaque ticket_nonce&lt;<span class="hljs-number">0.</span><span class="hljs-number">.255</span>&gt;;<br>    opaque ticket&lt;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-1</span>&gt;;<br>    Extension extensions&lt;<span class="hljs-number">0.</span><span class="hljs-number">.2</span>^<span class="hljs-number">16</span><span class="hljs-number">-2</span>&gt;;<br>&#125; NewSessionTicket;<br></code></pre></td></tr></table></figure><ul><li><p>ticket_lifetime：<br>这个字段表示 ticket 的生存时间，这个时间是以 ticket 发布时间为网络字节顺序的 32 位无符号整数表示以秒为单位的时间。Server 禁止使用任何大于604800秒(7天)的值。值为零表示应立即丢弃 ticket。无论 ticket_lifetime 如何，Client 都不得缓存超过7天的 ticket，并且可以根据本地策略提前删除 ticket。Server 可以将 ticket 视为有效的时间段短于 ticket_lifetime 中所述的时间段。</p></li><li><p>ticket_age_add:<br>安全的生成的随机 32 位值，用于模糊 Client 在 “pre_shared_key” 扩展中包含的 ticket 的时间。Client 的 ticket age 以模 2 ^ 32 的形式添加此值，以计算出 Client 要传输的值。Server 必须为它发出的每个 ticket 生成一个新值。</p></li><li><p>ticket_nonce:<br>每一个 ticket 的值，在本次连接中发出的所有的 ticket 中是唯一的。</p></li><li><p>ticket:<br>这个值是被用作 PSK 标识的值。ticket 本身是一个不透明的标签。它可以是数据库查找键，也可以是自加密和自我验证的值。</p></li><li><p>extensions：<br>ticket 的一组扩展值。扩展格式在 4.2 节中定义的。Client 必须忽略无法识别的扩展。</p></li></ul><p>当前为 NewSessionTicket 定义的唯一扩展名是 “early_data”，表示该 ticket 可用于发送 0-RTT 数据(第4.2.10节)。 它包含以下值：</p><ul><li>max_early_data_size:<br>这个字段表示使用 ticket 时允许 Client 发送的最大 0-RTT 数据量(以字节为单位)。数据量仅计算应用数据有效载荷(即，明文但不填充或内部内容类型字节)。Server 如果接收的数据大小超过了 max_early_data_size 字节的 0-RTT 数据，应该立即使用 “unexpected_message” alert 消息终止连接。请注意，由于缺少加密材料而拒绝 early data 的 Server 将无法区分内容中的填充部分，因此 Client 不应该依赖于能够在 early data 记录中发送大量填充内容。</li></ul><p>PSK 关联的 ticket 计算方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">HKDF-Expand-Label(resumption_master_secret,<br>                 <span class="hljs-string">&quot;resumption&quot;</span>, ticket_nonce, Hash.length)<br></code></pre></td></tr></table></figure><p>因为 ticket_nonce 值对于每个 NewSessionTicket 消息都是不同的，所以每个 ticket 会派生出不同的 PSK。</p><p>请注意，原则上可以继续发布新 ticket，该 ticket 无限期地延长生命周期，这个生命周期是最初从初始非 PSK 握手中(最可能与对等证书相关联)派生得到的密钥材料的生命周期。</p><p>建议实现方对密钥材料这些加上总寿命时间的限制。这些限制应考虑到对等方证书的生命周期，干预撤销的可能性以及自从对等方在线 CertificateVerify 签名到当前时间的这段时间。</p><h4 id="2-post-handshake-authentication"><a class="markdownIt-Anchor" href="#2-post-handshake-authentication"></a> (2) Post-Handshake Authentication</h4><p>当 Client 发送了 “post_handshake_auth” 扩展(参见第4.2.6节)时，Server 可以在握手完成后随时通过发送 CertificateRequest 消息来请求客户端身份验证。Client 必须使用适当的验证消息进行响应(参见第4.4节)。如果 Client 选择进行身份验证，则必须发送 Certificate，CertificateVerify，Finished 消息。如果 Client 拒绝身份验证，它必须发送一个 Certificate 证书消息，其中不包含证书，然后是 Finished 消息。响应 Server 的所有 Client 消息必须连续出现在线路上，中间不能有其他类型的消息。</p><p>在没有发送 “post_handshake_auth” 扩展的情况下接收 CertificateRequest 消息的 Client 必须发送 “unexpected_message” alert 消息。</p><p>注意：由于 Client 身份验证可能涉及提示用户，因此 Server 必须做好一些延迟的准备，包括在发送 CertificateRequest 和接收响应之间接收任意数量的其他消息。此外，Client 如果连续接收到了多个 CertificateRequests 消息，Client 可能会以不同于它们的顺序响应它们(certificate_request_context 值允许服务器消除响应的歧义)</p><h4 id="3-key-and-initialization-vector-update"><a class="markdownIt-Anchor" href="#3-key-and-initialization-vector-update"></a> (3) Key and Initialization Vector Update</h4><p>KeyUpdate 握手消息用于表示发送方正在更新其自己的发送加密密钥。任何对等方在发送 Finished 消息后都可以发送此消息。在接收 Finished 消息之前接收 KeyUpdate 消息的，实现方必须使用 “unexpected_message” alert 消息终止连接。发送 KeyUpdate 消息后，如第 7.2 节所描述的计算方法，发送方应使用新一代的密钥发送其所有流量。收到 KeyUpdate 后，接收方必须更新其接收密钥。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    update_not_requested(<span class="hljs-number">0</span>), update_requested(<span class="hljs-number">1</span>), (<span class="hljs-number">255</span>)<br>&#125; KeyUpdateRequest;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    KeyUpdateRequest request_update;<br>&#125; KeyUpdate;<br></code></pre></td></tr></table></figure><ul><li>request_update:<br>这个字段表示 KeyUpdate 的收件人是否应使用自己的 KeyUpdate 进行响应。 如果实现接收到任何其他的值，则必须使用 “illegal_parameter” alert 消息终止连接。</li></ul><p>如果 request_update 字段设置为 “update_requested”，则接收方必须在发送其下一个应用数据记录之前发送自己的 KeyUpdate，其中 request_update 设置为 “update_not_requested”。此机制允许任何一方强制更新整个连接，但会导致一个实现方接收多个 KeyUpdates，并且它还是静默的响应单个更新。请注意，实现方可能在发送 KeyUpdate (把 request_update 设置为 “update_requested”) 与接收对等方的 KeyUpdate 之间接收任意数量的消息，因为这些消息可能早就已经在传输中了。但是，由于发送和接收密钥是从独立的流量密钥中导出的，因此保留接收流量密钥并不会影响到发送方更改密钥之前发送的数据的前向保密性。</p><p>如果实现方独立地发送它们自己的 KeyUpdates，其 request_update 设置为 “update_requested” 并且它们的消息都是传输中，结果是双方都会响应，双方都会更新密钥。</p><p>发送方和接收方都必须使用旧密钥加密其 KeyUpdate 消息。另外，在接受使用新密钥加密的任何消息之前，双方必须强制接收带有旧密钥的 KeyUpdate。如果不这样做，可能会引起消息截断攻击。</p><hr><h1 id="记录协议"><a class="markdownIt-Anchor" href="#记录协议"></a> 记录协议</h1><p>TLS 记录协议接收要传输的消息，将数据分段为可管理的块，保护记录并传输结果。收到的数据经过验证，解密，重新组装，然后交付给更上层的协议。</p><p>TLS 记录允许同一层记录层上复用多个更高层的协议。本文档指定了 4 种内容类型：handshake，application_data，alert 和 change_cipher_spec。change_cipher_spec 记录仅用于兼容性目的。</p><p>实现方可能会在发送或接收第一个 ClientHello 消息之后，和，在接收到对等方的 Finished 消息之前的任何时间接收由单字节值 0x01 组成的未加密的类型 change_cipher_spec 的记录，如果接收到了这种记录，则必须简单地丢弃它而不进行进一步处理。请注意，此记录可能出现在握手中，这时候实现方是期望保护记录的，因此有必要在尝试对记录进行去除保护之前检测此情况。接收到任何其他 change_cipher_spec 值或接收到受保护的 change_cipher_spec 记录的实现方必须使用 “unexpected_message” alert 消息中止握手。如果实现方检测到在第一个 ClientHello 消息之前或在对等方的 Finished 消息之后收到的 change_cipher_spec 记录，则必须将其视为意外记录类型(尽管无状态的 Server 可能无法将这些情况与允许的情况区分开)</p><p>除非协商了某些扩展，否则实现方绝不能发送本文档中未定义的记录类型。如果 TLS 实现方收到意外的记录类型，它必须使用 “unexpected_message” alert 消息终止连接。新记录内容类型值由 IANA 在 TLS ContentType 注册表中分配，具体见第 11 节。</p><h2 id="一-record-layer"><a class="markdownIt-Anchor" href="#一-record-layer"></a> 一. Record Layer</h2><p>记录层将信息块分段为 TLSPlaintext 记录，TLSPlaintext 中包含 2^14 字节或更少字节块的数据。根据底层 ContentType 的不同，消息边界的处理方式也不同。任何未来的新增的内容类型必须指定适当的规则。请注意，这些规则比 TLS 1.2 中强制执行的规则更加严格。</p><p>握手消息可以合并为单个 TLSPlaintext 记录，或者在几个记录中分段，前提是：</p><ul><li><p>握手消息不得与其他记录类型交错。也就是说，如果握手消息被分成两个或多个记录，则它们之间不能有任何其他记录。</p></li><li><p>握手消息绝不能跨越密钥更改。实现方必须验证密钥更改之前的所有消息是否与记录边界对齐; 如果没有，那么他们必须用 “unexpected_message” alert 消息终止连接。因为 ClientHello，EndOfEarlyData，ServerHello，Finished 和 KeyUpdate 消息可以在密钥更改之前立即发生，所以实现方必须将这些消息与记录边界对齐。</p></li></ul><p>实现方绝不能发送握手类型的零长度片段，即使这些片段包含填充。</p><p>Alert 消息禁止在记录之间进行分段，并且多条 alert 消息不得合并为单个 TLSPlaintext 记录。换句话说，具有 alert 类型的记录必须只包含一条消息。</p><p>应用数据消息包含对 TLS 不透明的数据。应用数据消息始终受到保护。可以发送应用数据的零长度片段，因为它们可能作为流量分析对策使用。应用数据片段可以拆分为多个记录，也可以合并为一个记录。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    invalid(<span class="hljs-number">0</span>),<br>    change_cipher_spec(<span class="hljs-number">20</span>),<br>    alert(<span class="hljs-number">21</span>),<br>    handshake(<span class="hljs-number">22</span>),<br>    application_data(<span class="hljs-number">23</span>),<br>    (<span class="hljs-number">255</span>)<br>&#125; ContentType;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ContentType type;<br>    ProtocolVersion legacy_record_version;<br>    uint16 length;<br>    opaque fragment[TLSPlaintext.length];<br>&#125; TLSPlaintext;<br></code></pre></td></tr></table></figure><ul><li><p>type:<br>用于处理封闭片段的更高级协议。</p></li><li><p>legacy_record_version:<br>对于除初始 ClientHello 之外的 TLS 1.3 实现生成的所有记录(即，在 HelloRetryRequest 之后未生成的记录)，必须将其设置为 0x0303，其中出于兼容性目的，它也可以是0x0301。该字段已弃用，必须忽略它。在某些情况下，以前版本的 TLS 将在此字段中使用其他值。</p></li><li><p>length:<br>TLSPlaintext.fragment 的长度(以字节为单位)。长度不得超过 2 ^ 14 字节。接收超过此长度的记录的端点必须使用 “record_overflow” alert 消息终止连接。</p></li><li><p>fragment:<br>正在传输的数据。此字段的值是透明的，它并被视为一个独立的块，由类型字段指定的更高级别协议处理。</p></li></ul><p>本文档描述了使用版本 0x0304 的 TLS 1.3。此版本的值是历史的，源自对 TLS 1.0 使用 0x0301 和对 SSL 3.0 使用 0x0300。为了最大化向后兼容性，包含初始 ClientHello 的记录应该具有版本 0x0301(对应 TLS 1.0)，包含第二个 ClientHello 或 ServerHello 的记录必须具有版本 0x0303(对应 TLS 1.2)。在协商 TLS 的早期版本时，端点需要遵循附录 D 中提供的过程和要求。</p><p>当尚未使用记录保护时，TLSPlaintext 结构是直接写入传输线路中的。一旦记录保护开始，TLSPlaintext 记录将受到保护并按照下节部分描述的那样进行发送。请注意，应用数据记录不得写入未受保护的连接中。(有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TLS_1.3.md#%E4%BA%94tls-13-%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%A7%88">第 2 节</a>)</p><h2 id="二-record-payload-protection"><a class="markdownIt-Anchor" href="#二-record-payload-protection"></a> 二. Record Payload Protection</h2><p>记录保护功能将 TLSPlaintext 结构转换为 TLSCiphertext 结构。去除保护功能和保护功能互为逆过程。在 TLS 1.3 中，与先前版本的 TLS 相反，所有密码都是“具有关联数据的认证加密”(AEAD)<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5116">[RFC5116]</a>。 AEAD 功能提供统一的加密和认证操作，将明文转换为经过认证的密文，然后再返回。每个加密记录由一个明文标题后跟一个加密的主体组成，该主体本身包含一个类型和可选的填充。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    opaque content[TLSPlaintext.length];<br>    ContentType type;<br>    uint8 zeros[length_of_padding];<br>&#125; TLSInnerPlaintext;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ContentType opaque_type = application_data; <span class="hljs-comment">/* 23 */</span><br>    ProtocolVersion legacy_record_version = <span class="hljs-number">0x0303</span>; <span class="hljs-comment">/* TLS v1.2 */</span><br>    uint16 length;<br>    opaque encrypted_record[TLSCiphertext.length];<br>&#125; TLSCiphertext;<br></code></pre></td></tr></table></figure><ul><li><p>content:<br>TLSPlaintext.fragment 值，包含握手或警报消息的字节编码，或要发送的应用数据的原始字节。</p></li><li><p>type:<br>TLSPlaintext.type 值，包含记录的内容类型。</p></li><li><p>zeros:<br>在类型字段之后的明文中可以出现任意长度的零值字节。只要总数保持在记录大小限制范围内，这个字段为发件人提供了按所选的量去填充任何 TLS 记录的机会。更多详细信息，请参见<a target="_blank" rel="noopener" href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TLS_1.3_Record_Protocol.md#%E5%9B%9B-record-padding">[第 5.4 节]</a></p></li><li><p>opaque_type:<br>TLSCiphertext 记录外部的 opaque_type 字段始终设置为值23(application_data)，以便与解析以前版本的 TLS 的中间件向外兼容。解密后，在 TLSInnerPlaintext.type 中找到记录的实际内容类型。</p></li><li><p>legacy_record_version:<br>legacy_record_version 字段始终为 0x0303。TLS 1.3 TLSCiphertexts 在协商 TLS 1.3 之后才生成，因此没有历史兼容性问题可能会收到其他值。请注意，握手协议(包括 ClientHello 和 ServerHello 消息)会对协议版本进行身份验证，因此该值是多余的。</p></li><li><p>length:<br>TLSCiphertext.encrypted_record 的长度(以字节为单位)，它是内容和填充的长度之和，加上内部内容类型的长度加上 AEAD 算法添加的任何扩展。长度不得超过 2 ^ 14 + 256 字节。接收超过此长度的记录的端点必须使用 “record_overflow” alert 消息终止连接。</p></li><li><p>encrypted_record:<br>AEAD 加密形式的序列化 TLSInnerPlaintext 结构。</p></li></ul><p>AEAD 算法将单个密钥，随机数，明文和要包含在认证检查中的“附加数据”作为输入，如<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5116#section-2.1">[RFC5116的第2.1节]</a>所述。key 是 client_write_key 或 server_write_key，nonce 是从序列号和 client_write_iv 或 server_write_iv 中派生出来的(参见<a target="_blank" rel="noopener" href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TLS_1.3_Record_Protocol.md#%E4%B8%89-per-record-nonce">[第5.3节]</a>)，附加数据的输入是记录头，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">additional_data = TLSCiphertext.opaque_type ||<br>                  TLSCiphertext.legacy_record_version ||<br>                  TLSCiphertext.length<br></code></pre></td></tr></table></figure><p>作为输入 AEAD 算法的明文是编码后的 TLSInnerPlaintext 结构。<a target="_blank" rel="noopener" href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TLS_1.3_Cryptographic_Computations.md#%E4%B8%89-traffic-key-calculation">第7.3节</a>定义了流量密钥的派生。</p><p>AEAD 输出包括 AEAD 加密操作的密文输出。由于包含 TLSInnerPlaintext.type 和发送方提供的任何填充，明文的长度大于相应的 TLSPlaintext.length。AEAD 输出的长度通常大于明文，但是其中一部分也会随着 AEAD 算法的变化而变化。</p><p>由于密码可能包含填充，因此开销量可能随着明文的不同长度而变化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">AEADEncrypted =<br>    AEAD-Encrypt(write_key, nonce, additional_data, plaintext)<br></code></pre></td></tr></table></figure><p>TLSCiphertext 的 encrypted_record 字段设置为 AEADEncrypted。</p><p>为了解密和验证，密码会把密钥，随机数，附加数据和 AEADEncrypted 值作为输入。输出的是明文或表示解密失败的错误。这里没有单独的完整性检查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">plaintext of encrypted_record =<br>    AEAD-Decrypt(peer_write_key, nonce,<br>                 additional_data, AEADEncrypted)<br></code></pre></td></tr></table></figure><p>如果解密失败，接收方必须使用 “bad_record_mac” alert 消息终止连接。</p><p>TLS 1.3 中使用的 AEAD 算法不得产生大于 255 个八位字节的扩展。从对端的 TLSCiphertext.length 接收记录，如果 TLSCiphertext.length 大于 2 ^ 14 + 256 个八位字节，则必须用 “record_overflow” 消息终止连接。这个限制源自于：TLSInnerPlaintext 长度的最大值是 2 ^ 14 个八位字节 + 1 个八字节的 ContentType + 255 个八位字节的最大 AEAD 扩展。</p><h2 id="三-per-record-nonce"><a class="markdownIt-Anchor" href="#三-per-record-nonce"></a> 三. Per-Record Nonce</h2><p>分别维护 64 位序列号以读取和写入记录。在读取或写入每个记录之后，适当的序列号加 1。每个序列号在连接开始时和每次更改密钥时都设置为零; 在特定流量密钥下传输的第一条记录必须使用序列号 0。</p><p>因为序列号的大小是 64 位，所以它们不应该 wrap。如果 TLS 实现方需要 wrap 序列号，它必须重新生成密钥(<a target="_blank" rel="noopener" href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TLS_1.3_Handshake_Protocol.md#3-key-and-initialization-vector-update">第4.6.3节</a>)或终止连接。</p><p>每个 AEAD 算法将为 per-record 的随机数指定一系列可能的长度，从 N_MIN 字节到输入的 N_MAX 字节<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5116">[RFC5116]</a>。 对于 AEAD 算法，TLS 的 per-record 随机数(iv_length)的长度设置为 8 字节和 N_MIN 中的较大者(参见<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5116#section-4">[RFC5116]</a>，第4节)。 其中 N_MAX 小于 8 个字节的 AEAD 算法不得与 TLS 一起使用。AEAD 结构的 per-record 随机数形成如下:</p><ol><li>64 位的记录序列号是按网络字节顺序编码，并在左边用零填充到 iv_length。</li><li>填充的序列号要和 client_write_iv 或者 server_write_iv 进行异或(取决于角色)</li></ol><p>得到的值(长度为 iv_length)被用作 per-record 的随机数。</p><p>注意：这与 TLS 1.2 中的结构不同了，TLS 1.2 指定了部分显式的随机数。</p><h2 id="四-record-padding"><a class="markdownIt-Anchor" href="#四-record-padding"></a> 四. Record Padding</h2><p>所有加密的 TLS 记录都可以被填充，从而扩大 TLSCiphertext 的大小。这种做法允许发送者隐藏来自观察者的流量大小。</p><p>生成 TLSCiphertext 记录时，实现方可以选择填充。未填充的记录只是填充长度为零的记录。填充是在加密之前附加到 ContentType 字段的一串零值字节。实现方必须在加密之前将填充的八位字节全部设置为零。</p><p>如果发送者需要，应用数据记录可以包含零长度 TLSInnerPlaintext.content。 这允许在对 activity 存在或者不存在敏感的情况下，产生合理大小的覆盖流量。实现方绝不能发送具有零长度 TLSInnerPlaintext.content 的握手和 alert 记录; 如果收到这样的消息，接收实现方必须用 “unexpected_message” alert 消息终止连接。</p><p>发送的填充由记录保护机制自动验证;在成功解密 TLSCiphertext.encrypted_record后，接收实现方从末端向前开始扫描字段，直到找到非零八位字节。该非零八位字节是消息的内容类型 type 字段。选择此填充方案是因为它允许以任意大小(从零到 TLS 记录大小限制)填充任何加密的 TLS 记录，而不引入新的内容类型。该设计还强制执行全零填充八位字节，以便快速检测填充错误。</p><p>实现方必须将扫描范围限制为只扫描从 AEAD 解密返回的明文。如果接收实现方在明文中没有找到非零八位字节，它必须以 “unexpected_message” alert 消息终止连接。</p><p>填充并不会改变整体记录大小限制：完整编码的 TLSInnerPlaintext 不得超过 2 ^ 14 + 1 个八位字节。如果最大片段长度减少 - 例如，来自 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8449">[RFC8449]</a> 的 record_size_limit 扩展 - 那么减少的限制适用于完整的纯文本，包括内容类型和填充。</p><p>选择一个合理的填充策略，比如何时填充，填充多少，这是一个复杂的主题，超出了本规范的范围。如果 TLS 之上的应用层协议具有自己的填充，则最好在应用层内填充应用数据 TLS 记录。但是，加密握手或 alert 记录的填充仍必须在 TLS 层处理。稍后的文档可以定义填充选择算法或通过 TLS 扩展或一些其他手段定义填充策略的请求机制。</p><h2 id="五-limits-on-key-usage"><a class="markdownIt-Anchor" href="#五-limits-on-key-usage"></a> 五. Limits on Key Usage</h2><p>明文数量存在一些加密限制，这些限制可以在给定的一组密钥下安全加密。<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8446#ref-AEAD-LIMITS">[AEAD-LIMITS]</a> 在假设基础原语(AES 或 ChaCha20)没有弱点的情况下提供了对这些限制的分析。在达到这些限制之前，实现方应该按照<a target="_blank" rel="noopener" href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TLS_1.3_Handshake_Protocol.md#3-key-and-initialization-vector-update">第 4.6.3 节</a>中的描述进行密钥更新。</p><p>对于 AES-GCM，在给定连接上可以加密多达 2 ^ 24.5 个全尺寸记录(大约 2400 万个)，同时为认证加密(AE)安全性保持大约 2 ^ -57 的安全余量。对于 ChaCha20 / Poly1305，记录序列号将在达到安全限制之前就会 wrap。</p><hr><h1 id="密钥计算"><a class="markdownIt-Anchor" href="#密钥计算"></a> 密钥计算</h1><p>TLS 握手建立一个或多个输入的 secrets，如下文所述，将这些 secrets 组合起来以创建实际工作密钥材料。密钥派生过程包含输入 secrets 和握手记录。请注意，由于握手记录包含来自 Hello 消息的随机值，因此即使使用相同的输入 secrets，任何给定的握手都将具有不同的流量 secrets，就像将相同的 PSK 用于多个连接的情况一样。</p><h2 id="一-key-schedule"><a class="markdownIt-Anchor" href="#一-key-schedule"></a> 一. Key Schedule</h2><p>密钥派生过程使用 HKDF <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5869">[RFC5869]</a> 定义的 HKDF-Extract 和 HKDF-Expand 函数，以及下面定义的函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">HKDF-Expand-Label(Secret, Label, Context, Length) =<br>     HKDF-Expand(Secret, HkdfLabel, Length)<br><br>Where HkdfLabel is specified as:<br><br><span class="hljs-keyword">struct</span> &#123;<br>    uint16 length = Length;<br>    opaque label&lt;<span class="hljs-number">7.</span><span class="hljs-number">.255</span>&gt; = <span class="hljs-string">&quot;tls13 &quot;</span> + Label;<br>    opaque context&lt;<span class="hljs-number">0.</span><span class="hljs-number">.255</span>&gt; = Context;<br>&#125; HkdfLabel;<br><br>Derive-Secret(Secret, Label, Messages) =<br>     HKDF-Expand-Label(Secret, Label,<br>                       Transcript-Hash(Messages), Hash.length)<br></code></pre></td></tr></table></figure><p>Transcript-Hash 和 HKDF 使用的 Hash 函数是密码套件哈希算法。Hash.length 是其输出长度(以字节为单位)。消息是表示的握手消息的串联，包括握手消息类型和长度字段，但不包括记录层头。请注意，在某些情况下，零长度 context（由 “” 表示）传递给 HKDF-Expand-Label。本文档中指定的 labels 都是 ASCII 字符串，不包括尾随 NUL 字节。</p><p>注意：对于常见的哈希函数，任何超过 12 个字符的 label 都需要额外迭代哈希函数才能计算。所有标准都已选择遵守此限制。</p><p>密钥是从使用 HKDF-Extract 和 Derive-Secret 函数的两个输入 secrets 中派生出来的。添加新 secret 的一般模式是使用 HKDF-Extract，其中 Salt 是当前的 secret 状态，输入密钥材料(IKM)是要添加的新 secret 。在此版本的 TLS 1.3 中，两个输入 secrets 是:</p><ul><li><p>PSK(外部建立的预共享密钥，或从先前连接的 resumption_master_secret 值派生的)</p></li><li><p>(EC)DHE 共享 secret (<a target="_blank" rel="noopener" href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TLS_1.3_Cryptographic_Computations.md#%E5%9B%9B-ecdhe-shared-secret-calculation">Section 7.4</a>)</p></li></ul><p>这将生成一个完整的密钥推导计划，如下图所示。在此图中，约定以下的格式：</p><ul><li><p>HKDF-Extract 画在图上，它为从顶部获取 Salt 参数，从左侧获取 IKM 参数，它的输出是底部，和右侧输出的名称。</p></li><li><p>Derive-Secret 的 Secret 参数由传入的箭头指示。例如，Early Secret 是生成 client_early_traffic_secret 的 Secret。</p></li><li><p>“0” 表示将 Hash.length 字节的字符串设置为零。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c">          <span class="hljs-number">0</span><br>          |<br>          v<br>PSK -&gt;  HKDF-Extract = Early Secret<br>          |<br>          +-----&gt; Derive-Secret(., <span class="hljs-string">&quot;ext binder&quot;</span> | <span class="hljs-string">&quot;res binder&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>          |                     = binder_key<br>          |<br>          +-----&gt; Derive-Secret(., <span class="hljs-string">&quot;c e traffic&quot;</span>, ClientHello)<br>          |                     = client_early_traffic_secret<br>          |<br>          +-----&gt; Derive-Secret(., <span class="hljs-string">&quot;e exp master&quot;</span>, ClientHello)<br>          |                     = early_exporter_master_secret<br>          v<br>    Derive-Secret(., <span class="hljs-string">&quot;derived&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>          |<br>          v<br>(EC)DHE -&gt; HKDF-Extract = Handshake Secret<br>          |<br>          +-----&gt; Derive-Secret(., <span class="hljs-string">&quot;c hs traffic&quot;</span>,<br>          |                     ClientHello...ServerHello)<br>          |                     = client_handshake_traffic_secret<br>          |<br>          +-----&gt; Derive-Secret(., <span class="hljs-string">&quot;s hs traffic&quot;</span>,<br>          |                     ClientHello...ServerHello)<br>          |                     = server_handshake_traffic_secret<br>          v<br>    Derive-Secret(., <span class="hljs-string">&quot;derived&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>          |<br>          v<br><span class="hljs-number">0</span> -&gt; HKDF-Extract = Master Secret<br>          |<br>          +-----&gt; Derive-Secret(., <span class="hljs-string">&quot;c ap traffic&quot;</span>,<br>          |                     ClientHello...server Finished)<br>          |                     = client_application_traffic_secret_0<br>          |<br>          +-----&gt; Derive-Secret(., <span class="hljs-string">&quot;s ap traffic&quot;</span>,<br>          |                     ClientHello...server Finished)<br>          |                     = server_application_traffic_secret_0<br>          |<br>          +-----&gt; Derive-Secret(., <span class="hljs-string">&quot;exp master&quot;</span>,<br>          |                     ClientHello...server Finished)<br>          |                     = exporter_master_secret<br>          |<br>          +-----&gt; Derive-Secret(., <span class="hljs-string">&quot;res master&quot;</span>,<br>                                ClientHello...client Finished)<br>                                = resumption_master_secret<br></code></pre></td></tr></table></figure><p>这里的一般模式指的是，图左侧显示的 secrets 是没有上下文的原始熵，而右侧的 secrets 包括握手上下文，因此可以用来派生工作密钥而无需额外的上下文。请注意，对 Derive-Secret 的不同调用可能会使用不同的 Messages 参数，即使是具有相同的 secret。在 0-RTT 交换中，Derive-Secret 和四个不同的副本一起被调用;在 1-RTT-only 交换中，它和三个不同的副本一起被调用。</p><p>如果给定的 secret 不可用，则使用由设置为零的 Hash.length 字节串组成的 0 值。请注意，这并不意味着要跳过轮次，因此如果 PSK 未被使用，Early Secret 仍将是 HKDF-Extract(0,0)。对于 binder_key 的计算，label 是外部 PSK(在 TLS 之外提供的那些)的 “ext binder” 和用于恢复 PSK 的 “res binder”(提供为先前握手的恢复主密钥的那些)。不同的 labels 阻止了一种 PSK 替代另一种 PSK。</p><p>这存在有多个潜在的 Early Secret 值，具体取决于 Server 最终选择的 PSK。Client 需要为每个潜在的 PSK 都计算一个值;如果没有选择 PSK，则需要计算对应于零 PSK 的 Early Secret。</p><p>一旦计算出了从给定 secret 派生出的所有值，就应该删除该 secret。</p><h2 id="二-updating-traffic-secrets"><a class="markdownIt-Anchor" href="#二-updating-traffic-secrets"></a> 二. Updating Traffic Secrets</h2><p>一旦握手完成后，任何一方都可以使用<a target="_blank" rel="noopener" href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TLS_1.3_Handshake_Protocol.md#3-key-and-initialization-vector-update">第 4.6.3 节</a>中定义的 KeyUpdate 握手消息更新其发送流量密钥。 下一代流量密钥的计算方法是，如本节所述，从 client_ / server_application_traffic_secret_N 生成出 client_ / server_application_traffic_secret_N + 1，然后按 <a target="_blank" rel="noopener" href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TLS_1.3_Cryptographic_Computations.md#%E4%B8%89-traffic-key-calculation">7.3 节</a>所述方法重新导出流量密钥。</p><p>下一代 application_traffic_secret 计算方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">application_traffic_secret_N+<span class="hljs-number">1</span> =<br>    HKDF-Expand-Label(application_traffic_secret_N,<br>                      <span class="hljs-string">&quot;traffic upd&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, Hash.length)<br></code></pre></td></tr></table></figure><p>一旦计算了 client_ / server_application_traffic_secret_N + 1 及其关联的流量密钥，实现方应该删除 client_ / server_application_traffic_secret_N 及其关联的流量密钥。</p><h2 id="三-traffic-key-calculation"><a class="markdownIt-Anchor" href="#三-traffic-key-calculation"></a> 三. Traffic Key Calculation</h2><p>流量密钥材料由以下输入值生成:</p><ul><li><p>secret 的值</p></li><li><p>表示正在生成的特定值的目的值</p></li><li><p>生成密钥的长度</p></li></ul><p>使用输入流量 secret 的值生成流量密钥材料:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">[sender]_write_key = HKDF-Expand-Label(Secret, <span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, key_length)<br> [sender]_write_iv  = HKDF-Expand-Label(Secret, <span class="hljs-string">&quot;iv&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, iv_length)<br></code></pre></td></tr></table></figure><p>[sender] 表示发送方。每种记录类型的 Secret 值显示在下表中:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">+-------------------+---------------------------------------+<br>| Record Type       | Secret                                |<br>+-------------------+---------------------------------------+<br>| <span class="hljs-number">0</span>-RTT Application | client_early_traffic_secret           |<br>|                   |                                       |<br>| Handshake         | [sender]_handshake_traffic_secret     |<br>|                   |                                       |<br>| Application Data  | [sender]_application_traffic_secret_N |<br>+-------------------+---------------------------------------+<br></code></pre></td></tr></table></figure><p>每当底层 Secret 更改时(例如，从握手更改为应用数据密钥或密钥更新时)，将重新计算所有流量密钥材料。</p><h2 id="四-ecdhe-shared-secret-calculation"><a class="markdownIt-Anchor" href="#四-ecdhe-shared-secret-calculation"></a> 四. (EC)DHE Shared Secret Calculation</h2><h3 id="1-finite-field-diffie-hellman"><a class="markdownIt-Anchor" href="#1-finite-field-diffie-hellman"></a> 1. Finite Field Diffie-Hellman</h3><p>对于有限的字段组合，执行传统的 Diffie-Hellman <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8446#ref-DH76">[DH76]</a> 计算。协商密钥(Z)被转换成一个字节字符串，字符串以 big-endian 形式编码，并用零往左边填充到初始的大小。此字节字符串用作上面指定的密钥计划中的共享密钥。</p><p>请注意，此结构与先前版本的 TLS 不同，TLS 之前的版本删除了前导零。</p><h3 id="2-elliptic-curve-diffie-hellman"><a class="markdownIt-Anchor" href="#2-elliptic-curve-diffie-hellman"></a> 2. Elliptic Curve Diffie-Hellman</h3><p>对于 secp256r1，secp384r1 和 secp521r1，ECDH 计算(包括参数和密钥生成以及共享密钥计算)根据 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8446#ref-IEEE1363">[IEEE1363]</a> 使用 ECKAS-DH1 方案执行，identity 映射作为密钥导出函数(KDF）， 因此，共享 secret 是表示为八位字节串的 ECDH 共享秘密椭圆曲线点的 x 坐标。<br> <br>注意，FE2OSP (字段元素到八位字符串转换原语)输出的该八位字节串(IEEE 1363 术语中的“Z”)对于任何给定字段都具有恒定长度;在此八位字符串中找到的前导零不得被截断。</p><p>(请注意，使用 KDF 标识是一种技术性。完整的做法是 ECDH 与 KDF 一起使用，因为 TLS 不直接将此 secret 用于计算其他 secret 以外的任何其他内容。)</p><p>对于 X25519 和 X448，ECDH 计算如下：</p><ul><li><p>放入 KeyShareEntry.key_exchange 结构的公钥是将 ECDH 标量乘法函数应用于适当长度(标量输入)和标准公共基点( u 坐标点输入)的密钥的结果。</p></li><li><p>ECDH 共享密钥是将 ECDH 标量乘法函数应用于密钥(标量输入)和对等方的公钥( u 坐标点输入)的结果。输出是直接使用的，没有经过处理的。</p></li></ul><p>对于这些曲线，实现方应该使用 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7748">RFC7748</a> 中指定的方法来计算 Diffie-Hellman 共享密钥。实现方必须检查计算的 Diffie-Hellman 共享密钥是否为全零值，如果是，则中止，如 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7748#section-6">[RFC7748] 第 6 节</a> 所述。如果实现者使用这些椭圆曲线的替代实现，他们应该执行 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7748#section-7">[RFC7748] 第 7 节</a>中指定的附加检查。</p><h2 id="五-exporters"><a class="markdownIt-Anchor" href="#五-exporters"></a> 五. Exporters</h2><p>[RFC5705] 根据 TLS 伪随机函数(PRF)定义 TLS 的密钥材料 exporter。本文档用 HKDF 取代 PRF，因此需要新的结构。exporter 的接口保持不变。</p><p>exporter 的值计算方法如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">TLS-Exporter(label, context_value, key_length) =<br>    HKDF-Expand-Label(Derive-Secret(Secret, label, <span class="hljs-string">&quot;&quot;</span>),<br>                      <span class="hljs-string">&quot;exporter&quot;</span>, Hash(context_value), key_length)<br></code></pre></td></tr></table></figure><p>Secret 可以是 early_exporter_master_secret 或 exporter_master_secret。除非应用程序明确指定，否则实现方必须使用exporter_master_secret。early_exporter_master_secret 被定义用来在 0-RTT 数据需要 exporter 的设置这种情况中使用。建议为 early exporter 提供单独的接口;这可以避免 exporter 用户在需要常规 exporter 时意外使用 early exporter，反之亦然。</p><p>如果未提供上下文，则 context_value 为零长度。因此，不提供上下文计算与提供空上下文得到的结果都是相同的。这是对以前版本的 TLS 的更改，以前的 TLS 版本中，空的上下文产生的输出与不提供的上下文的结果不同。截至本文档，无论是否使用上下文，都不会使用已分配的 exporter 标签。未来的规范绝不能定义允许空上下文和没有相同标签的上下文的 exporter 的使用。exporter 的新用法应该是在所有 exporter 计算中提供上下文，尽管值可能为空。</p><p>exporter 标签格式的要求在 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5705#section-4">[RFC5705] 第4节</a> 中定义。</p><hr><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc8446">RFC 8446</a></li><li><a target="_blank" rel="noopener" href="https://zq99299.github.io/note-book2/http-protocol/05/05.html#%E6%8F%A1%E6%89%8B%E5%88%86%E6%9E%90">更好更快的握手: TLS 1.3 特性解析</a></li><li><a target="_blank" rel="noopener" href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TLS_1.3_Handshake_Protocol.md#6-post-handshake-messages">TLS_1.3_Handshake_Protocol</a></li><li><a target="_blank" rel="noopener" href="http://suntus.github.io/2020/03/20/PSK%E7%9B%B8%E5%85%B3/">PSK相关</a></li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" class="category-chain-item">密码学</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%8E%9F%E5%88%9B/">#原创</a> <a href="/tags/TLS1-3/">#TLS1.3</a></div></div><div class="license-box my-3"><div class="license-title"><div>tls1.3协议原理</div><div>http://example.com/2023/08/16/tls/protocol/tls1_3/085339/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>EtcFly</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年8月16日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2024年3月5日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2023/08/16/tls/protocol/tls1_2/085339/" title="tls1.2协议原理"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">tls1.2协议原理</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2023/08/16/mbedtls-certificate/ext/085157/" title="tls协议扩展详情"><span class="hidden-mobile">tls协议扩展详情</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="waline"></div><script type="text/javascript">Fluid.utils.loadComments("#waline",(function(){Fluid.utils.createCssLink("https://lib.baomitu.com/waline/2.14.1/waline.min.css"),Fluid.utils.createScript("https://lib.baomitu.com/waline/2.14.1/waline.min.js",(function(){var i=Object.assign({serverURL:"https://etcfly.top:14000/",path:"window.location.pathname",meta:["nick","mail","link"],requiredMeta:["nick"],lang:"zh-CN",emoji:["https://unpkg.com/@waline/emojis@1.1.0/qq"],dark:'html[data-user-color-scheme="dark"]',wordLimit:0,pageSize:10},{el:"#waline",path:window.location.pathname});Waline.init(i),Fluid.utils.waitElementVisible("#waline .vcontent",()=>{var i="#waline .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://github.com/EtcFly" target="_blank" rel="nofollow noopener"><span>Copyright</span></a> <i class="iconfont icon-copyright"></i> <a href="https://etcfly.top:14100/share/yqTLFDlP/%E4%BB%97%E5%89%91%E8%B5%B0%E5%A4%A9%E6%B6%AF" target="_blank" rel="nofollow noopener"><span>2018-2024 EtcFly</span></a><div style="font-size:.85rem"><span>总访问量 <span style="color:#000" id="PVstatic">0</span> 次&nbsp</span> <span>总访客数 <span style="color:#000" id="UVstatic">0</span> 人&nbsp</span> <span>当前在线 <span style="color:#000" id="ACTstatic">0</span> 人&nbsp</span><script src="https://etcfly.top:14200/statistics" defer></script></div><div style="font-size:.85rem"><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="js/duration.js"></script></div></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener"></a> </span><span><a href="http://beian.miit.gov.cn/2023000858" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" alt="police-icon"> <span>浙ICP备2023000858号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/jquery.min.js"></script><script src="/live2d-widget/autoload.js"></script><script src="/js/star.js"></script><script src="/js/ribbon.min.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>