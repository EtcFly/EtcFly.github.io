<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="EtcFly"><meta name="keywords" content=""><meta name="description" content="版权归作者所有, 转载请保留该部分声明。本文作者：EtcFly原文地址：https:&#x2F;&#x2F;etcfly.top              3. 报文格式   5.0 版本协议相对于3.1.1版本协议, 新增了一个AUTH 控制报文, 接下来对这 15 种控制报文进行逐一讲解, 讲解将从报文的 固定报头, 可变报头, 有效载荷 三部分进行讲解, 现在开始！  3.1 CONN"><meta property="og:type" content="article"><meta property="og:title" content="mqtt5协议一连接"><meta property="og:url" content="http://example.com/2023/05/23/linux/network/mqtt50/connect/084806/"><meta property="og:site_name" content="仗剑走天涯"><meta property="og:description" content="版权归作者所有, 转载请保留该部分声明。本文作者：EtcFly原文地址：https:&#x2F;&#x2F;etcfly.top              3. 报文格式   5.0 版本协议相对于3.1.1版本协议, 新增了一个AUTH 控制报文, 接下来对这 15 种控制报文进行逐一讲解, 讲解将从报文的 固定报头, 可变报头, 有效载荷 三部分进行讲解, 现在开始！  3.1 CONN"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/mqtt.png"><meta property="article:published_time" content="2023-05-23T08:48:06.000Z"><meta property="article:modified_time" content="2024-03-05T03:41:03.000Z"><meta property="article:author" content="EtcFly"><meta property="article:tag" content="原创"><meta property="article:tag" content="TCPIP"><meta property="article:tag" content="MQTT"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/img/mqtt.png"><title>mqtt5协议一连接 仗剑走天涯</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/fluid-extention.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:4},web_analytics:{enable:!0,follow_dnt:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"3AEufnWAJdp8cFODp1DXvrQU-MdYXbMMI",app_key:"mGJiL6xVvYv21ygqfynJoCyO",server_url:null,path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Strive For Dream</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="mqtt5协议一连接"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-05-23 08:48" pubdate>2023年5月23日 早上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 15k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 124 分钟 </span><span id="vvdpost_container_page_pvuv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="vvdpost_value_page_pv">0</span> 次&nbsp&nbsp <i class="iconfont icon-users" aria-hidden="true"></i> <span id="vvdpost_value_page_uv">0</span> 人</span><script>console.log(window.location.pathname);var httpRequest=new XMLHttpRequest;httpRequest.open("POST","https://etcfly.top:14200/poststats",!0),httpRequest.setRequestHeader("Content-type","application/json"),httpRequest.send(JSON.stringify(window.location.pathname)),httpRequest.onreadystatechange=function(){if(4==httpRequest.readyState&&200==httpRequest.status){var e=httpRequest.responseText,t=JSON.parse(e);console.log(t.pv);var o=document.querySelector("#vvdpost_container_page_pvuv");if(console.log(o),o){var n=document.querySelector("#vvdpost_value_page_pv");console.log(n);var s=document.querySelector("#vvdpost_value_page_uv");console.log(s),s&&s&&(n.innerText=t.pv,s.innerText=t.uv,o.style.display="inline")}}}</script></div></div></div></div></div></div><script async src="https://etcfly.top:14100/script.js" data-website-id="1a5c096d-21e5-4556-99b0-28c810c9c868"></script></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">mqtt5协议一连接</h1><p class="note note-info">本文最后更新于：2024年3月5日 凌晨</p><div class="markdown-body"><div class="note note-success"><p>版权归作者所有, 转载请保留该部分声明。<br>本文作者：EtcFly<br>原文地址：<a target="_blank" rel="noopener" href="https://etcfly.top">https://etcfly.top</a></p></div><hr><h3 id="3-报文格式"><a class="markdownIt-Anchor" href="#3-报文格式"></a> 3. 报文格式</h3><p>  <code>5.0</code> 版本协议相对于<code>3.1.1</code>版本协议, 新增了一个<code>AUTH</code> 控制报文, 接下来对这 <code>15</code> 种控制报文进行逐一讲解, 讲解将从报文的 <strong>固定报头</strong>, <strong>可变报头</strong>, <strong>有效载荷</strong> 三部分进行讲解, 现在开始！</p><h4 id="31-connect"><a class="markdownIt-Anchor" href="#31-connect"></a> 3.1 CONNECT</h4><p>  客户端想要和服务端建立通讯连接, 其发送的第一个控制报文必须是<code>connect</code>报文, 服务端使用 <u>客户端标识符</u> 来唯一标识一个连接的客户端, 客户端连接建立后, 如果相同的客户端(相同客户端标识符)重复发起连接, 服务端将断开之前客户端连接, 并建立新的客户端连接。</p><p>  一个<code>CONNECT</code>连接包含多个编码字段, 包括客户端的唯一标识符， <code>Will</code> 主题， <code>Will</code> 消息，用户名和密码。除客户端标识之外，其它的字段都是可选的，基于标志位来决定可变报头中是否需要包含这些字段。</p><h5 id="311-固定报头"><a class="markdownIt-Anchor" href="#311-固定报头"></a> 3.1.1 固定报头</h5><p><img src="/2023/05/23/linux/network/mqtt50/connect/084806/connect%E6%8A%A5%E6%96%87%E5%9B%BA%E5%AE%9A%E6%8A%A5%E5%A4%B4.png" srcset="/img/loading.gif" lazyload alt="connect报文固定报头.png"></p><ul><li>剩余类型: 剩余长度等于可变报头的长度（固定<code>10</code> 字节）加上可变报头属性字段长度 加上有效载荷的长度。这也是<code>5.0</code>协议和<code>3.1.1</code>协议<code>CONNECT</code>报文格式最大区别, 可变报头中多了属性字段。</li></ul><hr><h5 id="312-可变报头"><a class="markdownIt-Anchor" href="#312-可变报头"></a> 3.1.2 可变报头</h5><p>  <code>CONNECT</code> 报文的可变报头按下列次序包含四个字段：协议名（<code>Protocol Name</code>）(<code>6Byte</code>)， 协议级别（<code>Protocol Level</code>）(<code>1Byte</code>) ， 连接标志（<code>Connect Flags</code>）(<code>1Byte</code>)和保持连接（<code>Keep Alive</code>）(<code>2Byte</code>), 总共<code>10Byte</code>, 这是和<code>3.1.1</code>兼容部分, <code>5.0</code>协议在其后追加了 <u>属性字段</u>。</p><h6 id="3121-协议名"><a class="markdownIt-Anchor" href="#3121-协议名"></a> 3.1.2.1 协议名</h6><p><img src="/2023/05/23/linux/network/mqtt50/connect/084806/connect%E5%8D%8F%E8%AE%AE%E5%90%8D.png" srcset="/img/loading.gif" lazyload alt="connect协议名.png"></p><p>  协议名是表示协议名 <code>MQTT</code> 的 <code>UTF-8</code> 编码的字符串。 <code>MQTT</code> 规范的后续版本不会改变这个字符串的偏移和长度。如果协议名不正确服务端可以断开客户端的连接， 也可以按照某些其它规范继续处理 <code>CONNECT</code> 报文。对于后一种情况，按照本规范， 服务端不能继续处理 <code>CONNECT</code> 报文</p><p>  如果服务端不愿意接受 <code>CONNECT</code> 但希望表明其 <code>MQTT</code> 服务端身份， 可以发送包含原因码为 <code>0x84</code>（不支持的协议版本）的 <code>CONNACK</code>报文，然后必须关闭网络连接。</p><h6 id="3122-协议版本"><a class="markdownIt-Anchor" href="#3122-协议版本"></a> 3.1.2.2 协议版本</h6><p><img src="/2023/05/23/linux/network/mqtt50/connect/084806/connect%E5%8D%8F%E8%AE%AE%E7%BA%A7%E5%88%AB.png" srcset="/img/loading.gif" lazyload alt="connect协议级别.png"></p><p>客户端用 <code>8</code> 位的无符号值表示协议的修订版本, 协议级别目前定义如下:</p><ul><li><code>3</code>: <code>3.1</code> 版协议</li><li><code>4</code>: <code>3.1.1</code> 版协议</li><li><code>5</code>: <code>5.0</code> 版协议</li></ul><p>  如果协议版本不是 <code>5</code> 且服务端不愿意接受此 <code>CONNECT</code> 报文， 可以发送包含原因码 <code>0x84</code>（不支持的协议版本）的 <code>CONNACK</code> 报文，然后必须关闭网络连接。</p><hr><h6 id="3123-连接标志"><a class="markdownIt-Anchor" href="#3123-连接标志"></a> 3.1.2.3 连接标志</h6><p>  连接标志用于指定<code>MQTT</code>连接行为的参数, 它指出有效载荷中一些字段是否存在。</p><p><img src="/2023/05/23/linux/network/mqtt50/connect/084806/connect%E8%BF%9E%E6%8E%A5%E6%A0%87%E5%BF%97.png" srcset="/img/loading.gif" lazyload alt="connect连接标志.png"></p><ul><li>服务端必须验证 <code>CONNECT</code> 报文的保留标志位（第 <code>0</code> 位）是否为 <code>0</code>，如果不为 <code>0</code> 则此报文为无效报文。</li></ul><p>接下来我们对这些标志逐一讲解:</p><ul><li><strong>clean Start</strong></li></ul><blockquote><ul><li>这个二进制位表明此次连接是一个新的会话还是一个已存在的会话的延续</li><li>如果收到 <code>Clean Start</code> 为 1 的 <code>CONNECT</code> 报文，客户端和服务端必须丢弃任何已存在的会话，并开始一个新的会话 。相应的， <code>CONNACK</code> 报文中的会话存在标志设置为 <code>0</code>。</li><li>如果收到<code>Clean Start</code>为 0 的 <code>CONNECT</code> 报文，并且存在一个关联此客户标识符的会话，服务端必须基于此会话的状态恢复与客户端的通信。 如果收到<code>Clean Start</code>为 <code>0</code> 的 <code>CONNECT</code> 报文，并且不存在任何关联此客户标识符的会话，服务端必须创建一个新的会话</li></ul></blockquote><p>  通常<code>clean Start</code> 和 <code>3.1</code>协议中的<code>clean Session</code> 对应, 当值为<code>1</code>时二者作用相同, 表示清理一个会话, 但是为<code>0</code>时, <code>3.1.1</code>协议定义服务端需要一直存储会话状态, 如果设备端出现问题一直离线, 服务端需要缓存<code>qos1/qos2</code>消息, 这对服务端字段消耗严重。因此<code>5.0</code>协议端在此基础上定义了 <strong>会话期望值</strong>, 用于指示设备端超过这个离线时间, 服务端将释放会话资源。具体参考会话过期 属性部分。</p><p><strong>特点:</strong></p><ul><li>当客户端掉线或者正常断开, 之前客户端订阅的话题被服务器保存, 下次重新连接不需要重新订阅话题(有些客户端能正确接受服务端消息但是不展示，容易引发困惑(如 <code>mqttfx v1.7.1</code>), 可以通过抓包查看)</li><li>当订阅的话题<code>QOS1</code>, <code>QOS2</code> 级别时, 假如客户端掉线期间, 其他客户端发布了该主题, 服务器将保存该信息, 待下次 客户端连接后, 发布该主题. 确保<code>QOS1</code>, <code>QOS2</code> 级别消息不会被丢失。<code>QOS0</code> 是否不存取决于服务器配置(测试 <code>mosquitto_pub v2.0.15</code> 版本也会转发)。</li><li>如果<code>clean Session</code>标记为 1, 则每次清理回话信息, 会话仅持续和网络连接相同时间, 及每次需要重新订阅原有的所有主题</li></ul><hr><ul><li><strong>Will Flag</strong><br>遗嘱消息标志设置为1, 表示遗嘱消息必须存储到服务端与该设备标识符相关联的会话中, 这是一个和网络相关的消息, 当网络断开时消息发布。这样当网络环境较差, 设备频繁离上线, 服务端需要频繁分发该客户端遗嘱, 导致占用服务端和其他设备资源。<code>5.0</code>协议为解决这个问题, 引入遗嘱属性。<br>协议规定:<ul><li>遗嘱消息（<code>Will Message</code>）包含 <strong>遗嘱属性</strong>，<strong>遗嘱主题</strong> 和 <strong>遗嘱载荷</strong> 遗嘱必须在网络连接被关闭（如果定义了遗嘱延时间隔, 需要到期, 这样短时间内频繁上下线由于遗嘱延时间隔没到, 遗嘱也不会发布)或者会话结束之后被发布。</li><li>服务端收到包含原因码为 <code>0x00</code>（正常关闭）的 <code>DISCONNECT</code> 报文之后删除遗嘱消息（<code>Will Message</code>）(正常关闭服务端会清空会话中的遗嘱消息)</li><li>当遗嘱被发布, 服务端将删除会话中的遗嘱消息。</li><li>服务端应该在网络连接断开并且遗嘱迟发时间（<code>Will Delay Interval</code>）到期，或者会话结束之后立即发布遗嘱消息。服务端关闭或出错的情况下， 可以在服务重新启动之后发布遗嘱消息（<code>Will Message</code>）。这种情况下从服务端出错到遗嘱发布之间存在一定的延迟</li></ul></li></ul><blockquote><p><strong>注意</strong>: 掉线重连时不能使用空的客户端标识符重连, 如果使用空的客户端重连, 服务端会自动给客户端重新分配新的客户端标识符标识其是一个新的连接。</p></blockquote><ul><li><strong>Will QoS</strong>: 遗嘱的消息级别(<code>QOS0/QOS1/QOS2</code>), 当遗嘱标志为<code>0</code>时必须为<code>0</code></li><li><strong>Will Retain</strong>: 遗嘱保留(是否当做保留消息处理)</li></ul><blockquote><p><strong>删除保留消息</strong>: 保留消息是不会随着客户端断开连接而删除的, 因此非常考验服务端的性能。客户端发布一个 <code>0</code> 长度的保留消息, 服务端将删除该主题的保留消息。如果发布一个该主题 <code>0</code> 长度的非保留消息(保留标志位<code>0</code>), 服务端不能存储这个消息也不能移除或替换任何现存的保留消息</p></blockquote><ul><li><strong>USER NAME</strong>: 用户名标志</li></ul><blockquote><p>用于连接建立期间向服务端传输认证数据。</p></blockquote><ul><li><strong>PASSWORD FLAG</strong>:</li></ul><blockquote><p>用于连接建立期间向服务端传输认证数据。</p></blockquote><p><strong>注意</strong>:</p><ul><li><code>v5.0</code>版本协议允许<code>connect</code>报文中仅包含密码字段, 但是在<code>v3.1.1</code>协议中, 密码字段和用户名字段必须成对存在。</li></ul><hr><h6 id="3124-保活连接时间"><a class="markdownIt-Anchor" href="#3124-保活连接时间"></a> 3.1.2.4 保活连接时间</h6><p><img src="/2023/05/23/linux/network/mqtt50/connect/084806/%E4%BF%9D%E6%B4%BB%E8%BF%9E%E6%8E%A5%E6%97%B6%E9%97%B42.png" srcset="/img/loading.gif" lazyload alt="保活连接时间2.png"></p><p>保活时间(<code>2Byte</code> 单位秒), 如果服务器在 <code>1.5</code>倍的这个时间还没有收到<code>PINGEQ</code>, 将断开连接, 客户端可以在连接期间任何时间发送<code>PINGEQ</code> 报文。如果保活时间为<code>0</code>, 服务端将不检测客户端是否离线。</p><hr><h6 id="3125-connect属性"><a class="markdownIt-Anchor" href="#3125-connect属性"></a> 3.1.2.5 CONNECT属性</h6><p><img src="/2023/05/23/linux/network/mqtt50/connect/084806/CONNECT%E5%B1%9E%E6%80%A7%E6%A0%BC%E5%BC%8F.png" srcset="/img/loading.gif" lazyload alt="CONNECT属性格式.png"></p><p>  <code>CONNECT</code>报文属性有两种, 一种是<code>WILL</code>主题属性, 一种是<code>CONNECT</code>常规属性, <code>WILL</code>主题属性有如下几种:</p><table><thead><tr><th style="text-align:center"><code>Packet / Will Properties</code></th><th style="text-align:center"><code>hex</code></th><th style="text-align:center"><code>Name (usage)</code></th><th style="text-align:center"><code>Type</code></th></tr></thead><tbody><tr><td style="text-align:center"><code>Will Properties</code></td><td style="text-align:center"><code>0x01</code></td><td style="text-align:center"><code>Payload Format Indicator</code></td><td style="text-align:center"><code>Byte</code></td></tr><tr><td style="text-align:center"><code>Will Properties</code></td><td style="text-align:center"><code>0x02</code></td><td style="text-align:center"><code>Message Expiry Interval</code></td><td style="text-align:center"><code>Four Byte Integer</code></td></tr><tr><td style="text-align:center"><code>Will Properties</code></td><td style="text-align:center"><code>0x03</code></td><td style="text-align:center"><code>Content Type</code></td><td style="text-align:center"><code>UTF-8 Encoded String</code></td></tr><tr><td style="text-align:center"><code>Will Properties</code></td><td style="text-align:center"><code>0x08</code></td><td style="text-align:center"><code>Response Topic</code></td><td style="text-align:center"><code>UTF-8 Encoded String</code></td></tr><tr><td style="text-align:center"><code>Will Properties</code></td><td style="text-align:center"><code>0x09</code></td><td style="text-align:center"><code>Correlation Data</code></td><td style="text-align:center"><code>Binary Data</code></td></tr><tr><td style="text-align:center"><code>Will Properties</code></td><td style="text-align:center"><code>0x18</code></td><td style="text-align:center"><code>Will Delay Interval</code></td><td style="text-align:center"><code>Four Byte Integer</code></td></tr><tr><td style="text-align:center"><code>Will Properties</code></td><td style="text-align:center"><code>0x26</code></td><td style="text-align:center"><code>User Property</code></td><td style="text-align:center"><code>UTF-8 String Pair</code></td></tr></tbody></table><ul><li>有效载荷标识<code>0x01</code>(<code>Payload Format Indicator</code>): 该属性只存在于 <code>PUBLISH</code> 报文和 <code>CONNECT</code> 报文的遗嘱属性中。有效载荷标识只占据一个字节大小，它只有 <code>0(0x00)</code> 和 <code>1(0x01)</code> 两个值。</li></ul><blockquote><p><code>MQTT CONNECT</code> 报文中：</p><ul><li>当遗嘱属性的有效载荷标识的值为 <code>0</code> 时，意味着遗嘱消息是未确定的字节，等同于不发送载荷指示。</li><li>当该属性值为 <code>1</code> 时，意味着遗嘱消息是 <code>UTF-8</code> 编码的字符数据，遗嘱载荷（<code>Will Payload</code>）中的数据必须符合标准 <code>UTF-8</code> 的定义。</li></ul><p><code>MQTT PUBLISH</code> 报文中：</p><ul><li>当 <code>PUBLISH</code> 属性的有效载荷标识的值为 <code>0</code> 时，意味着 <code>PUBLISH</code> 消息是未确定的字节。</li><li>当该属性值为 <code>1</code> 时，意味着 <code>PUBLISH</code> 报文的有效载荷是 <code>UTF-8</code> 编码的字符数据，<code>PUBLISH</code> 报文载荷（<code>Payload</code>）中的数据必须符合标准 <code>UTF-8</code> 的定义。</li></ul></blockquote><ul><li>内容类型<code>0x03</code>（<code>Content Type</code>）: 该属性同样只存在于 <code>PUBLISH</code> 报文和 <code>CONNECT</code> 报文的遗嘱属性中。该属性存放的是 <code>UTF-8</code> 编码的字符串，用于描述遗嘱消息或 <code>PUBLISH</code> 消息的内容。</li></ul><blockquote><p>它是由收发消息的应用程序决定的。在消息转发过程中， 内容类型不能被篡改。内容类型的一个比较典型的应用就是存放 <code>MIME</code> 类型，比如 <code>text/plain</code> 表示文本文件，<code>audio/aac</code> 表示音频文件。<br><strong>参考资料</strong>:</p><ul><li><a target="_blank" rel="noopener" href="https://www.emqx.com/zh/blog/mqtt5-new-features-payload-format-indicator-and-content-type">有效载荷标识与内容类型 - MQTT 5.0 新特性</a></li></ul></blockquote><ul><li>消息过期间隔<code>0x02</code> (<code>Message Expiry Interval</code>): 消息过期间隔只针对保留消息, 在<code>v3.1.1</code>版本中, 保留消息会永久存储在服务端(即使会话被删除), 当客户端异常离线, 会造成服务端资源没有释放导致风险, <code>v5.0</code>删除保留消息有两种方式:<ul><li>客户端往某个主题发送一个 <code>Payload</code> 为空的保留消息，服务端就会删除这个主题下的保留消息。</li><li>如果包含保留消息的 <code>PUBLISH</code> 报文设置了消息过期间隔属性，那么保留消息在服务端存储超过过期时间后就会被删除。即使消息还没有相匹配交付的订阅者。</li></ul></li></ul><blockquote><p><strong>参考</strong>:</p><ul><li><a target="_blank" rel="noopener" href="https://www.emqx.com/zh/blog/message-retention-and-message-expiration-interval-of-emqx-mqtt5-broker">EMQX MQTT 5.0 服务器的保留消息与消息过期间隔</a></li></ul></blockquote><ul><li>响应主题<code>0x08</code>(<code>Response Topic</code>): 响应主题是<code>v5.0</code>定义的新特性, 用于实现客户端向其他客户端请求数据的(<code>v3.1.1</code>只支持发布和订阅)。</li></ul><blockquote><p>  我们知道，在 <code>MQTT</code> 中客户端可以向指定主题发布消息，也可以订阅指定主题以接收感兴趣的消息。在明确有人订阅的情况下，大于 <code>0</code> 的 <code>QoS</code> 可以保证消息送达至订阅端 <code>1</code>。但如果结合一些业务场景，即不仅仅是将消息投递至订阅端，可能需要订阅端触发一些行为并返回结果，又或者是需要向订阅端请求一些信息，发布订阅模式下的实现就会稍显笨重，通信双方需要事先协商好请求主题和响应主题。</p></blockquote><p>  如果同一个请求主题存在多个请求方，为了将响应正确地返回给请求方，需要多个不同的响应主题，最常见的办法就是在 <code>Payload</code> 首部或是其他位置插入客户端标识符（<code>Client ID</code>）等能够唯一标识该请求客户端的字段，响应方在收到请求后按照事先约定的规则提取这些字段以及真正的 <code>Payload</code>，并将这些字段用于构造响应主题。</p><p><img src="/2023/05/23/linux/network/mqtt50/connect/084806/v311%E5%8D%8F%E8%AE%AE%E6%9E%84%E9%80%A0%E5%93%8D%E5%BA%94%E4%B8%BB%E9%A2%98.png" srcset="/img/loading.gif" lazyload alt="v311协议构造响应主题.png"></p><blockquote><p>  但显然这不是一个好的实现，我们期望请求接收方只需要关注怎么处理请求即可，而不用花费额外的精力考虑怎么将响应正确返回给请求方。因此，<code>MQTT 5.0</code> 新增了 响应主题（<code>Response Topic</code>） 属性，并定义了以下请求响应交互过程：</p><ol><li><code>MQTT</code> 客户端（请求方）向请求主题发布包含 响应主题 属性的请求消息。</li><li>假如有其他 <code>MQTT</code> 客户端（响应方）订阅了与请求消息发布时使用的主题名相匹配的主题过滤器，那么将收到该请求消息。</li><li>响应方根据请求消息采取适当的操作，然后向该 响应主题 属性指定的主题发布响应消息。</li></ol></blockquote><p><img src="/2023/05/23/linux/network/mqtt50/connect/084806/%E5%93%8D%E5%BA%94%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt="响应主题的交互流程.png"></p><ul><li>关联数据<code>0x09</code>(<code>Correlation Data</code>): 关联数据唯一标识一个请求响应。和响应主题属性一般一起使用。</li></ul><blockquote><p>  与 <code>HTTP</code> 的请求响应模式不同，<code>MQTT</code> 的请求响应是异步的，这带来了一个问题，即响应消息与请求消息如何关联。最常用的办法就是在请求消息中携带一个特征字段，响应方在响应时将收到的字段原封不动地返回，请求方在收到响应消息时就可以根据其中的特征字段来匹配相应的请求。很显然 <code>MQTT</code> 也是这么考虑的，所以为 <code>PUBLISH</code> 报文新增了一个 关联数据（<code>Correlation Data</code>） 属性。</p></blockquote><p><img src="/2023/05/23/linux/network/mqtt50/connect/084806/%E5%85%B3%E8%81%94%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="关联数据交互图.png"></p><blockquote><p><strong>参考资料</strong>:</p><ul><li><a target="_blank" rel="noopener" href="https://www.emqx.com/zh/blog/mqtt5-request-response">请求响应 - MQTT 5.0 新特性</a></li></ul></blockquote><ul><li>遗嘱延迟间隔<code>0x18</code>(<code>Will Delay Interval</code>): 定义客户端离线后, 延迟发布遗嘱的时间间隔(避免某些客户端短时间频繁离线导致服务端频繁发布遗嘱)。使用<code>mosquitto_pub</code>示例如下:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mosquitto_pub -h 192.168.125.29 -p 1883 -V 5 -q 1 -t cpu-rate -d  -x 60 -l -D WILL Will-Delay-Interval 30  --will-topic <span class="hljs-string">&#x27;will-topic&#x27;</span>  --will-payload <span class="hljs-string">&#x27;this is a will payload&#x27;</span> --will-qos 1 -i <span class="hljs-string">&#x27;mqtt-client-type&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>用户属性<code>0x26</code>(<code>User Property</code>): 用户可以自定义的属性, 以<code>k-v</code>的形式存在。这里需要注意:</li></ul><blockquote><ul><li>用户属性在<code>connect</code>报文时, 只有服务端可见, 后续<code>publish</code>报文中无法感知这些属性。<br><strong>参考资料</strong>:</li><li><a target="_blank" rel="noopener" href="https://www.emqx.com/zh/blog/mqtt5-user-properties">用户属性 - MQTT 5.0 新特性</a></li></ul></blockquote><hr><p>同样<code>CONNECT</code>属性有如下几种:</p><table><thead><tr><th style="text-align:center"><code>Packet / Will Properties</code></th><th style="text-align:center"><code>hex</code></th><th style="text-align:center"><code>Name (usage)</code></th><th style="text-align:center"><code>Type</code></th></tr></thead><tbody><tr><td style="text-align:center"><code>CONNECT</code></td><td style="text-align:center"><code>0x11</code></td><td style="text-align:center"><code>Session Expiry Interval</code></td><td style="text-align:center"><code>Four Byte Integer</code></td></tr><tr><td style="text-align:center"><code>CONNECT</code></td><td style="text-align:center"><code>0x15</code></td><td style="text-align:center"><code>Authentication Method</code></td><td style="text-align:center"><code>UTF-8 Encoded String</code></td></tr><tr><td style="text-align:center"><code>CONNECT</code></td><td style="text-align:center"><code>0x16</code></td><td style="text-align:center"><code>Authentication Data</code></td><td style="text-align:center"><code>Binary Data</code></td></tr><tr><td style="text-align:center"><code>CONNECT</code></td><td style="text-align:center"><code>0x17</code></td><td style="text-align:center"><code>Request Problem Information</code></td><td style="text-align:center"><code>Byte</code></td></tr><tr><td style="text-align:center"><code>CONNECT</code></td><td style="text-align:center"><code>0x19</code></td><td style="text-align:center"><code>Request Response Information</code></td><td style="text-align:center"><code>Byte</code></td></tr><tr><td style="text-align:center"><code>CONNECT</code></td><td style="text-align:center"><code>0x21</code></td><td style="text-align:center"><code>Receive Maximum</code></td><td style="text-align:center"><code>Two Byte Integer</code></td></tr><tr><td style="text-align:center"><code>CONNECT</code></td><td style="text-align:center"><code>0x22</code></td><td style="text-align:center"><code>Topic Alias Maximum</code></td><td style="text-align:center"><code>Two Byte Integer</code></td></tr><tr><td style="text-align:center"><code>CONNECT</code></td><td style="text-align:center"><code>0x26</code></td><td style="text-align:center"><code>User Property</code></td><td style="text-align:center"><code>UTF-8 String Pair</code></td></tr><tr><td style="text-align:center"><code>CONNECT</code></td><td style="text-align:center"><code>0x27</code></td><td style="text-align:center"><code>Maximum Packet Size</code></td><td style="text-align:center"><code>Four Byte Integer</code></td></tr></tbody></table><ul><li>会话期望间隔<code>0x11</code>(<code>Session Expiry Interval</code>): 标识符。跟随其后的是用四字节整数表示的以秒为单位的会话过期间隔（<code>Session Expiry Interval</code>）。包含多个会话过期间隔（<code>Session Expiry Interval</code>）将造成协议错误（<code>Protocol Error</code>）。</li></ul><blockquote><p>  如果会话过期间隔（<code>Session Expiry Interval</code>）值未指定，则使用 <code>0</code>。如果设置为 <code>0</code> 或者未指定，会话将在网络连接（<code>Network Connection</code>）关闭时结束。如果会话过期间隔（<code>Session Expiry Interval</code>）为 <code>0xFFFFFFFF(UINT_MAX)</code>，则会话永不过期。</p><p>会话过期值在<code>clean Start</code>标志为<code>1</code>时无效。服务端清除会话内容, 重连时使用<code>clean Start</code>为<code>0</code>值获取服务端会话状态, 如果存在, 不需要重新进行话题订阅, 同时在断连期间话题接受得内容也会在重连成功时由服务端下发。</p><p>  <code>MQTT v3.1.1</code> 没有规定持久会话应该在什么时候过期，但在实际场景中会话会占用服务端的资源, 因此<code>v5.0</code>协议引入会话过期字段。</p><p><strong>会话生命周期与 <code>Clean Session</code> 关系</strong></p></blockquote><p><img src="/2023/05/23/linux/network/mqtt50/connect/084806/%E4%BC%9A%E8%AF%9D%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8EcleanSession%E5%85%B3%E7%B3%BB2.png" srcset="/img/loading.gif" lazyload alt="会话生命周期与cleanSession关系.png"></p><blockquote><p><code>MQTT v5.0</code> 提供了 <code>Clean Start</code> 与 <code>Session Expiry Interval</code> 来分别决定是否启用会话持久化，以及会话的过期时间，会话生命周期与两者关系如下：</p></blockquote><p><img src="/2023/05/23/linux/network/mqtt50/connect/084806/CleanStart%E4%B8%8ESessionExpiryInterva%E5%85%B3%E7%B3%BB.png" srcset="/img/loading.gif" lazyload alt="CleanStart与SessionExpiryInterva关系.png"></p><blockquote><p>  通常情况下, 服务端只保证<code>qos1/qos2</code>质量消息的可靠到达, <code>qos0</code>消息在客户端离线后, 服务端会话是否保存取决于服务端设计。</p></blockquote><hr><ul><li>认证方法<code>0x15</code>(<code>Authentication Method</code>):</li><li>认证数据<code>0x16</code>(<code>Authentication Data</code>):</li><li>请求问题信息<code>0x17</code>(<code>Request Problem Information</code>): 客户端使用此值指示遇到错误时是否发送原因字符串（<code>Reason String</code>）或用户属性（<code>User Properties</code>）, 跟随其后的是用一个字节表示的 0 或 1, 包含多个请求问题信息或者值不为0或者1将导致协议错误。如果没有请求问题信息, 默认值为1。</li></ul><blockquote><ul><li>如果请求问题信息的值为 0，服务端可以选择在 <code>CONNACK</code> 或 <code>DISCONNECT</code> 报文中返回原因字符串（<code>Reason String</code>）或用户属性（<code>User Properties</code>），但不能在除 <code>PUBLISH</code>， <code>CONNACK</code> 或 <code>DISCONNECT</code> 之外的报文中发送原因字符串（<code>Reason String</code>）或用户属性（<code>User Properties</code>） 。并且在除 <code>PUBLISH</code>， <code>CONNACK</code> 或 <code>DISCONNECT</code> 之外的报文中收到了原因字符串（<code>Reason String</code>）或用户属性（<code>User Properties</code>），客户端将发送一个包含原因码 <code>0x82</code>（协议错误） 的 <code>DISCONNECT</code> 报文给服务端。</li><li>如果此值为 1，服务端可以在任何被允许的报文中返回原因字符串（<code>Reason String</code>）或用户属性（<code>User Properties</code>）。</li></ul></blockquote><ul><li>请求响应信息<code>0x19</code>(<code>Request Response Information</code>): 客户端使用此值向服务端请求 <code>CONNACK</code> 报文中的响应信息（<code>Response Information</code>）。 值为 0，表示服务端不能返回响应信息。值为 1，表示服务端可以在 <code>CONNACK</code> 报文中返回响应信息。</li></ul><blockquote><p>跟随其后的是用一个字节表示的 0 或 1。包含多个请求响应信息（<code>Request Response Information</code>） ，或者请求响应信息（<code>Request Response Information</code>） 的值既不为 0 也不为 1 会造成协议错误（<code>Protocol Error</code>） 。如果没有请求响应信息（<code>Request Response Information</code>） ，则请求响应默认值为 0。</p></blockquote><ul><li><p>最大接收报文<code>0x21</code>(<code>Receive Maximum</code>): 该属性是由双字节整数表示的最大接收值， 表示设备端愿意同时处理的 <code>QoS</code> 等级 1 和 <code>QoS</code> 等级 2 的发布消息最大数量, 超出数量的<code>QOS1/QOS2</code> 服务端应该限制发送。接收最大值只将被应用在当前网络连接。如果没有设置最大接收值，将使用默认值 <code>65535</code>。</p></li><li><p>主题别名最大值<code>0x22</code>(<code>Topic Alias Maximum</code>): 此值指示了客户端能够接收的来自服务端的主题别名（<code>Topic Alias</code>） 最大数量。客户端使用此值来限制本次连接可以拥有的主题别名的数量。 服务端在一个 <code>PUBLISH</code> 报文中发送的主题别名不能超过客户端设置的主题别名最大值（<code>Topic Alias Maximum</code>）</p></li></ul><blockquote><ul><li>值为零表示本次连接客户端不接受任何主题别名（<code>Topic Alias</code>）</li><li>如果主题别名最大值（<code>Topic Alias</code>）没有设置，或者设置为零，则服务端不能向此客户端发送任何主题别名（<code>Topic Alias</code>）</li></ul></blockquote><ul><li><p>用户属性<code>0x26</code>(<code>User Property</code>): 用户属性（<code>User Property</code>）可以出现多次，表示多个名字/值对。 相同的名字可以出现多次。</p></li><li><p>最大包长度<code>0x27</code>(<code>Maximum Packet Size</code>): 最大报文长度（<code>Maximum Packet Size</code>）标识符</p></li></ul><blockquote><ul><li>跟随其后的是由四字节整数表示的客户端愿意接收的最大报文长度（<code>Maximum Packet Size</code>），如果没有设置最大报文长度（<code>Maximum Packet Size</code>），则按照协议由固定报头中的剩余长度可编码最大值和协议报头对数据包的大小做限制。</li><li>包含多个最大报文长度（<code>Maximum Packet Size</code>）或者最大报文长度（<code>Maximum Packet Size</code>）值为 0 将造成协议错误。</li><li>服务端不能发送超过最大报文长度（<code>Maximum Packet Size</code>）的报文给客户端 。收到长度超过限制的报文将导致协议错误，客户端发送包含原因码<code>0x95</code>（报文过大）的 <code>DISCONNECT</code> 报文给服务</li></ul></blockquote><hr><h4 id="32-connack"><a class="markdownIt-Anchor" href="#32-connack"></a> 3.2 CONNACK</h4><p>  服务端用<code>CONNACK</code>指示一次<code>CONNECT</code>连接的结果, 在<code>v3.1.1</code>协议中, 服务端发送给客户端的第一个报文必须是 <code>CONNACK</code>, 但是在<code>v5.0</code>协议中还可以是<code>AUTH</code>交互认证报文。</p><h5 id="321-固定报头"><a class="markdownIt-Anchor" href="#321-固定报头"></a> 3.2.1 固定报头</h5><p><img src="/2023/05/23/linux/network/mqtt50/connect/084806/connect-ack%E5%9B%BA%E5%AE%9A%E6%8A%A5%E5%A4%B4.png" srcset="/img/loading.gif" lazyload alt="connect-ack固定报头.png"></p><h5 id="322-可变报头"><a class="markdownIt-Anchor" href="#322-可变报头"></a> 3.2.2 可变报头</h5><p><code>CONNACK</code> 报文的可变报头按顺序包含以下字段：连接确认标志（<code>Connect Acknowledge Flags</code>），连接原因码（<code>Reason Code</code>），属性（<code>Properties</code>）。</p><h6 id="3221-连接确认标志"><a class="markdownIt-Anchor" href="#3221-连接确认标志"></a> 3.2.2.1 连接确认标志</h6><blockquote><ul><li>第 1 个字节是连接确认标志，位 7-1 是保留位且必须设置为 0</li><li>第 0（<code>SP</code>）位是会话存在标志（<code>Session Present Flag</code>）</li></ul></blockquote><h6 id="3222-连接原因码"><a class="markdownIt-Anchor" href="#3222-连接原因码"></a> 3.2.2.2 连接原因码</h6><blockquote><p>可变报头中第 2 个字节是连接原因码（<code>Reason Code</code>）, 当客户端发起连接时服务端进行响应。如果服务端发送了一个包含原因码大于等于 <code>128</code> 的 <code>CONNACK</code> 报文，它随后必须关闭网络连接</p></blockquote><p><img src="/2023/05/23/linux/network/mqtt50/connect/084806/connack%E5%8E%9F%E5%9B%A0%E7%A0%81.png" srcset="/img/loading.gif" lazyload alt="connack原因码.png"></p><blockquote><ul><li>原因码 <code>0x80</code>（未指明的错误）可以被用作：服务器知道失败的原因但是并不希望透露给客户端，或者没有其他适用的原因码。</li><li>出于安全考虑，发现 <code>CONNECT</code> 出错时服务端可以选择不发送 <code>CONNACK</code> 报文而关闭网络连接。例如，在公网中向未被授权的网络连接告知自身 <code>MQTT</code> 服务端身份并不明智</li></ul></blockquote><hr><h6 id="3223-connack-属性"><a class="markdownIt-Anchor" href="#3223-connack-属性"></a> 3.2.2.3 CONNACK 属性</h6><table><thead><tr><th style="text-align:center"><code>Packet / Will Properties</code></th><th style="text-align:center"><code>hex</code></th><th style="text-align:center"><code>Name (usage)</code></th><th style="text-align:center"><code>Type</code></th></tr></thead><tbody><tr><td style="text-align:center"><code>CONNACK</code></td><td style="text-align:center"><code>0x11</code></td><td style="text-align:center"><code>Session Expiry Interval</code></td><td style="text-align:center"><code>Four Byte Integer</code></td></tr><tr><td style="text-align:center"><code>CONNACK</code></td><td style="text-align:center"><code>0x12</code></td><td style="text-align:center"><code>Assigned Client Identifier</code></td><td style="text-align:center"><code>UTF-8 Encoded String</code></td></tr><tr><td style="text-align:center"><code>CONNACK</code></td><td style="text-align:center"><code>0x13</code></td><td style="text-align:center"><code>Server Keep Alive</code></td><td style="text-align:center"><code>Two Byte Integer</code></td></tr><tr><td style="text-align:center"><code>CONNACK</code></td><td style="text-align:center"><code>0x15</code></td><td style="text-align:center"><code>Authentication Method</code></td><td style="text-align:center"><code>UTF-8 Encoded String</code></td></tr><tr><td style="text-align:center"><code>CONNACK</code></td><td style="text-align:center"><code>0x16</code></td><td style="text-align:center"><code>Authentication Data</code></td><td style="text-align:center"><code>Binary Data</code></td></tr><tr><td style="text-align:center"><code>CONNACK</code></td><td style="text-align:center"><code>0x1A</code></td><td style="text-align:center"><code>Response Information</code></td><td style="text-align:center"><code>UTF-8 Encoded String</code></td></tr><tr><td style="text-align:center"><code>CONNACK</code></td><td style="text-align:center"><code>0x1C</code></td><td style="text-align:center"><code>Server Reference</code></td><td style="text-align:center"><code>UTF-8 Encoded String</code></td></tr><tr><td style="text-align:center"><code>CONNACK</code></td><td style="text-align:center"><code>0x1F</code></td><td style="text-align:center"><code>Reason String</code></td><td style="text-align:center"><code>UTF-8 Encoded String</code></td></tr><tr><td style="text-align:center"><code>CONNACK</code></td><td style="text-align:center"><code>0x21</code></td><td style="text-align:center"><code>Receive Maximum</code></td><td style="text-align:center"><code>Two Byte Integer</code></td></tr><tr><td style="text-align:center"><code>CONNACK</code></td><td style="text-align:center"><code>0x22</code></td><td style="text-align:center"><code>Topic Alias Maximum</code></td><td style="text-align:center"><code>Two Byte Integer</code></td></tr><tr><td style="text-align:center"><code>CONNACK</code></td><td style="text-align:center"><code>0x24</code></td><td style="text-align:center"><code>Maximum QoS</code></td><td style="text-align:center"><code>Byte</code></td></tr><tr><td style="text-align:center"><code>CONNACK</code></td><td style="text-align:center"><code>0x25</code></td><td style="text-align:center"><code>Retain Available</code></td><td style="text-align:center"><code>Byte</code></td></tr><tr><td style="text-align:center"><code>CONNACK</code></td><td style="text-align:center"><code>0x26</code></td><td style="text-align:center"><code>User Property</code></td><td style="text-align:center"><code>UTF-8 String Pair</code></td></tr><tr><td style="text-align:center"><code>CONNACK</code></td><td style="text-align:center"><code>0x27</code></td><td style="text-align:center"><code>Maximum Packet Size</code></td><td style="text-align:center"><code>Four Byte Integer</code></td></tr><tr><td style="text-align:center"><code>CONNACK</code></td><td style="text-align:center"><code>0x28</code></td><td style="text-align:center"><code>Wildcard Subscription Available</code></td><td style="text-align:center"><code>Byte</code></td></tr><tr><td style="text-align:center"><code>CONNACK</code></td><td style="text-align:center"><code>0x29</code></td><td style="text-align:center"><code>Subscription Identifier Available</code></td><td style="text-align:center"><code>Byte</code></td></tr><tr><td style="text-align:center"><code>CONNACK</code></td><td style="text-align:center"><code>0x2A</code></td><td style="text-align:center"><code>Shared Subscription Available</code></td><td style="text-align:center"><code>Byte</code></td></tr></tbody></table><ul><li>会话过期间隔(<code>0x11</code>): 请参考<code>CONNECT</code>报文属性。</li></ul><blockquote><ul><li>如果会话过期间隔（<code>Session Expiry Interval</code>）值未指定，则使用 <code>CONNECT</code> 报文中指定的会话过期时间间隔。</li><li>如果指定了, 服务端使用此属性通知客户端它使用的会话过期时间间隔与客户端在 <code>CONNECT</code> 中发送的值不同。客户端应该使用二者之间较小值作为会话过期间隔。</li></ul></blockquote><ul><li>分配客户标识符(<code>0x12</code>): 该标识符是一个<code>UTF-8</code>编码的字符串， 包含多个分配客户端标识符将造成协议错误。</li></ul><blockquote><ul><li><code>v5.0</code>协议支持服务端为客户端唯一分配客户端标识符, 并通过<code>connack</code>的该属性进行返回。</li><li>如果客户端使用长度为 0 的客户标识符（<code>ClientID</code>），服务端必须回复包含分配客户标识符（<code>Assigned Client Identifier</code>）的 <code>CONNACK</code> 报文。分配客户标识符必须是没有被服务端的其他会话所使用的新客户标识符。</li></ul></blockquote><ul><li>服务端保持连接(<code>0x13</code>): 服务端指明的连接保活时间。</li></ul><blockquote><ul><li>如果服务端发送了服务端保持连接（<code>Server Keep Alive</code>）属性，客户端必须使用此值代替其在 <code>CONNECT</code> 报文中发送的保持连接时间 值。</li><li>如果服务端没有发送服务端保持连接属性，服务端必须使用客户端在 <code>CONNECT</code> 报 文中设置的保持连接时间值</li></ul></blockquote><ul><li><p>认证方法(<code>0x15</code>): 用于<code>AUTH</code> 交互认证</p></li><li><p>认证数据(<code>0x16</code>): 用于<code>AUTH</code> 交互认证</p></li><li><p>响应信息(<code>0x1A</code>): 响应信息属性通常和 <strong>请求响应</strong> 属性相关联, <code>v5.0</code>协议允许客户端主动请求另一个客户端数据, 但是当存在多个请求方同时发起请求的情况,为避免不同请求方之间的冲突，请求方客户端使用的响应主题最好对于该客户端是唯一的。由于请求方和响应方通常都需要对这些主题进行授权，因此使用随机主题名称将会对授权造成挑战。</p></li></ul><blockquote><p>  为了解决此问题，<code>MQTT5.0</code>在<code>CONNACK</code>报文中定义了一个名为 <strong>响应信息</strong> 的属性。服务端可以使用此属性指导客户端如何选择使用的响应主题。此机制对于服务端和客户端都是可选的。连接时，客户端通过设置<code>CONNECT</code>报文中的请求响应信息属性来请求服务端发送响应信息。这会导致服务端在<code>CONNACK</code>报文中插入响应信息属性，请求方可以使用响应信息来构建响应主题。</p></blockquote><p><img src="/2023/05/23/linux/network/mqtt50/connect/084806/%E5%93%8D%E5%BA%94%E4%BF%A1%E6%81%AF%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt="响应信息交互流程.png"></p><blockquote><p><strong>参考资料</strong></p><ul><li><a target="_blank" rel="noopener" href="https://www.163.com/dy/article/HVQ26CI705528VE3.html">请求响应–MQTT 5.0新特性</a></li></ul></blockquote><p><strong>示例:</strong><br>请求:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mosquitto_pub  -h 192.168.125.29 -p 1883 -V 5 -q 1 -t cpu-rate -d  -x 60 -l -P passwd -D CONNECT  Request-Response-Information 1 --will-topic <span class="hljs-string">&#x27;will-topic&#x27;</span>  --will-payload <span class="hljs-string">&#x27;this is a will payload&#x27;</span> --will-qos 1<br></code></pre></td></tr></table></figure><p><strong>输出抓包:</strong></p><p><img src="/2023/05/23/linux/network/mqtt50/connect/084806/%E5%93%8D%E5%BA%94%E4%BF%A1%E6%81%AF%E6%8A%93%E5%8C%85.png" srcset="/img/loading.gif" lazyload alt="响应信息抓包.png"></p><p>服务端可以根据不同客户端返回不同的响应信息已组成客户端的响应主题。</p><ul><li>服务端参考(<code>0x1c</code>)(<code>Server Reference</code>): 服务端在包含了原因码为 <code>0x9C</code>（（临时） 使用其他服务端）或 <code>0x9D</code>（服务端已（永久） 移动）的<code>CONNACK</code> 报文或 <code>DISCONNECT</code> 报文中设置服务端参考。</li></ul><blockquote><ul><li>跟随其后的是一个以 <code>UTF-8</code> 编码的字符串，可以被客户端用来标识其他可用的服务端。包含多个服务端参考（<code>Server Reference</code>）将造成协议错误（<code>Protocol Error</code>）。</li></ul></blockquote><ul><li>原因字符串<code>0x1F</code>(<code>Reason String</code>): 服务端使用此值向客户端提供附加信息。 如果加上原因字符串之后的 <code>CONNACK</code> 报文长度超出了客户端指定的最大报文长度，则服务端不能发送此原因字符串。 包含多个原因字符串将造成协议错误（<code>Protocol Error</code>）。</li></ul><blockquote><ul><li>跟随其后的是 <code>UTF-8</code> 编码的字符串，表示此次响应相关的原因。此原因字符串（<code>Reason String</code>）是为诊断而设计的可读字符串， 不应该被客户端所解析。</li></ul></blockquote><ul><li>接收最大值<code>0x21</code>(<code>Receive Maximum</code>): 服务端使用此值限制服务端愿意为该客户端同时处理的 <code>QoS</code> 为 1 和 <code>QoS</code> 为 2 的发布消息最大数量。 没有机制可以限制客户端试图发送的 <code>QoS</code> 为 0 的发布消息。</li></ul><blockquote><ul><li>跟随其后的是由双字节整数表示的最大接收值。包含多个接收最大值或接收最大值为 0 将造成协议错误（<code>Protocol Error</code>）。</li></ul></blockquote><ul><li>主题别名最大值<code>0x22</code>(<code>Topic Alias Maximum</code>): 此值指示了服务端能够接收的来自客户端的主题别名（<code>Topic Alias</code>）最大值。</li></ul><blockquote><ul><li>服务端使用此值来限制本次连接可以拥有的主题别名的值。 客户端在一个 PUBLISH 报文中发送的主题别名值不能超过服务端设置的主题别名最大值（<code>Topic Alias Maximum</code>）。</li><li>值为 <code>0</code> 表示本次连接服务端不接受任何主题别名（<code>Topic Alias</code>）。 如果主题别名最大值（<code>Topic Alias</code>）没有设置，或者设置为 0，则客户端不能向此服务端发送任何主题别名（<code>Topic Alias</code>）</li></ul></blockquote><ul><li>最大服务质量标识符<code>0x24</code>(<code>Maximum QoS</code>): 指示服务端最大支持的服务质量等级。</li><li>保留可用<code>0x25</code>(<code>Retain Available</code>): 用于表明服务端是否支持保留消息(<code>0</code>:不支持 <code>1</code>: 支持)</li><li>用户属性<code>0x26</code>(<code>User Property</code>): 服务端和设备端传递的属性</li><li>最大报文长度<code>0x27</code>(<code>Maximum Packet Size</code>): 定义客户端发送的最大报文长度。</li><li>通配符订阅可用<code>0x28</code>(<code>Wildcard Subscription Available</code>): 指示服务端是否支持通配符订阅主题。(<code>0</code>: 不支持 <code>1</code>: 支持)</li><li>订阅标识符可用<code>0x29</code>(<code>Subscription Identifier Available</code>): 指示服务端是否支持订阅标识符。(<code>0</code>:不支持 <code>1</code>: 支持 支持的话客户端可以在接下来的订阅话题过程中使用<code>Subscription Identifier</code>属性来指定订阅标识符。)这样做可以有效提高消息分发和处理速度, 但是数据包会增加几个字节。</li></ul><blockquote><ul><li>客户端可以在订阅时指定一个订阅标识符，服务端将在订阅成功创建或修改时建立并存储该订阅与订阅标识符的映射关系。当有匹配该订阅的 <code>PUBLISH</code> 报文要转发给此客户端时，服务端会将与该订阅关联的订阅标识符随 <code>PUBLISH</code> 报文一并返回给客户端, (报文本身也包含<code>topic</code>)。 这样对于算力有限的客户端, 客户端可以建立订阅标识符与消息处理程序的映射，以在收到 <code>PUBLISH</code> 报文时直接通过订阅标识符将消息定向至对应的消息处理程序，这会远远快于通过主题匹配来查找消息处理程序的速度。</li><li>由于 <code>SUBSCRIBE</code> 报文支持包含多个订阅，因此可能出现多个订阅关联到同一个订阅标识符的情况。以下是几种常见的情况：</li></ul><blockquote><ol><li>客户端订阅主题 a 并指定订阅标识符为 <code>1</code>，订阅主题 <code>b</code> 并指定订阅标识符为 <code>2</code>。由于使用了不同的订阅标识符，主题为 <code>a</code> 和 <code>b</code> 的消息能够被定向至不同的消息处理程序。</li><li>客户端订阅主题 <code>a</code> 并指定订阅标识符为 <code>1</code>，订阅主题 <code>b</code> 并指定订阅标识符为 <code>1</code>。由于使用了相同的订阅标识符，主题为 <code>a</code> 和 <code>b</code> 的消息都将被定向至同一个消息处理程序。</li><li>客户端订阅主题 <code>a/+</code> 并指定订阅标识符为 <code>1</code>，订阅主题 <code>a/b</code> 并指定订阅标识符为 <code>1</code>。主题为 <code>a/b</code> 的 <code>PUBLISH</code> 报文将会携带两个相同的订阅标识符，对应的消息处理程序将被触发两次。</li><li>客户端订阅主题 <code>a/+</code> 并指定订阅标识符为 <code>1</code>，订阅主题 <code>a/b</code> 并指定订阅标识符为 <code>2</code>。主题为 <code>a/b</code> 的 <code>PUBLISH</code> 报文将会携带两个不同的订阅标识符，一个消息将触发两个不同的消息处理程序。</li></ol></blockquote></blockquote><p><img src="/2023/05/23/linux/network/mqtt50/connect/084806/%E8%AE%A2%E9%98%85%E6%A0%87%E8%AF%86%E7%AC%A6%E6%8A%93%E5%8C%85%E5%AF%B9%E6%AF%94.png" srcset="/img/loading.gif" lazyload alt="订阅标识符抓包对比.png"></p><ul><li>共享订阅可用<code>0x2A</code>(<code>Shared Subscription Available</code>): 用来声明服务端是否支持共享订阅(<code>0</code>: 不支持 <code>1</code>: 支持)</li></ul><blockquote><ul><li>共享订阅是多个客户端订阅一个话题, 当向该话题推送一个消息时, 消息会根据服务端策略从这几个客户端选一个进行消息代理转发。及共享订阅中的消息只有一个消费者，可以根据不同策略实现负载均衡。</li><li><strong>格式</strong>: 共享订阅需要以<code>$share/&#123;shareName&#125;/&#123;filter&#125;</code>为基本格式, 表示其为共享订阅话题。实际消息发布时不需要加<code>$share/&#123;shareName&#125;</code>。</li></ul><blockquote><ul><li><code>$share</code> 前缀表明这将是一个共享订阅</li><li><code>&#123;ShareName&#125;</code> 是一个不包含 <code>&quot;/&quot;, &quot;+&quot;</code> 以及 <code>&quot;#&quot;</code> 的字符串。订阅会话通过使用相同的<code>&#123;ShareName&#125;</code> 表示共享同一个订阅，匹配该订阅的消息每次只会发布给其中一个会话。</li></ul></blockquote><ul><li><code>&#123;filter&#125;</code> 即非共享订阅中的主题过滤器</li></ul></blockquote><blockquote><p><strong>示例</strong>:<br>客户端<code>1</code>和客户端<code>2</code>订阅共享话题<code>will-topic</code>, 将其加入一个会话组<code>a</code>, 也就是说在会话组<code>a</code>中, 消息是均衡的, 可以客户端<code>1</code>订阅话题<code>$share/a/will-topic</code>, 客户端<code>2</code>订阅<code>$share/a/will-topic</code>。此时二者加入会话<code>a</code>并共享主题<code>will-topic</code>。抓包如下:</p></blockquote><p><img src="/2023/05/23/linux/network/mqtt50/connect/084806/%E5%85%B1%E4%BA%AB%E8%AE%A2%E9%98%85%E6%8A%A5%E6%96%87.png" srcset="/img/loading.gif" lazyload alt="共享订阅报文.png"></p><blockquote><p><strong>共享订阅转发</strong>:</p></blockquote><p><img src="/2023/05/23/linux/network/mqtt50/connect/084806/%E5%85%B1%E4%BA%AB%E8%AE%A2%E9%98%85%E8%BD%AC%E5%8F%91%E6%8A%A5%E6%96%87.png" srcset="/img/loading.gif" lazyload alt="共享订阅转发报文.png"></p><hr><h5 id="323-有效载荷"><a class="markdownIt-Anchor" href="#323-有效载荷"></a> 3.2.3 有效载荷</h5><p><code>CONNACK</code> 报文没有有效载荷</p><hr><h4 id="33-disconnect"><a class="markdownIt-Anchor" href="#33-disconnect"></a> 3.3 DISCONNECT</h4><p>  <code>DISCONNECT</code> 报文是客户端发给服务端的最后一个 <code>MQTT</code> 控制报文。表示客户端为什么断开网络连接的原因。 客户端和服务端在关闭网络连接之前可以发送一个 <code>DISCONNECT</code> 报文。如果在客户端没有首先发送包含原因码为 <code>0x00</code>（正常断开） <code>DISCONNECT</code> 报文并且连接包含遗嘱消息的情况下，遗嘱消息会被发布。</p><ul><li>服务端不能发送 <code>DISCONNECT</code> 报文，直到它发送了包含原因码小于 <code>0x80</code> 的 <code>CONNACK</code> 报文之后。</li></ul><h5 id="331-固定报头"><a class="markdownIt-Anchor" href="#331-固定报头"></a> 3.3.1 固定报头</h5><p><img src="/2023/05/23/linux/network/mqtt50/connect/084806/disconnect%E5%9B%BA%E5%AE%9A%E6%8A%A5%E5%A4%B4.png" srcset="/img/loading.gif" lazyload alt="disconnect固定报头.png"></p><p>服务端必须验证所有的保留位都被设置为 <code>0</code>， 如果它们不为 <code>0</code> 必须断开连接</p><h5 id="332-可变报头"><a class="markdownIt-Anchor" href="#332-可变报头"></a> 3.3.2 可变报头</h5><p><code>DISCONNECT</code> 报文的可变报头按顺序包含以下字段：断开原因码，属性（<code>Properties</code>）。</p><h5 id="3321-原因码"><a class="markdownIt-Anchor" href="#3321-原因码"></a> 3.3.2.1 原因码</h5><p>  可变报头的第 <code>1</code> 个字节是断开原因码。如果剩余长度小于<code>1</code>，则表示使用原因码 <code>0x00</code>（正常断开）。</p><p><img src="/2023/05/23/linux/network/mqtt50/connect/084806/disconnect%E5%8E%9F%E5%9B%A0%E7%A0%81.png" srcset="/img/loading.gif" lazyload alt="disconnect原因码.png"></p><p>客户端或服务端发送 <code>DISCONNECT</code> 报文时必须使用一种 <code>DISCONNECT</code> 原因码。如果原因码为 <code>0x00</code>（正常断开）且没有属性，原因码和属性长度可以被省略。这种情况下 <code>DISCONNECT</code> 报文剩余长度为 <code>0</code>。</p><ul><li>客户端可以使用这些信息来决定是否重新连接，以及在重新尝试之前应该等待多长时间。</li></ul><h6 id="3322-属性"><a class="markdownIt-Anchor" href="#3322-属性"></a> 3.3.2.2 属性</h6><table><thead><tr><th style="text-align:center"><code>Packet / Will Properties</code></th><th style="text-align:center"><code>hex</code></th><th style="text-align:center"><code>Name (usage)</code></th><th style="text-align:center"><code>Type</code></th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><code>DISCONNECT</code></td><td style="text-align:center"><code>0x11</code></td><td style="text-align:center"><code>Session Expiry Interval</code></td><td style="text-align:center"><code>Four Byte Integer</code></td><td style="text-align:center">会话过期间隔</td></tr><tr><td style="text-align:center"><code>DISCONNECT</code></td><td style="text-align:center"><code>0x1F</code></td><td style="text-align:center"><code>Reason String</code></td><td style="text-align:center"><code>UTF-8 Encoded String</code></td><td style="text-align:center">原因码</td></tr><tr><td style="text-align:center"><code>DISCONNECT</code></td><td style="text-align:center"><code>0x26</code></td><td style="text-align:center"><code>User Property</code></td><td style="text-align:center"><code>UTF-8 String Pair</code></td><td style="text-align:center">用户属性(<code>k-v</code>)</td></tr><tr><td style="text-align:center"><code>DISCONNECT</code></td><td style="text-align:center"><code>0x1C</code></td><td style="text-align:center"><code>Server Reference</code></td><td style="text-align:center"><code>UTF-8 String Pair</code></td><td style="text-align:center">服务端参考标识符</td></tr></tbody></table><ul><li>服务端参考标识符<code>0x1c</code>(<code>Server Reference</code>):</li></ul><blockquote><p>  跟随其后的是一个 <code>UTF-8</code> 编码字符串，客户端可以使用它来识别其他要使用的服务端。包含多个服务端参考将造成协议错误（<code>Protocol Error</code>）</p><p>  服务端可以通过发送包含原因码为 <code>0x9C</code>（（临时）使用其他服务端）或<code>0x9D</code>（服务端已（永久）移动）的 <code>CONNACK</code> 或 <code>DISCONNECT</code> 报文请求客户端使用另一台服务端，服务端发送这些原因码时可以包含一个服务端参考属性，用以说明客户端应该使用的服务端位置。</p><ul><li>原因码 <code>0x9C</code> （（临时）使用其他服务端） 指定客户端应该临时切换到另一台服务端。另一台服务端可能是客户端已知的，也可能是由服务端参考所指定的。</li><li>原因码 <code>0x9D</code>（服务端已（永久）移动）指定客户端应该永久切换到另一台服务端。另一台服务端可能是客户端已知的，也可能是由服务端参考所指定的。</li></ul><p>服务端参考是一个 <code>UTF-8</code> 编码字符串，其值是一个由空格分隔开的参考列表。本规范不指定服务端参考的格式。</p><p>推荐每个参考包含名称及可选的端口号。如果名称包含冒号，则名称字符串可以由方括号括起来（“[“和“]”）。由方括号括起来的名称不能包含右方括号(“]”)字符，用于表示使用冒号分隔符的 IPv6地址。<br>如:</p><ul><li><code>myserver.xyz.org</code></li><li><code>myserver.xyz.org:8883</code></li><li><code>10.10.151.22:8883 [fe80::9610:3eff:fe1c]:1883</code></li></ul><p>允许服务端不发送服务端参考，允许客户端忽略服务端参考。此特性可用于负载均衡、服务端重定位和服务端预置服务端。</p></blockquote><p><img src="/2023/05/23/linux/network/mqtt50/connect/084806/disconnect%E6%8A%A5%E6%96%87%E5%8F%AF%E5%8F%98%E6%8A%A5%E5%A4%B4.png" srcset="/img/loading.gif" lazyload alt="disconnect报文可变报头.png"></p><h5 id="333-有效载荷"><a class="markdownIt-Anchor" href="#333-有效载荷"></a> 3.3.3 有效载荷</h5><p><code>DISCONNECT</code> 报文没有有效载荷</p><ul><li>发送端发送完 <code>DISCONNECT</code> 报文之后：</li></ul><blockquote><ul><li>不能再在此网络连接上发送任何 <code>MQTT</code> 控制报文</li><li>必须关闭网络连接</li></ul></blockquote><ul><li>接收到包含原因码为 <code>0x00</code>（成功）的 <code>DISCONNECT</code> 时，服务端：</li></ul><blockquote><ul><li>必须丢弃任何与当前连接相关的遗嘱消息，而不发布它</li></ul></blockquote><ul><li>接收到 DISCONNECT 报文时，接收端</li></ul><blockquote><ul><li>应该关闭网络连接</li></ul></blockquote><hr><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><ul><li><a target="_blank" rel="noopener" href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901029">MQTT Version 5.0</a></li><li><a target="_blank" rel="noopener" href="http://mqtt.p2hp.com/mqtt-5-0">MQTT协议5.0中文版</a></li><li><a target="_blank" rel="noopener" href="https://www.emqx.com/zh/blog/mqtt-session">MQTT 持久会话与 Clean Session 详解</a></li><li><a target="_blank" rel="noopener" href="https://www.emqx.io/docs/zh/v5.0/mqtt/mqtt-session-and-message-expiry.html#mqtt-%E4%BC%9A%E8%AF%9D">会话与消息过期 MQTT 会话</a></li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" class="category-chain-item">网络协议</a> <span>></span> <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/MQTT/" class="category-chain-item">MQTT</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%8E%9F%E5%88%9B/">#原创</a> <a href="/tags/TCPIP/">#TCPIP</a> <a href="/tags/MQTT/">#MQTT</a></div></div><div class="license-box my-3"><div class="license-title"><div>mqtt5协议一连接</div><div>http://example.com/2023/05/23/linux/network/mqtt50/connect/084806/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>EtcFly</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年5月23日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2024年3月5日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2023/05/23/linux/network/mqtt50/publish/085243/" title="mqtt5协议一消息发布"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">mqtt5协议一消息发布</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2023/05/23/linux/network/mqtt50/about/084455/" title="mqtt5协议一简介"><span class="hidden-mobile">mqtt5协议一简介</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="waline"></div><script type="text/javascript">Fluid.utils.loadComments("#waline",(function(){Fluid.utils.createCssLink("https://lib.baomitu.com/waline/2.14.1/waline.min.css"),Fluid.utils.createScript("https://lib.baomitu.com/waline/2.14.1/waline.min.js",(function(){var i=Object.assign({serverURL:"https://etcfly.top:14000/",path:"window.location.pathname",meta:["nick","mail","link"],requiredMeta:["nick"],lang:"zh-CN",emoji:["https://unpkg.com/@waline/emojis@1.1.0/qq"],dark:'html[data-user-color-scheme="dark"]',wordLimit:0,pageSize:10},{el:"#waline",path:window.location.pathname});Waline.init(i),Fluid.utils.waitElementVisible("#waline .vcontent",()=>{var i="#waline .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://github.com/EtcFly" target="_blank" rel="nofollow noopener"><span>Copyright</span></a> <i class="iconfont icon-copyright"></i> <a href="https://etcfly.top:14100/share/yqTLFDlP/%E4%BB%97%E5%89%91%E8%B5%B0%E5%A4%A9%E6%B6%AF" target="_blank" rel="nofollow noopener"><span>2018-2024 EtcFly</span></a><div style="font-size:.85rem"><span>总访问量 <span style="color:#000" id="PVstatic">0</span> 次&nbsp</span> <span>总访客数 <span style="color:#000" id="UVstatic">0</span> 人&nbsp</span> <span>当前在线 <span style="color:#000" id="ACTstatic">0</span> 人&nbsp</span><script src="https://etcfly.top:14200/statistics" defer></script></div><div style="font-size:.85rem"><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="js/duration.js"></script></div></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener"></a> </span><span><a href="http://beian.miit.gov.cn/2023000858" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" alt="police-icon"> <span>浙ICP备2023000858号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/jquery.min.js"></script><script src="/live2d-widget/autoload.js"></script><script src="/js/star.js"></script><script src="/js/ribbon.min.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>