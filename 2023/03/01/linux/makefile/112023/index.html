<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="EtcFly"><meta name="keywords" content=""><meta name="description" content="版权归作者所有, 转载请保留该部分声明。本文作者：EtcFly原文地址：https:&#x2F;&#x2F;etcfly.top              简介   IDE工具集成了编码、调试、编译等多功能为一体的现代化工具，对于提高代码开发的效率起着较为重要的作用。但是对于现代化IDE软件百花齐放，并且对于多人协助的支持程度各不相同，因此寻找一款多人合作并且统一的工具就尤为重要，其次，目前"><meta property="og:type" content="article"><meta property="og:title" content="Makefile基本语法"><meta property="og:url" content="http://example.com/2023/03/01/linux/makefile/112023/"><meta property="og:site_name" content="仗剑走天涯"><meta property="og:description" content="版权归作者所有, 转载请保留该部分声明。本文作者：EtcFly原文地址：https:&#x2F;&#x2F;etcfly.top              简介   IDE工具集成了编码、调试、编译等多功能为一体的现代化工具，对于提高代码开发的效率起着较为重要的作用。但是对于现代化IDE软件百花齐放，并且对于多人协助的支持程度各不相同，因此寻找一款多人合作并且统一的工具就尤为重要，其次，目前"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/linux.png"><meta property="article:published_time" content="2023-03-01T11:20:23.000Z"><meta property="article:modified_time" content="2024-03-05T03:41:03.000Z"><meta property="article:author" content="EtcFly"><meta property="article:tag" content="原创"><meta property="article:tag" content="linux - Makefile"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/img/linux.png"><title>Makefile基本语法 仗剑走天涯</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/fluid-extention.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:4},web_analytics:{enable:!0,follow_dnt:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"3AEufnWAJdp8cFODp1DXvrQU-MdYXbMMI",app_key:"mGJiL6xVvYv21ygqfynJoCyO",server_url:null,path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Strive For Dream</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Makefile基本语法"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-03-01 11:20" pubdate>2023年3月1日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 14k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 119 分钟 </span><span id="vvdpost_container_page_pvuv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="vvdpost_value_page_pv">0</span> 次&nbsp&nbsp <i class="iconfont icon-users" aria-hidden="true"></i> <span id="vvdpost_value_page_uv">0</span> 人</span><script>console.log(window.location.pathname);var httpRequest=new XMLHttpRequest;httpRequest.open("POST","https://etcfly.top:14200/poststats",!0),httpRequest.setRequestHeader("Content-type","application/json"),httpRequest.send(JSON.stringify(window.location.pathname)),httpRequest.onreadystatechange=function(){if(4==httpRequest.readyState&&200==httpRequest.status){var e=httpRequest.responseText,t=JSON.parse(e);console.log(t.pv);var o=document.querySelector("#vvdpost_container_page_pvuv");if(console.log(o),o){var n=document.querySelector("#vvdpost_value_page_pv");console.log(n);var s=document.querySelector("#vvdpost_value_page_uv");console.log(s),s&&s&&(n.innerText=t.pv,s.innerText=t.uv,o.style.display="inline")}}}</script></div></div></div></div></div></div><script async src="https://etcfly.top:14100/script.js" data-website-id="1a5c096d-21e5-4556-99b0-28c810c9c868"></script></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">Makefile基本语法</h1><p class="note note-info">本文最后更新于：2024年3月5日 凌晨</p><div class="markdown-body"><div class="note note-success"><p>版权归作者所有, 转载请保留该部分声明。<br>本文作者：EtcFly<br>原文地址：<a target="_blank" rel="noopener" href="https://etcfly.top">https://etcfly.top</a></p></div><hr><h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3><p>  <code>IDE</code>工具集成了编码、调试、编译等多功能为一体的现代化工具，对于提高代码开发的效率起着较为重要的作用。但是对于现代化<code>IDE</code>软件百花齐放，并且对于多人协助的支持程度各不相同，因此寻找一款多人合作并且统一的工具就尤为重要，其次，目前市面上大多数<code>IDE</code>底层也是通过<code>makefile</code>来管理的。我们这里就底层<code>Makefile</code>原理进行一些剖析。</p><hr><h3 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">target ... : prerequisites ...<br>    <span class="hljs-built_in">command</span> <br>    ... <br></code></pre></td></tr></table></figure><ul><li><code>target</code>: 表示需要生成的目标, 可以是多个</li><li><code>prerequisites</code>: 用于生成该目标的依赖文件或者目标</li><li><code>command</code>: 生成该目标<code>target</code>所需要执行的命令(任意脚本或者<code>shell</code>命令)</li></ul><p>这描述了文件的依赖关系，也就是说， <code>target</code> 这一个或多个的目标文件依赖于 <code>prerequisites</code> 中的文件，其生成规则定义在<code>command</code> 中:</p><blockquote><p><strong>核心要素</strong>:</p><ul><li><code>prerequisites</code> 中如果有一个以上的文件比 <code>target</code> 文件要新的话， <code>command</code> 所定义的命令就会被执行</li><li>在定义好依赖关系后，<code>command</code>命令一定要以一个 <code>Tab</code>键作为开头, 否则<code>make</code>程序认为是一个空目标<br>示例:</li></ul></blockquote><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">main.o : main.c main.h<br>    gcc -o main.o -c main.c<br></code></pre></td></tr></table></figure><p>以上表示, <code>main.o</code>生成依赖<code>main.c</code>和<code>main.h</code>, 如果依赖文件更新, 那么使用下面的命令进行生成。</p><p><strong>注意事项</strong></p><ul><li>当一个真实的目标存在, 但是不存在依赖时, <code>make</code>始终认为规则最新不更新。如下：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">new : <br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;this is new!&quot;</span><br></code></pre></td></tr></table></figure><p>假如当前目录存在<code>new</code>文件, 那么<code>make new</code>永远不会执行<code>echo &quot;this is new!&quot;</code>命令。因为<code>new</code>相对于依赖永远是最新, 想要命令默认执行, 可以加上<code>.PHONY</code>，如下:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">.PHONY : new<br>new : <br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;this is new!&quot;</span><br></code></pre></td></tr></table></figure><p><code>.PHONY</code>定义<code>new</code>是一个伪目标, 即使目录下存在<code>new</code>文件也会默认执行<code>new</code>目标, 因此定义后<code>make new</code>一定执行命令。<strong>所有的伪目标一定执行命令</strong>。</p><ul><li><code>make</code>依赖生产比较规则。如果依赖比目标更新那么执行命令重新生成依赖，如果依赖本身是一个中间文件，那么找寻中间文件的依赖，检测是否需要更新中间文件.<br>如下中间文件<code>main.o</code>:</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">main : main.o test.o<br>    cc -o main <span class="hljs-variable">$^</span><br><br>main.o : main.c main.h<br>    gcc -o main.o -c <span class="hljs-variable">$^</span><br>    <br>test.o : test.c test.h<br>    gcc -o main.o -c <span class="hljs-variable">$^</span><br></code></pre></td></tr></table></figure><p>执行<code>make main</code>, 那么首先检测<code>main.o test.o</code>和<code>main</code>文件, 发现<code>main.o test.o</code>属于中间文件, 于是查找<code>test.o main.o</code>和他们依赖, 及<code>main.o</code>和<code>main.c main.h</code>那个文件最新, 依次类推生成中间文件, 最终生成<code>main</code>目标。</p><ul><li>命令一般由<code>shell</code>命令（<code>echo、ls</code>）和编译器的一些工具（<code>gcc、ld、ar、objcopy</code>等）组成，使用<code>tab</code>键缩进。</li><li>命令是<code>make</code>在编译程序时真正要执行的部分。对于规则中的每一个命令，<code>make</code>会开一个进程执行，每条命令执行完，<code>make</code>会监测每个命令的返回码。</li></ul><hr><h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3><p>  通常要使用变量来简化规则的编写, 在 <code>Makefile</code>中的定义的变量，就像是 <code>C/C++</code>语言中的宏一样，他代表了一个文本字串，在 <code>Makefile</code>中执行的时候其会自动原模原样地展开在所使用的地方。其与 <code>C/C++</code> 所不同的是，你可以在 <code>Makefile</code>中改变其值。在 <code>Makefile</code>中，变量可以使用在目标，依赖目标，命令或是 <code>Makefile</code> 的其它部分中。</p><p><strong>变量的命名</strong>: 包含字符、数字，下划线（可以是数字开头），但不应该含有 <code>:</code> 、 <code>#</code> 、 <code>=</code> 或是空字符（空格、回车等）。变量是大小写敏感的，<code>foo</code>、<code>Foo</code>和<code>FOO</code>是三个不同的变量名。</p><p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上 <code>$</code>符号，但最好用小括号 <code>()</code> 或是大括号 <code>&#123;&#125;</code>把变量给包括起来。如果你要使用真实的 <code>$</code>字符，那么你需要用 <code>$$</code> 来表示。</p><p><code>Makefile</code>中支持几类变量:</p><ul><li>普通变量<br>普通变量是定义在<code>Makefile</code>中的全局变量, 可以有如下定义方式:</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">VAR  = <span class="hljs-string">&quot;this&quot;</span><br>VAR := <span class="hljs-string">&quot;this&quot;</span><br>VAR += <span class="hljs-string">&quot;this&quot;</span><br>VAR ?= <span class="hljs-string">&quot;this&quot;</span><br></code></pre></td></tr></table></figure><p><code>=</code>表示又称为 <strong>延时变量</strong>, 变量只会在使用时会展开, 因此可以出现如下定义:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">VAR = <span class="hljs-variable">$(VAR1)</span><br>VAR1 = <span class="hljs-string">&quot;this&quot;</span><br></code></pre></td></tr></table></figure><p>这时候<code>VAR</code>值进行<code>echo</code>也是<code>this</code>。</p><p><code>:=</code>表示又称为 <strong>及时变量</strong>, 也就是赋值时立即进行, 不会延迟到后面展开。<br><code>+=</code>表示追加变量的值</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">VAR := <span class="hljs-string">&quot;this&quot;</span><br>VAR += <span class="hljs-string">&quot;new&quot;</span><br></code></pre></td></tr></table></figure><p>最后结果是<code>this new</code>。<br><code>?=</code>表示加入变量没有定义, 那么赋值</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">VAR ?= <span class="hljs-string">&quot;this&quot;</span><br></code></pre></td></tr></table></figure><p>如果<code>VAR</code>之前定义了, 那么值不变, 否则值为<code>this</code>。</p><hr><ul><li>环境变量<br>  <code>make</code> 运行时的系统环境变量可以在 <code>make</code> 开始运行时被载入到 <code>Makefile</code> 文件中，但是如果 <code>Makefile</code>中已定义了这个变量，或是这个变量由 <code>make</code> 命令行带入，那么系统的环境变量的值将被覆盖。（如果<code>make</code> 指定了<code>-e</code>参数，那么，系统环境变量将覆盖 <code>Makefile</code> 中定义的变量）<br>  当 <code>make</code> 嵌套调用时（参见前面的“嵌套调用”章节），上层 <code>Makefile</code> 中定义的变量会以系统环境变<br>量的方式传递到下层的 <code>Makefile</code> 中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义<br>在文件中的变量，如果要向下层 <code>Makefile</code> 传递，则需要使用 <code>exprot</code> 关键字来声明。</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">VAR = <span class="hljs-string">&quot;this&quot;</span><br><span class="hljs-keyword">export</span> VAR <span class="hljs-comment">#所有子makefile都可见该变量</span><br></code></pre></td></tr></table></figure><p>通常的环境变量有:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">CFLAGS、ARFLAGS、ASFLAGS、CPPFLAGS、LDFLAGS ...<br></code></pre></td></tr></table></figure><hr><ul><li>目标变量<br>  目标变量是为某个目标设置局部变量，这种变量被称为<code>Target-specific Variable</code>，它可以和 <strong>全局变</strong> 同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。</li></ul><p>格式:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">&lt;target ...&gt; : &lt;variable-assignment&gt;;<br>&lt;target ...&gt; : overide &lt;variable-assignment&gt;<br></code></pre></td></tr></table></figure><p><code>&lt;variable-assignment&gt;;</code> 可以是前面讲过的各种赋值表达式，如 <code>=</code> 、 <code>:=</code> 、 <code>+=</code> 或是 <code>?=</code> 。第二个语法是针对于 <code>make</code>命令行带入的变量，或是系统环境变量。这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">prog : CFLAGS = -g<br>prog : prog.o foo.o bar.o<br></code></pre></td></tr></table></figure><p>在这个示例中，不管全局的 <code>$(CFLAGS)</code> 的值是什么，在 <code>prog</code> 目标，以及其所引发的所有规则中（<code>prog.o foo.o bar.o</code> 的规则）， <code>$(CFLAGS)</code> 的值都是 <code>-g</code>。</p><hr><ul><li>模式变量<br>  在 <code>GNU</code> 的 <code>make</code> 中，还支持模式变量（<code>Pattern-specific Variable</code>），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。我们知道， <code>make</code> 的 <strong>模式</strong> 一般是至少含有一个 <code>%</code> 的，所以，我们可以以如下方式给所有以 <code>.o</code> 结尾的目标定义目标变量。</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">%.o : CFLAGS = -O<br></code></pre></td></tr></table></figure><p>同样，模式变量的语法和 “目标变量” 一样：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">&lt;pattern ...&gt;; : &lt;variable-assignment&gt;;<br>&lt;pattern ...&gt;; : <span class="hljs-keyword">override</span> &lt;variable-assignment&gt;;<br></code></pre></td></tr></table></figure><p>模式变量其实是某种意义上目标变量的特殊形式，只是作用在模式规则上。</p><hr><ul><li>多行变量<br>  还有一种设置变量值的方法是使用 <code>define</code> 关键字。使用 <code>define</code> 关键字设置变量的值可以有换行，这有利于定义一系列的命令。</li></ul><p>  <code>define</code> 指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以 <code>endef</code> 关键字结束。其工作方式和<code>=</code>操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以 <code>[Tab]</code>键开头，所以如果你用 <code>define</code> 定义的命令变量中没有以 <code>Tab</code> 键开头，那么 <code>make</code> 就不会把其认为是命令</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-keyword">define</span> two-lines<br>echo foo<br><span class="hljs-keyword">endef</span><br></code></pre></td></tr></table></figure><hr><ul><li>override指示符<br>  如果有变量是通常 <code>make</code> 的命令行参数设置的，那么 <code>Makefile</code> 中对这个变量的赋值会被忽略。如果你想在 <code>Makefile</code> 中设置这类参数的值，那么，你可以使用<code>override</code>指示符。其语法是:</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-keyword">override</span> &lt;variable&gt;; = &lt;value&gt;;<br><span class="hljs-keyword">override</span> &lt;variable&gt;; := &lt;value&gt;;<br></code></pre></td></tr></table></figure><p>对于多行的变量定义，我们用 <code>define</code> 指示符，在 <code>define</code> 指示符前，也同样可以使用 <code>override</code> 指示符，如:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-keyword">override</span> <span class="hljs-keyword">define</span> foo<br>bar<br><span class="hljs-keyword">endef</span><br></code></pre></td></tr></table></figure><hr><ul><li><p>规则变量</p><ul><li><code>$@</code>: 规则中目标文件集合</li><li><code>$&lt;</code>: 第一个依赖目标</li><li><code>$^</code>: 所有依赖目标</li><li><code>$+</code>: 和<code>$^</code>类似但是不去除重复的依赖目标。</li><li><code>$*</code>: 变量表示目标模式中<code>%</code>及其之前的部分。如目标是<code>dir/a.foo.b</code>, 并且模板是<code>a.%.b</code>, 那么<code>$*</code>就是<code>dir/a.foo</code>。</li><li><code>$?</code>: 所有比目标新的依赖目标的集合以空格分隔。</li><li><code>$%</code>: 仅当目标是函数库中, 表示规则中的目标成员名。例如，如果一个目标是 <code>foo.a(bar.o)</code>，那么， <code>$%</code> 就是 <code>bar.o</code> ， <code>$@</code> 就是 <code>foo.a</code> 。如果目标不是函数库文件（<code>Unix</code> 下是 <code>.a</code> ， <code>Windows</code>下是 <code>.lib</code> ），那么，其值为空。</li><li><code>$(@D)</code>：表示目标文件的目录部分</li><li><code>$(@F)</code>：表示目标文件的文件名部分</li><li><code>$(*D)</code>：在模式匹配中，表示目标模式中<code>%</code>的目录部分</li><li><code>$(*F)</code>：在模式匹配中，表示目标模式中<code>%</code>的文件名部分</li></ul></li><li><p>通配符<br>在<code>Makefile</code>中，可以使用的通配符有：<code>*</code> 、<code>?</code> 、<code>%</code> 等等。通配符主要用在两个场合：</p><ul><li>用在规则的目标和依赖中：<code>make</code>在读取<code>Makefile</code>时会自动对其进行匹配处理（通配符展开）,如:</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">%.o : %.d<br>    ...<br></code></pre></td></tr></table></figure><ul><li>用在规则的命令中：通配符的通配处理在<code>shell</code>执行命令时完成。如：</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-section">clean:</span><br>rm -f *.o<br></code></pre></td></tr></table></figure><ul><li>用在函数中</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.c)</span><br></code></pre></td></tr></table></figure><ul><li>模式变量</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">SRC = $(SRC:%.o=%.d)<br></code></pre></td></tr></table></figure></li></ul><p>除了以上几种情况，在其他地方都不能直接使用通配符。</p><hr><ul><li>高级用法</li></ul><ol><li>变量扩展<br>如:</li></ol><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">X = Y<br>Y = Z<br>Z = <span class="hljs-string">&quot;this&quot;</span><br></code></pre></td></tr></table></figure><p>通过上面展开<code>$(X) = &quot;this&quot;</code>, 展开流程为<code>$($($(X)))</code>，最好后相当于<code>$(Z)</code></p><ol start="2"><li>变量后缀模式替换<br>如:</li></ol><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">VAR = main.c test.c b.c<br>VAR_O = $(VAR:.c=.o)<br>也可以是<br>VAR_O = $(VAR:%.c=%.o)<br></code></pre></td></tr></table></figure><hr><h3 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h3><table><thead><tr><th style="text-align:left">函数名</th><th style="text-align:left">功能</th><th style="text-align:left">函数名</th><th style="text-align:left">功能</th><th style="text-align:left">函数名</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left"><code>subst</code></td><td style="text-align:left"></td><td style="text-align:left"><code>patsubst</code></td><td style="text-align:left"></td><td style="text-align:left"><code>strip</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>findstring</code></td><td style="text-align:left"></td><td style="text-align:left"><code>filter</code></td><td style="text-align:left"></td><td style="text-align:left"><code>filter-out</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>sort</code></td><td style="text-align:left"></td><td style="text-align:left"><code>word</code></td><td style="text-align:left"></td><td style="text-align:left"><code>wordlist</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>words</code></td><td style="text-align:left"></td><td style="text-align:left"><code>firstword</code></td><td style="text-align:left"></td><td style="text-align:left"><code>dir</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>notdir</code></td><td style="text-align:left"></td><td style="text-align:left"><code>suffix</code></td><td style="text-align:left"></td><td style="text-align:left"><code>basename</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>addsuffix</code></td><td style="text-align:left"></td><td style="text-align:left"><code>addprefix</code></td><td style="text-align:left"></td><td style="text-align:left"><code>join</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>foreach</code></td><td style="text-align:left"></td><td style="text-align:left"><code>if</code></td><td style="text-align:left"></td><td style="text-align:left"><code>call</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>origin</code></td><td style="text-align:left"></td><td style="text-align:left"><code>shell</code></td><td style="text-align:left"></td><td style="text-align:left"><code>make</code></td><td style="text-align:left"></td></tr></tbody></table><p><code>makefile</code>中函数分为几类:</p><ul><li>字符串处理函数(<code>subst/patsubst/strip/findstring/filter/filter-out/sort/word/wordlist/words/firstword</code>)</li><li>文件名操作函数(<code>dir/notdir/suffix/basename/addsuffix/addprefix/join</code>)</li><li>杂项函数(<code>foreach/if/call/origin/shell/make</code>)</li></ul><p><code>makefile</code>中函数模板如下:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-variable">$(Func para1, para2, para3, ...)</span><br></code></pre></td></tr></table></figure><p>  其中<code>Func</code>为函数名, <code>para1,Para2, para3</code>为函数的参数, 参数之间使用<code>,</code>隔开</p><p><strong>调用时格式为</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">subst</span> <span class="hljs-params">a</span>, <span class="hljs-params">b</span>, <span class="hljs-params">abcdef</span>)</span><br></code></pre></td></tr></table></figure><p>这里<code>subst</code>为函数名, <code>a,b,abcdef</code>都是参数，例如当使用如下命令 <code>$(subst a, bb, Aaedfs)</code> 最终结果就是<code>Abbedfs</code></p><hr><h4 id="字符串处理类"><a class="markdownIt-Anchor" href="#字符串处理类"></a> 字符串处理类</h4><h5 id="subst函数"><a class="markdownIt-Anchor" href="#subst函数"></a> <code>subst</code>函数</h5><p><strong>格式:</strong> <code>$(subst a, b, c)</code> //在<code>c</code>中查找所用<code>a</code>并替换为<code>b</code><br><strong>示例:</strong><br>例如当使用如下命令时</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">A = i belive you<br>B = <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> live, LIVE, <span class="hljs-variable">$(A)</span>)</span><br></code></pre></td></tr></table></figure><p>那么最终<code>B = i beLIVE you</code>, 及在<code>A</code>中查找<code>live</code>并替换为<code>LIVE</code>。</p><hr><h5 id="patsubst函数"><a class="markdownIt-Anchor" href="#patsubst函数"></a> <code>patsubst</code>函数</h5><p><strong>格式:</strong> <code>$(patsubst %.a, %.b, c) //模式匹配,</code>将<code>c</code>中<code>a</code>格式替换为<code>b</code>格式<br><strong>示例</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">A <span class="hljs-operator">=</span> <span class="hljs-keyword">c</span>.<span class="hljs-keyword">c</span> d.<span class="hljs-keyword">c</span><br>B <span class="hljs-operator">=</span> $(patsubst <span class="hljs-variable">%.c</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%.d</span><span class="hljs-punctuation">,</span> $(A))<br></code></pre></td></tr></table></figure><p>结果为<code>B = c.d d.d</code>, 其和模式替换<code>$($(A):.c=.d)</code>功能是一样的。</p><hr><h5 id="strip函数"><a class="markdownIt-Anchor" href="#strip函数"></a> <code>strip</code>函数</h5><p><strong>格式:</strong> <code>$(strip &lt;string&gt;) //去除</code>string`字符串开头和结尾的空字符。<br><strong>示例</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">A =      c.c d.c  <br>B = <span class="hljs-variable">$(<span class="hljs-built_in">strip</span> <span class="hljs-variable">$(A)</span>)</span><br></code></pre></td></tr></table></figure><p><code>A</code>原先是 <code>' ' c.c d.c</code> 结果为<code>B = c.c d.c</code>。开头空格被去掉。</p><hr><h5 id="findstring函数"><a class="markdownIt-Anchor" href="#findstring函数"></a> <code>findstring</code>函数</h5><p><strong>格式:</strong> <code>$(findstring &lt;find&gt;,&lt;in&gt;)</code> //从<code>in</code> 字符串中查找<code>find</code>字符串, 找到返回<code>find</code>字符串, 否则返回空。<br><strong>示例</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">A = this is test<br>B = <span class="hljs-variable">$(<span class="hljs-built_in">findstring</span> is, <span class="hljs-variable">$(A)</span>)</span><br></code></pre></td></tr></table></figure><p>返回的结果<code>B=is</code>。</p><hr><h5 id="filter函数"><a class="markdownIt-Anchor" href="#filter函数"></a> <code>filter</code>函数</h5><p><strong>格式:</strong> <code>$(filter a, b) //</code>过滤<code>b</code>中所有符合<code>a</code>格式的字符串并返回<br><strong>示例</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">A</span> = a d/e c.c e/<br><span class="hljs-attr">B</span> = $(filter /e, $(A)<br></code></pre></td></tr></table></figure><p>其结果为<code>B = d/e</code><br>又比如:</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">A <span class="hljs-operator">=</span> a.<span class="hljs-keyword">c</span> b.<span class="hljs-keyword">c</span> <span class="hljs-keyword">c</span>.o d.<span class="hljs-keyword">c</span> e.s<br>B <span class="hljs-operator">=</span> $(<span class="hljs-keyword">filter</span> <span class="hljs-variable">%.o</span> <span class="hljs-variable">%.s</span><span class="hljs-punctuation">,</span> $(A))<br></code></pre></td></tr></table></figure><p>最后<code>B=c.o e.s</code></p><hr><h5 id="filter-out函数"><a class="markdownIt-Anchor" href="#filter-out函数"></a> <code>filter-out</code>函数</h5><p><strong>格式:</strong> <code>$(filter-out a, b)</code> //功能和<code>filter</code>函数相反<br><strong>示例</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm"> A <span class="hljs-operator">=</span> a.<span class="hljs-keyword">c</span> b.<span class="hljs-keyword">c</span> <span class="hljs-keyword">c</span>.o d.<span class="hljs-keyword">c</span> e.s<br>B <span class="hljs-operator">=</span> $(<span class="hljs-keyword">filter</span>-out <span class="hljs-variable">%.o</span> <span class="hljs-variable">%.s</span><span class="hljs-punctuation">,</span> $(A))<br></code></pre></td></tr></table></figure><p>执行结果为<code>B = a.c b.c d.c</code></p><hr><h5 id="sort函数"><a class="markdownIt-Anchor" href="#sort函数"></a> <code>sort</code>函数</h5><p><strong>格式:</strong> <code>$(sort &lt;list&gt;)</code> //去掉<code>list</code>中重复的元素并升序排列<br><strong>示例</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">A = test foo need need foo1<br>B = <span class="hljs-variable">$(<span class="hljs-built_in">sort</span> <span class="hljs-variable">$(A)</span>)</span><br></code></pre></td></tr></table></figure><p>执行结果为<code>B=foo foo1 need test</code></p><hr><h5 id="word函数"><a class="markdownIt-Anchor" href="#word函数"></a> <code>word</code>函数</h5><p><strong>格式:</strong> <code>$(word &lt;n&gt;,&lt;text&gt;)</code> //从<code>text</code>字符串中取出第<code>n</code>个单词<br><strong>示例</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">A = test foo need need foo1<br>B = <span class="hljs-variable">$(<span class="hljs-built_in">word</span> 2,<span class="hljs-variable">$(A)</span>)</span><br></code></pre></td></tr></table></figure><p>执行结果为<code>B=foo</code></p><hr><h5 id="wordlist函数"><a class="markdownIt-Anchor" href="#wordlist函数"></a> <code>wordlist</code>函数</h5><p><strong>格式:</strong> <code>$(wordlist &lt;ss&gt;,&lt;e&gt;,&lt;text&gt;)</code> //从字符串<code>text</code>中取<code>ss</code>开始到<code>e</code>的单词串, <code>ss</code>和<code>e</code>是数字。<br><strong>返回:</strong> 返回字符串 <code>text</code> 中从 <code>ss</code> 到 <code>e</code> 的单词字串。如果 <code>ss</code> 比 <code>text</code> 中的单词数要大，那么返回空字符串。如果 <code>e</code> 大于 <code>text</code> 的单词数，那么返回从 <code>ss</code> 开始，到 <code>text</code> 结束的单词串。<br><strong>示例</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">A = test foo need need foo1 kell<br>B = <span class="hljs-variable">$(<span class="hljs-built_in">wordlist</span> 2,4,<span class="hljs-variable">$(A)</span>)</span><br></code></pre></td></tr></table></figure><p>执行结果为<code>B=foo need need</code></p><hr><h5 id="words函数"><a class="markdownIt-Anchor" href="#words函数"></a> <code>words</code>函数</h5><p><strong>格式:</strong> <code>$(words &lt;text&gt;)</code> //单词个数统计<br><strong>示例</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">A</span> = test foo need need foo1 kell<br><span class="hljs-attr">B</span> = $(words $(A))<br></code></pre></td></tr></table></figure><p>执行结果为<code>B=6</code></p><hr><h5 id="firstword函数"><a class="markdownIt-Anchor" href="#firstword函数"></a> <code>firstword</code>函数</h5><p><strong>格式:</strong> <code>$(firstword &lt;text&gt;)</code> //取字符串首个单词<br><strong>示例</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">A = test foo need need foo1 kell<br>B = <span class="hljs-variable">$(<span class="hljs-built_in">firstword</span> <span class="hljs-variable">$(A)</span>)</span><br></code></pre></td></tr></table></figure><p>执行结果为<code>B=test</code></p><hr><h4 id="文件名操作函数"><a class="markdownIt-Anchor" href="#文件名操作函数"></a> 文件名操作函数</h4><h5 id="wildcard"><a class="markdownIt-Anchor" href="#wildcard"></a> <code>wildcard</code></h5><p><strong>格式:</strong> <code>wildcard a // Makefile</code>中，它被展开为已经存在的<code>、</code>使用空格分开的<code>、</code>匹配此模式的所有文件列表<br><strong>示例</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">当前目录下存在文件: <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.c</span> <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.s</span> e<span class="hljs-selector-class">.dis</span> f<span class="hljs-selector-class">.c</span> <br>A = $(wildcard *.c)  <span class="hljs-comment">//列出当前目录下所有存在的.c文件</span><br></code></pre></td></tr></table></figure><p>结果为: <code>A = a.c f.c</code><br>或者</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">当前目录下存在: <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.c</span> <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.s</span> e<span class="hljs-selector-class">.dis</span> f<span class="hljs-selector-class">.c</span><br>A = <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.c</span> <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.s</span><br>B = $(wildcard $(A)) <span class="hljs-comment">//当前目录下所有的匹配文件</span><br></code></pre></td></tr></table></figure><p>结果为<code>B = a.c b.s</code></p><hr><h5 id="nodir"><a class="markdownIt-Anchor" href="#nodir"></a> <code>nodir</code></h5><p><strong>格式:</strong> <code>$(nodir a)</code> //获取<code>a</code>中文件名 除去文件路径<br>例如:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">A = /home/a.c b.c /etcfly/pwd/uid.s<br>B = <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> <span class="hljs-variable">$(A)</span>)</span><br></code></pre></td></tr></table></figure><p>结果为: <code>B=a.c b.c uid.s</code></p><hr><h5 id="dir"><a class="markdownIt-Anchor" href="#dir"></a> <code>dir</code></h5><p><strong>格式:</strong> <code>$(nodir a)</code> //获取<code>a</code>中文件名 除去文件路径<br>例如:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">A = /home/a.c b.c /etcfly/pwd/uid.s<br>B = <span class="hljs-variable">$(<span class="hljs-built_in">dir</span> <span class="hljs-variable">$(A)</span>)</span><br></code></pre></td></tr></table></figure><p>结果为: <code>B=/home/ ./ /etcfly/pwd/</code></p><hr><h5 id="suffix"><a class="markdownIt-Anchor" href="#suffix"></a> <code>suffix</code></h5><p><strong>格式:</strong> <code>$(suffix &lt;name ...&gt;)</code> //获取<code>name</code>文件名列表中各文件名的后缀<br>例如:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">A = /home/a.c b.c /etcfly/pwd/uid.s<br>B = <span class="hljs-variable">$(<span class="hljs-built_in">suffix</span> <span class="hljs-variable">$(A)</span>)</span><br></code></pre></td></tr></table></figure><p>结果为 <code>B=.c .c .s</code></p><hr><h5 id="basename"><a class="markdownIt-Anchor" href="#basename"></a> <code>basename</code></h5><p><strong>格式:</strong> <code>$(basename &lt;name ...&gt;)</code> //获取<code>name</code>文件名列表中各文件名的前缀<br>例如:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">A = /home/a.c b.c /etcfly/pwd/uid.s<br>B = <span class="hljs-variable">$(<span class="hljs-built_in">basename</span> <span class="hljs-variable">$(A)</span>)</span><br></code></pre></td></tr></table></figure><p>结果为: <code>B=/home/a b /etcfly/pwd/uid</code></p><hr><h5 id="addsuffix"><a class="markdownIt-Anchor" href="#addsuffix"></a> <code>addsuffix</code></h5><p><strong>格式:</strong> <code>$(addsuffix &lt;suffix&gt; &lt;name ...&gt;)</code> //给<code>name</code>文件名列表各文件名添加<code>suffix</code>后缀<br>例如:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">A = /home/<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.c</span> <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.c</span> /etcfly/pwd/uid<span class="hljs-selector-class">.s</span><br>B = $(addsuffix <span class="hljs-selector-class">.l</span>, $(A))<br></code></pre></td></tr></table></figure><p>结果为: <code>B=/home/a.c.l b.c.l /etcfly/pwd/uid.s.l</code></p><hr><h5 id="addprefix"><a class="markdownIt-Anchor" href="#addprefix"></a> <code>addprefix</code></h5><p><strong>格式:</strong> <code>$(addprefix &lt;prefix&gt; &lt;name ...&gt;)</code> //给<code>name</code>文件名列表各文件名添加<code>prefix</code>前缀<br>例如:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">A = /home/a.c b.c /etcfly/pwd/uid.s<br>B = <span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> prefix, <span class="hljs-variable">$(A)</span>)</span><br></code></pre></td></tr></table></figure><p>结果为: <code>B=prefix/home/a.c prefixb.c prefix/etcfly/pwd/uid.s</code></p><hr><h5 id="join"><a class="markdownIt-Anchor" href="#join"></a> <code>join</code></h5><p><strong>格式:</strong> <code>$(join &lt;list1&gt; &lt;list2&gt;)</code> //连接<code>list1</code>和<code>list2</code>并返回<br>例如:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">A</span> = this is<br><span class="hljs-attr">B</span> = my sister<br><span class="hljs-attr">C</span>= $(join, $(A), $(B))<br></code></pre></td></tr></table></figure><p>结果为: <code>C=thismy issister</code>, 注意这里是每一个单词的连接。</p><hr><h4 id="杂项函数"><a class="markdownIt-Anchor" href="#杂项函数"></a> 杂项函数</h4><h5 id="foreach函数"><a class="markdownIt-Anchor" href="#foreach函数"></a> <code>foreach</code>函数</h5><p><strong>格式:</strong> <code>foreach a, b, c //</code>将<code>b</code>中以空格分隔的字符串取出赋值给<code>a</code>,然后执行<code>c</code>操作<br><strong>示例</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">A = a b c dc<br>B = <span class="hljs-variable">$(forech f, <span class="hljs-variable">$(A)</span>, <span class="hljs-variable">$(f)</span>.o)</span><br></code></pre></td></tr></table></figure><p>结果为<code>B = a.o</code></p><hr><h5 id="foreach函数-2"><a class="markdownIt-Anchor" href="#foreach函数-2"></a> <code>foreach</code>函数</h5><p><strong>格式:</strong> <code>$(foreach a, b, c)</code> //将<code>b</code>中以空格分隔的字符串取出赋值给<code>a</code>,然后执行<code>c</code>操作<br><strong>示例</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">A = a b c dc<br>B = <span class="hljs-variable">$(forech f, <span class="hljs-variable">$(A)</span>, <span class="hljs-variable">$(f)</span>.o)</span><br></code></pre></td></tr></table></figure><p>结果为<code>B = a.o</code></p><hr><h5 id="if函数"><a class="markdownIt-Anchor" href="#if函数"></a> <code>if</code>函数</h5><p><strong>格式:</strong><br>- <code>$(if &lt;condition&gt;, &lt;then-part&gt;)</code><br>- <code>$(if &lt;condition&gt;, &lt;then-part&gt;, &lt;else-part&gt;)</code></p><p><strong>解释</strong>:<br><code>if</code> 函数可以包含 <code>else</code> 部分，或是不含。即 <code>if</code> 函数的参数可以是两个，也可以是三个。<code>&lt;condition&gt;</code> 参数是 <code>if</code> 的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是， <code>&lt;then-part&gt;</code> 会被计算，否则 <code>&lt;else-part&gt;</code> 会被计算。</p><p><strong>示例</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">A = this is<br>B = my sister<br>C = <span class="hljs-variable">$(<span class="hljs-built_in">if</span>  , <span class="hljs-variable">$(A)</span>, <span class="hljs-variable">$(B)</span>)</span><br>D = <span class="hljs-variable">$(<span class="hljs-built_in">if</span> 1, <span class="hljs-variable">$(A)</span>, <span class="hljs-variable">$(B)</span>)</span><br></code></pre></td></tr></table></figure><p>结果为</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">C</span><span class="hljs-operator">=</span> my sister<br><span class="hljs-attribute">D</span><span class="hljs-operator">=</span> this is<br></code></pre></td></tr></table></figure><hr><h5 id="call函数"><a class="markdownIt-Anchor" href="#call函数"></a> <code>call</code>函数</h5><p><strong>格式:</strong> <code>$(call &lt;expression&gt;, &lt;para1&gt;, &lt;para2&gt;, ... , &lt;paran&gt;)</code><br><strong>解释:</strong> <code>call</code> 函数是唯一一个可以用来创建新的参数化的函数,这个表达式中，可以定义许多参数，然后通过 <code>call</code> 函数来向这个表达式传递参数。</p><p>当 <code>make</code> 执行这个函数时， <code>&lt;expression&gt;</code> 参数中的变量，如 <code>$(1)</code> 、 <code>$(2)</code> 等，会被参数 <code>&lt;parm1&gt;</code> 、<code>&lt;parm2&gt;</code> 、 <code>&lt;parm3&gt;</code> 依次取代。而 <code>&lt;expression&gt;</code> 的返回值就是 <code>call</code> 函数的返回值。</p><p><strong>示例</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">str</span> = <span class="hljs-variable">$2</span> <span class="hljs-variable">$1</span><br><span class="hljs-attr">C</span> = $(call str, this, new)<br></code></pre></td></tr></table></figure><p>结果为<code>C=new this</code></p><p><strong>备注:</strong> 需要注意：在向 <code>call</code> 函数传递参数时要尤其注意空格的使用。 <code>call</code> 函数在处理参数时，第 <code>2</code> 个及其之后的参数中的空格会被保留，因而可能造成一些奇怪的效果。因而在向 <code>call</code>函数提供参数时，最安全的做法是去除所有多余的空格。</p><hr><h5 id="origin函数"><a class="markdownIt-Anchor" href="#origin函数"></a> <code>origin</code>函数</h5><p><strong>格式:</strong> <code>$(origin &lt;variable&gt;)</code> //获取变量<code>variable</code>的来源, <code>variable</code>是变量的名字而不是引用, 最好不要在<code>variable</code>中使用<code>$</code>符号。<br><strong>返回值:</strong><br>* <code>undefined</code>: 未定义<br>* <code>default</code>: 是一个默认定义, 如<code>CC</code>变量<br>* <code>environment</code>： 变量是环境变量<br>* <code>file</code>：定义在<code>Makefile</code>中的变量<br>* <code>command line</code>: 变量被定义在命令行<br>* <code>override</code>: 被<code>override</code>指示符重新定义<br>* <code>automatic</code>: 命令运行中的自动化变量。<br><strong>示例</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">str</span> = this<br><span class="hljs-attr">C</span> = $(origin str)<br></code></pre></td></tr></table></figure><p>结果为<code>C=file</code>, 但是如果你写成如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">str = this<br>C = <span class="hljs-variable">$(<span class="hljs-built_in">origin</span> <span class="hljs-variable">$(str)</span>)</span><br></code></pre></td></tr></table></figure><p>则结果为:<code>C=undefined</code></p><hr><h5 id="shell函数"><a class="markdownIt-Anchor" href="#shell函数"></a> <code>shell</code>函数</h5><p><strong>格式:</strong> <code>$(shell &lt;shell command&gt;)</code> //执行<code>shell</code>命令<br><strong>示例</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">A = <span class="hljs-constructor">$(<span class="hljs-params">shell</span> <span class="hljs-params">echo</span> <span class="hljs-params">hello</span>)</span><br></code></pre></td></tr></table></figure><p>结果为<code>A = hello</code></p><hr><h5 id="make函数"><a class="markdownIt-Anchor" href="#make函数"></a> <code>make</code>函数</h5><p><strong>格式:</strong><br>- <code>$(error &lt;text ...&gt;)</code>: 产生一个致命的错误， <code>&lt;text ...&gt;</code> 是错误信息。<br>- <code>$(warning &lt;text ...&gt;)</code>: 产生一个警告消息, 并不会退出<code>make</code>。<br><strong>示例</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">ERR = <span class="hljs-variable">$(<span class="hljs-built_in">error</span> found an <span class="hljs-built_in">error</span>!)</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: err</span><br><br><span class="hljs-section">err: <span class="hljs-variable">$(ERR)</span></span><br></code></pre></td></tr></table></figure><hr><h3 id="模式匹配"><a class="markdownIt-Anchor" href="#模式匹配"></a> 模式匹配</h3><p>  静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。</p><p><strong>语法</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">&lt;targets ...&gt; : &lt;target-pattern&gt; : &lt;prereq-patterns ...&gt;<br>&lt;commands&gt;<br>...<br></code></pre></td></tr></table></figure><ul><li><code>target</code>: 定义一系列目标, 是目标的一个集合, 可以使用通配符。</li><li><code>target-pattern</code>: 指明<code>target</code>的模式, 也就是目标集模式。</li><li><code>prereq-patterns</code>: 定义了目标的依赖, 是<code>target-pattern</code>形成的模式集合进行的目标依赖定义。</li></ul><p><strong>举例:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">objects = foo.o bar.o<br><span class="hljs-section">all: <span class="hljs-variable">$(objects)</span></span><br><span class="hljs-variable">$(objects)</span>: %.o: %.c<br>    <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>上面规则的意思是, 从<code>$(objects)</code>目标集合中获取<code>%.o</code>的对象, 然后<code>%.c</code>是其依赖。及最后展开如下:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">objects = foo.o bar.o<br><span class="hljs-section">all: <span class="hljs-variable">$(objects)</span></span><br>foo.o : foo.c<br>    <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br><br>bar.o : bar.c<br>    <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p><strong>Note</strong>:</p><ul><li>对于模式匹配这一类的规则, <code>make</code>程序在前期会有一个类似<code>c/c++</code>的预处理过程, 这个过程会对此类规则进行展开, 形成真正的目标和文件依赖规则。</li></ul><p><strong>另一种模式匹配规则则如下</strong>:<br>  模式规则中，至少在规则的目标定义中要包含<code>%</code>，否则，就是一般的规则。目标中的 <code>%</code> 定义表示对文件名的匹配，<code>%</code> 表示长度任意的非空字符串。例如：<code>%.c</code> 表示以 <code>.c</code> 结尾的文件名（文件名的长度至少为 <code>3</code>），而 <code>s.%.c</code> 则表示以 <code>s.</code> 开头， <code>.c</code> 结尾的文件名（文件名的长度至少为 <code>5</code>）。</p><p>  如果 <code>%</code> 定义在目标中，那么，目标中的 <code>%</code> 的值决定了依赖目标中的 <code>%</code> 的值，也就是说，目标中的模式的 <code>%</code> 决定了依赖目标中 <code>%</code> 的样子</p><p><strong>语法:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">%.o : %.c ; &lt;command ......&gt;;<br></code></pre></td></tr></table></figure><p>其含义是，指出了怎么从所有的 .c 文件生成相应的 <code>.o</code> 文件的规则。如果要生成的目标是 <code>a.o b.o</code>，那么 <code>%c</code> 就是 <code>a.c b.c</code> 。</p><p>  一旦依赖目标中的 <code>%</code> 模式被确定，那么， <code>make</code>会被要求去匹配当前目录下所有的文件名，一旦找到， <code>make</code> 就会匹配规则命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标。<code>make</code> 就会产生所有的模式目标，此时， <code>make</code> 关心的是依赖的文件名和生成目标的命令这两件事。</p><p><strong>举例:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">%.o : %.c<br>    <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$(CPPFLAGS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>其中， <code>$@</code> 表示所有的目标的挨个值， <code>$&lt;</code> 表示了所有依赖目标的挨个值。</p><hr><h3 id="隐式规则"><a class="markdownIt-Anchor" href="#隐式规则"></a> 隐式规则</h3><p>  如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么， <code>make</code>会试图去自动推导产生这个目标的规则和命令，如果 <code>make</code> 可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。</p><p>隐式规则有如下特点：</p><ul><li><code>make</code>程序有自己的 &quot;隐含规则&quot;库, 因此会根据目标的后缀从隐含规则库进行规则匹配，如果找到那么就会使用，否则则报错退出。</li><li><code>隐含规则</code>在规则库每一条都有顺序, 且越靠前优先级越高，当一个规则被匹配<code>make</code>程序不会在进行此规则匹配，因此这导致有些时候即使我们显示指定了目标依赖, 最终相关规则并没有执行。</li></ul><p>常见隐含规则:</p><ul><li>编译<code>c</code></li></ul><blockquote><p><code>.o</code>的目标会自动推导依赖目标为<code>.c</code>, 并使用生成命令<code>$(CC) -c $(CPPFLAGS) $(CFLAGS)</code></p></blockquote><ul><li>编译<code>c++</code></li></ul><blockquote><p><code>.o</code>的目标会自动推导依赖目标为<code>.cc</code>或<code>.C</code>, 并使用生成命令<code>$(CXX) -c $(CPPFLAGS) $(CFLAGS)</code></p></blockquote><ul><li>编译汇编程序</li></ul><blockquote><p><code>.o</code>的目标会自动推导依赖目标为<code>.s</code>, <code>.s</code>目标依赖自动推导为<code>.S</code>, 并使用生成命令<code>$(AS) $(ASFLAGS)</code></p></blockquote><hr><h3 id="条件判断"><a class="markdownIt-Anchor" href="#条件判断"></a> 条件判断</h3><p>  <code>Makefile</code>中定义四种条件判断语法：<code>ifeq</code>、<code>ifneq</code>、<code>ifdef</code>、<code>ifndef</code></p><p><strong>语法1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">[<span class="hljs-keyword">ifeq</span>/<span class="hljs-keyword">ifneq</span>] (&lt;arg1&gt;, &lt;arg2&gt;)<br>...<br><span class="hljs-keyword">else</span><br>...<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>其比较参数 <code>arg1</code> 和 <code>arg2</code> 的值是否相同，如果不同，则为真</p><p><strong>语法2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">[<span class="hljs-keyword">ifdef</span>/<span class="hljs-keyword">ifndef</span>] &lt;variable-name&gt;<br>...<br><span class="hljs-keyword">else</span><br>...<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>如果变量 <code>&lt;variable-name&gt;</code>的值非空，那到表达式为真。否则，表达式为假。当然，<code>&lt;variable-name&gt;</code>同样可以是一个函数的返回值。注意， <code>ifdef</code>只是测试一个变量是否有值，其并不会把变量扩展到当前位置</p><p><strong>Note</strong>:<br>特别注意的是，<code>make</code> 是在读取 <code>Makefle</code>时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如 <code>$@</code> 等）放入条件表达式中，因为自动化变量是在运行时才有的。</p><hr><h3 id="嵌套"><a class="markdownIt-Anchor" href="#嵌套"></a> 嵌套</h3><p>  对于大型的<code>Makefile</code>而言, 一般不同模块使用不同的<code>Makefile</code>文件来进行编译管理, 因此会出现类似函数调用这样的嵌套调用。<code>Makefile</code>中可以有如下形式的嵌套调用。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">make -C &lt;path&gt; [target]<br>cd &lt;path&gt; &amp;&amp; make [target]<br></code></pre></td></tr></table></figure><p>如上两种形式的调用是等价的。都是进入<code>path</code>目录并执行<code>target</code>目标生成。嵌套的目标可以有几种方式进行变量共享:</p><ul><li>通过命令行参数传递, 子<code>Makefile</code>通过<code>$1 $2</code>之类变量访问</li><li>通过上级<code>Makefile</code>进行变量<code>export</code>。</li><li>通过环境变量共享。如<code>CFLAGS</code></li></ul><p><strong>注意：</strong></p><ul><li>顶层<code>Makefile</code>通过<code>export</code>导出变量, 在子<code>Makefile</code>是可以访问的, 但是同级<code>Makefile</code>是无法访问的。</li><li>顶层<code>Makefile</code>通过<code>-C</code>参数指定下下一级<code>Makefile</code>, 意思是先进入指定目录在<code>make</code></li></ul><hr><h3 id="自动依赖"><a class="markdownIt-Anchor" href="#自动依赖"></a> 自动依赖</h3><p>  对于每一个目标的生成都要进行依赖的指定有的时候是乏味而又缺乏技术含量的工作, 比如<code>c/c++</code>文件中, <code>.o</code>的生成其实是需要以来<code>.c</code>和<code>.h</code>的, 因此<code>.c .h</code>里面对头文件的修改都需要重新定义依赖关系, 这就很麻烦，因此目标自动生成依赖关系就很必要。</p><p>  <code>gcc</code>的一些选项可以提供自动依赖文件的生成, 如:</p><ul><li><code>-M</code>: 预处理过程中生成, 生成的规则输出到标准输出流, 生成的依赖包含系统库文件。</li><li><code>-MM</code>: 和<code>-M</code>类似, 但是不包含标准系统路径中的文件。</li><li><code>-MD</code>: 等同于<code>-M -MF</code>, 驱动程序根据是否指定<code>-o</code>选项决定是汇编还是编译。</li><li><code>-MMD</code>: 和<code>-MD</code>类似, 但是不包含系统路径的文件依赖。</li><li><code>-MF</code>: 正常<code>-M</code>, <code>-MM</code>生成的规则只会输出到标准输出流, 使用这个参数可以指定输出到特定文件名。</li><li><code>-MT</code>: 指定最终生成的目标, 及定义依赖的目标内容。</li><li><code>-MP</code>: 指定为每一个依赖项添加一个伪目标，这导致每一个依赖都不依赖任何内容，这在一些文件删除但是规则依赖没有同步更新时比较有用。</li></ul><p>通过上面的介绍，可以有两种方式进行自动化依赖的生成:</p><ul><li>源文件带路径</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">.PHONY :  clean<br>src = /home/etcfly/linux/test.c /home/etcfly/linux/src/src.c<br>obj = $(src:.c=.o)<br>dep = $(src:.d=.o)<br><br><span class="hljs-keyword">ifneq</span> (<span class="hljs-variable">$(MAKECMDGOALS)</span>, clean)<br><span class="hljs-keyword">include</span> <span class="hljs-variable">$(dep)</span><br><span class="hljs-keyword">endif</span><br><br>main : <span class="hljs-variable">$(obj)</span><br>    cc -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span><br><br>%.d : %.c<br>      cc <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$&lt;</span> -MM -MT<span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span> -MT<span class="hljs-string">&quot;<span class="hljs-variable">$*</span>.o&quot;</span> &gt; <span class="hljs-variable">$@</span><br><br>%.o : %.c<br>    gcc -c <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br><br>clean :<br>    -rm <span class="hljs-variable">$(obj)</span> <span class="hljs-variable">$(dep)</span> -rf<br></code></pre></td></tr></table></figure><ul><li>源文件不带路径</li></ul><p><strong>源码路径如下</strong>:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">.<br>├── Makefile<br>├── output<br>│   ├── dep<br>│   └── obj<br>├── src<br>│   ├── src.c<br>│   └── src.h<br>└── <span class="hljs-built_in">test</span><br>    └── test.c<br></code></pre></td></tr></table></figure><p>根目录<code>Makefile</code>内容如下:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">.PHONY : all<br><br>src_obj = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> src/*.c test/*.c)</span><br>src = <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> <span class="hljs-variable">$(src_obj)</span>)</span><br>obj = $(src:.c=.o)<br>dep = $(src:.c=.d)<br>inc = <span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> -I, $(<span class="hljs-built_in">dir</span> <span class="hljs-variable">$(src_obj)</span>)</span>)<br><br><br>output = output<br><br><span class="hljs-keyword">include</span> <span class="hljs-variable">$(dep)</span><br><br><span class="hljs-comment">#VPATH = ./output/obj:./output/dep</span><br><span class="hljs-keyword">vpath</span> %.c ./src ./test<br><span class="hljs-comment">#vpath %.o ./output/obj</span><br><span class="hljs-comment">#vpath %.d ./output/dep</span><br><br>all : <span class="hljs-variable">$(obj)</span><br>    @echo <span class="hljs-string">&quot;<span class="hljs-variable">$(src)</span>&quot;</span><br>    @echo <span class="hljs-string">&quot;<span class="hljs-variable">$(obj)</span>&quot;</span><br>    @echo <span class="hljs-string">&quot;<span class="hljs-variable">$(dep)</span>&quot;</span><br>    @echo <span class="hljs-string">&quot;<span class="hljs-variable">$(inc)</span>&quot;</span><br>    cc -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$(output)</span>/obj/*.o<br><br>%.d : %.c<br>    cc -c <span class="hljs-variable">$&lt;</span> <span class="hljs-variable">$(inc)</span> -MM -MF <span class="hljs-variable">$(output)</span>/dep/<span class="hljs-variable">$@</span><br><br>%.o : %.c<br>    cc -o <span class="hljs-variable">$(output)</span>/obj/<span class="hljs-variable">$@</span> -c <span class="hljs-variable">$^</span> <span class="hljs-variable">$(inc)</span> <br><br>clean : <br>    rm -rf <span class="hljs-variable">$(output)</span>/obj/*.o <span class="hljs-variable">$(output)</span>/dep/*.d all<br></code></pre></td></tr></table></figure><p>注意事项:</p><ul><li><code>vapth/VPATH</code>属于<code>Makefile</code>载入时计算, 也就是载入后内容发生变更是无法找到相关的文件的。</li><li><code>vpath</code>相对于<code>VPATH</code>更加灵活, 属于<code>make</code>关键字而非变量。</li></ul><p><strong>优化点:</strong></p><ul><li>每一个源文件目录下包含一个<code>Makefile</code>, 所有的<code>.o</code>中间文件存在该<code>Makefile</code>同级目录。这样的好处是不需要指定<code>.o</code>文件目录。</li><li>进行模式匹配的时候包含<code>.c</code>源码的路径。</li></ul><hr><h3 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h3><p>  在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当<code>make</code>需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉<code>make</code>，让<code>make</code>在自动去找。<br>  <code>Makefile</code>文件中的特殊变量“VPATH”就是完成这个功能的，如果没有指明这个变量，<code>make</code>只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，<code>make</code>就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。</p><blockquote><p><code>VPATH = src:../headers</code></p></blockquote><p>上面的的定义指定两个目录，<code>src</code>和<code>../headers</code>，<code>make</code>会按照这个顺序进行搜索。目录由<code>:</code>分隔。（当然，当前目录永远是最高优先搜索的地方）</p><p>  另一个设置文件搜索路径的方法是使用<code>make</code>的<code>vpath</code>关键字（注意，它是全小写的）， 这不是变量，这是一个<code>make</code>的关键字，这和上面提到的那个<code>VPATH</code>变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很 灵活的功能。它的使用方法有三种：</p><ul><li><code>vpath &lt;pattern&gt; &lt;directories&gt;</code></li></ul><blockquote><p>为符合模式<code>&lt;pattern&gt;</code>的文件指定搜索目录<code>&lt;directories&gt;</code>。</p></blockquote><ul><li><code>vpath &lt;pattern&gt;</code></li></ul><blockquote><p>清除符合模式<code>&lt;pattern&gt;</code>的文件的搜索目录。</p></blockquote><ul><li><code>vpath</code></li></ul><blockquote><p>清除所有已被设置好了的文件搜索目录。</p></blockquote><p><code>vapth</code>使用方法中的<code>&lt;pattern&gt;</code>需要包含<code>%</code>字符。<code>%</code>的意思是匹 配零或若干字符，例如，<code>%.h</code>表示所有以<code>.h</code>结尾的文件。<code>&lt;pattern&gt;</code>指定了要搜索的文件集， 而<code>&lt;directories&gt;</code>则指定了<code>&lt;pattern&gt;</code>的文件集的搜索的目录。<br><strong>举例</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-keyword">vpath</span> %.c foo<br><span class="hljs-keyword">vpath</span> %   blish<br><span class="hljs-keyword">vpath</span> %.c bar<br></code></pre></td></tr></table></figure><p>其表示<code>.c</code>结尾的文件，先在<code>foo</code>目录，然后是<code>blish</code>，最后是<code>bar</code>目录。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-keyword">vpath</span> %.c foo:bar<br><span class="hljs-keyword">vpath</span> %   blish<br></code></pre></td></tr></table></figure><p>而上面的语句则表示<code>.c</code>结尾的文件，先在<code>foo</code>目录，然后是<code>bar</code>目录，最后才是<code>blish</code>目录。</p><hr><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><ul><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/haoel/article/details/2886">跟我一起写 Makefile</a></li><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/pengdonglin137/articles/5087304.html">Makefile VPATH和vpath的使用</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/eydwyz/article/details/90296048">GCC -M,-MM,-MMD,-MF,-MT</a></li><li><a target="_blank" rel="noopener" href="https://www.zhaixue.cc/makefile/makefile-pattern.html">Makefile 简明教程</a></li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Linux%E5%85%A5%E9%97%A8/" class="category-chain-item">Linux入门</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%8E%9F%E5%88%9B/">#原创</a> <a href="/tags/linux-Makefile/">#linux - Makefile</a></div></div><div class="license-box my-3"><div class="license-title"><div>Makefile基本语法</div><div>http://example.com/2023/03/01/linux/makefile/112023/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>EtcFly</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年3月1日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2024年3月5日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2023/03/09/linux/compiler/convention/180300/" title="常用编译器调用约定"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">常用编译器调用约定</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2023/02/20/code/ansyler-c-asm/204522/" title="代码效率优化分析"><span class="hidden-mobile">代码效率优化分析</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="waline"></div><script type="text/javascript">Fluid.utils.loadComments("#waline",(function(){Fluid.utils.createCssLink("https://lib.baomitu.com/waline/2.14.1/waline.min.css"),Fluid.utils.createScript("https://lib.baomitu.com/waline/2.14.1/waline.min.js",(function(){var i=Object.assign({serverURL:"https://etcfly.top:14000/",path:"window.location.pathname",meta:["nick","mail","link"],requiredMeta:["nick"],lang:"zh-CN",emoji:["https://unpkg.com/@waline/emojis@1.1.0/qq"],dark:'html[data-user-color-scheme="dark"]',wordLimit:0,pageSize:10},{el:"#waline",path:window.location.pathname});Waline.init(i),Fluid.utils.waitElementVisible("#waline .vcontent",()=>{var i="#waline .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://github.com/EtcFly" target="_blank" rel="nofollow noopener"><span>Copyright</span></a> <i class="iconfont icon-copyright"></i> <a href="https://etcfly.top:14100/share/yqTLFDlP/%E4%BB%97%E5%89%91%E8%B5%B0%E5%A4%A9%E6%B6%AF" target="_blank" rel="nofollow noopener"><span>2018-2024 EtcFly</span></a><div style="font-size:.85rem"><span>总访问量 <span style="color:#000" id="PVstatic">0</span> 次&nbsp</span> <span>总访客数 <span style="color:#000" id="UVstatic">0</span> 人&nbsp</span> <span>当前在线 <span style="color:#000" id="ACTstatic">0</span> 人&nbsp</span><script src="https://etcfly.top:14200/statistics" defer></script></div><div style="font-size:.85rem"><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="js/duration.js"></script></div></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener"></a> </span><span><a href="http://beian.miit.gov.cn/2023000858" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" alt="police-icon"> <span>浙ICP备2023000858号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/jquery.min.js"></script><script src="/live2d-widget/autoload.js"></script><script src="/js/star.js"></script><script src="/js/ribbon.min.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>