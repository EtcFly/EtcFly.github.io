<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="EtcFly"><meta name="keywords" content=""><meta name="description" content="版权归作者所有, 转载请保留该部分声明。本文作者：EtcFly原文地址：https:&#x2F;&#x2F;etcfly.top              前言   前一章我们讨论了内存池的分配和回收的一些内幕，这一节我们将来讨论一下 lwip 的 mem 内存堆机制，那有的人就很好奇，既然有了内存池的管理机制了，为什么还要多此一举搞个内存堆管理呢?二者有什么区别，又或者各有什么优缺点呢?"><meta property="og:type" content="article"><meta property="og:title" content="LWIP之Mem原理"><meta property="og:url" content="http://example.com/2018/09/24/linux/lwip/mem/220714/"><meta property="og:site_name" content="仗剑走天涯"><meta property="og:description" content="版权归作者所有, 转载请保留该部分声明。本文作者：EtcFly原文地址：https:&#x2F;&#x2F;etcfly.top              前言   前一章我们讨论了内存池的分配和回收的一些内幕，这一节我们将来讨论一下 lwip 的 mem 内存堆机制，那有的人就很好奇，既然有了内存池的管理机制了，为什么还要多此一举搞个内存堆管理呢?二者有什么区别，又或者各有什么优缺点呢?"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/network.jpg"><meta property="article:published_time" content="2018-09-24T22:07:14.000Z"><meta property="article:modified_time" content="2024-03-05T03:41:03.000Z"><meta property="article:author" content="EtcFly"><meta property="article:tag" content="原创"><meta property="article:tag" content="TCPIP"><meta property="article:tag" content="LWIP"><meta property="article:tag" content="MEM"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/img/network.jpg"><title>LWIP之Mem原理 仗剑走天涯</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/fluid-extention.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:4},web_analytics:{enable:!0,follow_dnt:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"3AEufnWAJdp8cFODp1DXvrQU-MdYXbMMI",app_key:"mGJiL6xVvYv21ygqfynJoCyO",server_url:null,path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Strive For Dream</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="LWIP之Mem原理"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2018-09-24 22:07" pubdate>2018年9月24日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 14k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 117 分钟 </span><span id="vvdpost_container_page_pvuv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="vvdpost_value_page_pv">0</span> 次&nbsp&nbsp <i class="iconfont icon-users" aria-hidden="true"></i> <span id="vvdpost_value_page_uv">0</span> 人</span><script>console.log(window.location.pathname);var httpRequest=new XMLHttpRequest;httpRequest.open("POST","https://etcfly.top:14200/poststats",!0),httpRequest.setRequestHeader("Content-type","application/json"),httpRequest.send(JSON.stringify(window.location.pathname)),httpRequest.onreadystatechange=function(){if(4==httpRequest.readyState&&200==httpRequest.status){var e=httpRequest.responseText,t=JSON.parse(e);console.log(t.pv);var o=document.querySelector("#vvdpost_container_page_pvuv");if(console.log(o),o){var n=document.querySelector("#vvdpost_value_page_pv");console.log(n);var s=document.querySelector("#vvdpost_value_page_uv");console.log(s),s&&s&&(n.innerText=t.pv,s.innerText=t.uv,o.style.display="inline")}}}</script></div></div></div></div></div></div><script async src="https://etcfly.top:14100/script.js" data-website-id="1a5c096d-21e5-4556-99b0-28c810c9c868"></script></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">LWIP之Mem原理</h1><p class="note note-info">本文最后更新于：2024年3月5日 凌晨</p><div class="markdown-body"><div class="note note-success"><p>版权归作者所有, 转载请保留该部分声明。<br>本文作者：EtcFly<br>原文地址：<a target="_blank" rel="noopener" href="https://etcfly.top">https://etcfly.top</a></p></div><hr><h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>  前一章我们讨论了内存池的分配和回收的一些内幕，这一节我们将来讨论一下 <code>lwip</code> 的 <code>mem</code> 内存堆机制，那有的人就很好奇，既然有了内存池的管理机制了，为什么还要多此一举搞个内存堆管理呢?二者有什么区别，又或者各有什么优缺点呢? 这些疑惑将在这一节揭晓。</p><h3 id="memp相关宏以及变量的解释"><a class="markdownIt-Anchor" href="#memp相关宏以及变量的解释"></a> memp相关宏以及变量的解释</h3><h4 id="宏定义解释"><a class="markdownIt-Anchor" href="#宏定义解释"></a> 宏定义解释</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>	<span class="hljs-number">1</span>、MEM_USE_POOLS         <span class="hljs-comment">//使用内存池分配内存堆</span><br><span class="hljs-number">2.</span>	<span class="hljs-number">2</span>、MEM_LIBC_MALLOC       <span class="hljs-comment">//使用标准c函数库分配</span><br><span class="hljs-number">3.</span>	<span class="hljs-number">3</span>、MIN_SIZE                <span class="hljs-comment">//最小内存池大小</span><br><span class="hljs-number">4.</span>	<span class="hljs-number">4</span>、LWIP_RAM_HEAP_POINTER    <span class="hljs-comment">//定义的内存池的头部</span><br><span class="hljs-number">5.</span>	<span class="hljs-number">6</span>、MEM_USE_POOLS_TRY_BIGGER_POOL  <span class="hljs-comment">//如果当前内存池枯竭，将尝试其他大的内存池</span><br></code></pre></td></tr></table></figure><h4 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">memp_malloc_helper</span></span><br><span class="hljs-class">2.	&#123;</span><br><span class="hljs-number">3.</span>	   <span class="hljs-type">memp_t</span> poolnr;<br><span class="hljs-number">4.</span>	&#125;; <span class="hljs-comment">//当使用MEM_USE_POOLS时，mem内存用于区分哪一类型内存池</span><br><span class="hljs-number">5.</span><br><span class="hljs-number">6.</span>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem</span> &#123;</span><br><span class="hljs-number">7.</span>	  <span class="hljs-comment">/** index (-&gt; ram[next]) of the next struct */</span><br><span class="hljs-number">8.</span>	  <span class="hljs-type">mem_size_t</span> next;<br><span class="hljs-number">9.</span>	  <span class="hljs-comment">/** index (-&gt; ram[prev]) of the previous struct */</span><br><span class="hljs-number">10.</span>	  <span class="hljs-type">mem_size_t</span> prev;<br><span class="hljs-number">11.</span>	  <span class="hljs-comment">/** 1: this area is used; 0: this area is unused */</span><br><span class="hljs-number">12.</span>	  <span class="hljs-type">u8_t</span> used;<br><span class="hljs-number">13.</span>	&#125;;  <span class="hljs-comment">//当不使用MEM_USE_POOLS是内存管理结构</span><br></code></pre></td></tr></table></figure><p>以上就是内存堆管理最重要的两个基本结构单元</p><hr><h4 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>	<span class="hljs-type">u8_t</span> ram_heap[MEM_SIZE_ALIGNED + (<span class="hljs-number">2</span>*SIZEOF_STRUCT_MEM) + MEM_ALIGNMENT];   <span class="hljs-comment">//实际定义的物理内存堆</span><br><span class="hljs-number">2.</span>	<span class="hljs-type">static</span> <span class="hljs-type">u8_t</span> *ram;   <span class="hljs-comment">//始终指向内存堆的首部</span><br><span class="hljs-number">3.</span>	<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem</span> *<span class="hljs-title">ram_end</span>;</span>   <span class="hljs-comment">//始终指向内存堆的尾部</span><br><span class="hljs-number">4.</span>	<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem</span> *<span class="hljs-title">lfree</span>;</span>  <span class="hljs-comment">//始终指向内存堆中最低空闲内存块的地址</span><br></code></pre></td></tr></table></figure><p>  有人就要问了，就上面几个变量吗? 你可不要耍我啊，对你没有看错，在你眼中如此冗杂的内存管理仅仅使用上图这么几个简答的变量，由此可以看出其编码的巧妙。这也告诉我们，看起来冗杂的东西不要害怕，<code>maybe</code> 只是虚胖，哈哈哈。。。</p><hr><h3 id="mem的内存机制原理"><a class="markdownIt-Anchor" href="#mem的内存机制原理"></a> Mem的内存机制原理</h3><p>  这里，为了让大家更加直观的认识，我觉得从上而下开始讲解。其实 <code>MEM</code> 提供几种分配机制。</p><blockquote><ol><li>使用使用LWIP自己的内存分配机制</li><li>使用系统的库(<code>malloc</code>和<code>free</code>)来分配</li></ol></blockquote><p>  而决定上面的分配方式是通过 <code>MEM_LIBC_MALLOC</code> 来实现的，当为 <code>1</code> 时采用 <code>c</code> 中的 <code>malloc</code> 和 <code>free</code> 来实现的。这里我们着重分析 <code>LWIP</code> 自己的内存分配机制。好了，现在 <code>LWIP</code> 是通过自己的内存分配机制来实现内存堆了，那么就结束了吗??? 不不不，怎么可能，<code>LWIP</code> 在此基础上又分了两种构造机制。</p><blockquote><ol><li>使用MEMP机制来分配内存堆</li><li>使用自定义的物理内存来分配内存堆</li></ol></blockquote><p>  由此，才将所谓的内存申请动作真正映射到物理内存，故一般我将第二个宏的作用定义为决定内存的来源。本着有简到难的观点出发，我们首先来看一下<code>USE POOLS</code>。</p><p><img src="/2018/09/24/linux/lwip/mem/220714/%E4%BD%BF%E7%94%A8memp%E4%B8%BAmem%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98.png" srcset="/img/loading.gif" lazyload alt="使用memp为mem分配内存.png"></p><hr><p>  上图为使用内存池来分配内存堆的图示，由图我们可以看出，内存申请后，<code>lwip</code> 在申请的内存前加了一个 <code>poolnr</code> 的结构，这个正是我们前面提到的 <code>struct memp_malloc_helper</code> 结构，它专门用来管理使用内存池分配内存堆的。</p><p>  有的人可能就要问了，为什么要引入这样的结构呢?按照我们以往的经验来说，不应该是分配好内存，到释放的时候直接使用这个地址来释放就好了吗? 是的，你说的没错，但是你忽略了一点，那就是不同的内存池的大小不一样，也就是在释放的时候必须还要指定具体是哪一个尺寸的内存池给你分配的内存，因此，这个结构主要就是记录这个信息。</p><p>  有的人又要问，那我使用一个外部变量来管理不就可以了，确实如此，但是假象一下，当你申请了 <code>100</code> 个内存块，此时如果你自己来管理将是多磨的冗杂，并且容易出错，因此lwip为我们很好的解决了这个问题。</p><p>  讲完了 <code>mem</code> 使用内存池的申请，我们接下来看看内存堆自己对申请和释放是如何管理的。首先来看一下内存堆初始的模型。</p><p><img src="/2018/09/24/linux/lwip/mem/220714/mem%E5%88%9D%E5%A7%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" lazyload alt="mem初始内存模型.png"></p><hr><p>  由图可以看出，在初始化完成，其实内存堆被分为了两个块，一块是真正的内存卡，及 <code>ram_heap</code> 和 <code>ram_end</code> 之间的内存，另一个是 <code>ram_end</code> 之后的内存。至于为什么其后面存在多余的空闲的内存，主要是考虑的内存对齐的开销，因此增加了适量的内存。</p><p><img src="/2018/09/24/linux/lwip/mem/220714/mem%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8E%9F%E7%90%86.png" srcset="/img/loading.gif" lazyload alt="mem内存分配原理.png"></p><hr><p>  上图所示为 <code>mem</code> 在初始化完成申请的第一个内存，可以看出 <code>Ifree</code> 会随着分配的进行指向最低空闲内存块，同是由 <code>struct mem</code> 结构来连接新形成的内存块，使其形成一个链式的结构，使用 <code>used</code> 域来标识该内存块是否使用。</p><p><img src="/2018/09/24/linux/lwip/mem/220714/%E5%88%86%E9%85%8D%E9%87%8A%E6%94%BEn%E6%AC%A1.png" srcset="/img/loading.gif" lazyload alt="分配释放n次.png"></p><p>  上图表示申请了 <code>n</code> 次后的一个内存状况，可以看出，经过 <code>n</code> 次的内存申请和释放后，内存趋于分散化，此时将形成内存碎片，而不是像 <code>memp</code> 一样 <code>0</code> 碎片化。而对于如何优化和处理碎片也是众多内存分配和释放算法的一个重要的区别。对于这个小的碎片，我们需要在适时对其进行合并，以达到一些大的内存申请需要。<code>Lwip</code> 也提供了这样的机制，我们将在源码分析中对其进行讲解。我们可以通过下图加以理解。</p><p><img src="/2018/09/24/linux/lwip/mem/220714/mem%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%E5%8E%9F%E7%90%86%E5%8F%8A%E5%90%88%E5%B9%B6.png" srcset="/img/loading.gif" lazyload alt="mem内存释放原理及合并.png"></p><p>由于图片太大，貌似截图都不太清晰，文章后边将附上这些图的下载链接供读者自行下载。</p><hr><h3 id="mem的源码分析"><a class="markdownIt-Anchor" href="#mem的源码分析"></a> Mem的源码分析</h3><h4 id="内存池的初始化"><a class="markdownIt-Anchor" href="#内存池的初始化"></a> 内存池的初始化</h4><p>  这里需要注意一点，对于内存池分配方式而言，是不需要 <code>mem_init()</code> 的初始化的，原因在于 <code>mem_init</code> 主要是为内存堆准备起始环境，而如果使用内存池分配不需要该环境，而是需要初始化 <code>memp_init()</code> 内存池环境。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>	<span class="hljs-type">void</span><br><span class="hljs-number">2.</span>	mem_init(<span class="hljs-type">void</span>)<br><span class="hljs-number">3.</span>	&#123;<br><span class="hljs-number">4.</span>	  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem</span> *<span class="hljs-title">mem</span>;</span><br><span class="hljs-number">5.</span><br><span class="hljs-number">6.</span>	  LWIP_ASSERT(<span class="hljs-string">&quot;Sanity check alignment&quot;</span>,<br><span class="hljs-number">7.</span>	    (SIZEOF_STRUCT_MEM &amp; (MEM_ALIGNMENT<span class="hljs-number">-1</span>)) == <span class="hljs-number">0</span>);<br><span class="hljs-number">8.</span><br><span class="hljs-number">9.</span>	  <span class="hljs-comment">/* align the heap */</span><br><span class="hljs-number">10.</span>	  ram = (<span class="hljs-type">u8_t</span> *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);<br><span class="hljs-number">11.</span>	  <span class="hljs-comment">/* initialize the start of the heap */</span><br><span class="hljs-number">12.</span>	  mem = (<span class="hljs-keyword">struct</span> mem *)(<span class="hljs-type">void</span> *)ram;<br><span class="hljs-number">13.</span>	  mem-&gt;next = MEM_SIZE_ALIGNED;<br><span class="hljs-number">14.</span>	  mem-&gt;prev = <span class="hljs-number">0</span>;<br><span class="hljs-number">15.</span>	  mem-&gt;used = <span class="hljs-number">0</span>;<br><span class="hljs-number">16.</span>	  <span class="hljs-comment">/* initialize the end of the heap */</span><br><span class="hljs-number">17.</span>	  ram_end = (<span class="hljs-keyword">struct</span> mem *)(<span class="hljs-type">void</span> *)&amp;ram[MEM_SIZE_ALIGNED];<br><span class="hljs-number">18.</span>	  ram_end-&gt;used = <span class="hljs-number">1</span>;<br><span class="hljs-number">19.</span>	  ram_end-&gt;next = MEM_SIZE_ALIGNED;<br><span class="hljs-number">20.</span>	  ram_end-&gt;prev = MEM_SIZE_ALIGNED;<br><span class="hljs-number">21.</span><br><span class="hljs-number">22.</span>	  <span class="hljs-comment">/* initialize the lowest-free pointer to the start of the heap */</span><br><span class="hljs-number">23.</span>	  lfree = (<span class="hljs-keyword">struct</span> mem *)(<span class="hljs-type">void</span> *)ram;<br><span class="hljs-number">24.</span><br><span class="hljs-number">25.</span>	  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);<br><span class="hljs-number">26.</span><br><span class="hljs-number">27.</span>	  <span class="hljs-keyword">if</span>(sys_mutex_new(&amp;mem_mutex) != ERR_OK) &#123;<br><span class="hljs-number">28.</span>	    LWIP_ASSERT(<span class="hljs-string">&quot;failed to create mem_mutex&quot;</span>, <span class="hljs-number">0</span>);<br><span class="hljs-number">29.</span>	  &#125;<br><span class="hljs-number">30.</span>	&#125;<br></code></pre></td></tr></table></figure><p>由上面可以看出，内存堆初始化主要做了这几件事。</p><blockquote><ol><li>初始化内存管理的基本结构，即mem结构。</li><li>初始化尾部ram_end及Ifree。</li></ol></blockquote><hr><h4 id="内存池的分配"><a class="markdownIt-Anchor" href="#内存池的分配"></a> 内存池的分配</h4><h5 id="使用内存池分配"><a class="markdownIt-Anchor" href="#使用内存池分配"></a> 使用内存池分配</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>	<span class="hljs-type">void</span> *<br><span class="hljs-number">2.</span>	mem_malloc(<span class="hljs-type">mem_size_t</span> size)<br><span class="hljs-number">3.</span>	&#123;<br><span class="hljs-number">4.</span>	  <span class="hljs-type">void</span> *ret;<br><span class="hljs-number">5.</span>	  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">memp_malloc_helper</span> *<span class="hljs-title">element</span>;</span><br><span class="hljs-number">6.</span>	  <span class="hljs-type">memp_t</span> poolnr;<br><span class="hljs-number">7.</span>	  <span class="hljs-type">mem_size_t</span> required_size = size + LWIP_MEM_ALIGN_SIZE(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> memp_malloc_helper));  <span class="hljs-comment">//计算实际需要的内存</span><br><span class="hljs-number">8.</span><br><span class="hljs-number">9.</span>	  <span class="hljs-keyword">for</span> (poolnr = MEMP_POOL_FIRST; poolnr &lt;= MEMP_POOL_LAST; poolnr = (<span class="hljs-type">memp_t</span>)(poolnr + <span class="hljs-number">1</span>)) &#123;<br><span class="hljs-number">10.</span>	<span class="hljs-meta">#<span class="hljs-keyword">if</span> MEM_USE_POOLS_TRY_BIGGER_POOL</span><br><span class="hljs-number">11.</span>	again:<br><span class="hljs-number">12.</span>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* MEM_USE_POOLS_TRY_BIGGER_POOL */</span></span><br><span class="hljs-number">13.</span>	    <span class="hljs-comment">/* is this pool big enough to hold an element of the required size</span><br><span class="hljs-comment">14.	       plus a struct memp_malloc_helper that saves the pool this element came from? */</span><br><span class="hljs-number">15.</span>	    <span class="hljs-keyword">if</span> (required_size &lt;= memp_sizes[poolnr]) &#123;<br><span class="hljs-number">16.</span>	      <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//适配到需要的大小相当的内存池</span><br><span class="hljs-number">17.</span>	    &#125;<br><span class="hljs-number">18.</span>	  &#125;<br><span class="hljs-number">19.</span>	  <span class="hljs-keyword">if</span> (poolnr &gt; MEMP_POOL_LAST) &#123;<br><span class="hljs-number">20.</span>	    LWIP_ASSERT(<span class="hljs-string">&quot;mem_malloc(): no pool is that big!&quot;</span>, <span class="hljs-number">0</span>);<br><span class="hljs-number">21.</span>	    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-number">22.</span>	  &#125;<br><span class="hljs-number">23.</span>	  element = (<span class="hljs-keyword">struct</span> memp_malloc_helper*)memp_malloc(poolnr);  <span class="hljs-comment">//从该内存池的链表上进行内存申请，但是此时不一样链表上存在内存</span><br><span class="hljs-number">24.</span>	  <span class="hljs-keyword">if</span> (element == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-number">25.</span>	    <span class="hljs-comment">/* No need to DEBUGF or ASSERT: This error is already</span><br><span class="hljs-comment">26.	       taken care of in memp.c */</span><br><span class="hljs-number">27.</span>	<span class="hljs-meta">#<span class="hljs-keyword">if</span> MEM_USE_POOLS_TRY_BIGGER_POOL  <span class="hljs-comment">//如果定义了 可以查找其他的内存池链</span></span><br><span class="hljs-number">28.</span>	    <span class="hljs-comment">/** Try a bigger pool if this one is empty! */</span><br><span class="hljs-number">29.</span>	    <span class="hljs-keyword">if</span> (poolnr &lt; MEMP_POOL_LAST) &#123;  <span class="hljs-comment">//遍历所有的内存池</span><br><span class="hljs-number">30.</span>	      poolnr++;<br><span class="hljs-number">31.</span>	      <span class="hljs-keyword">goto</span> again;<br><span class="hljs-number">32.</span>	    &#125;<br><span class="hljs-number">33.</span>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* MEM_USE_POOLS_TRY_BIGGER_POOL */</span></span><br><span class="hljs-number">34.</span>	    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//内存枯竭  申请失败</span><br><span class="hljs-number">35.</span>	  &#125;<br><span class="hljs-number">36.</span><br><span class="hljs-number">37.</span>	  <span class="hljs-comment">/* save the pool number this element came from */</span><br><span class="hljs-number">38.</span>	  element-&gt;poolnr = poolnr;<br><span class="hljs-number">39.</span>	  <span class="hljs-comment">/* and return a pointer to the memory directly after the struct memp_malloc_helper */</span><br><span class="hljs-number">40.</span>	  ret = (<span class="hljs-type">u8_t</span>*)element + LWIP_MEM_ALIGN_SIZE(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> memp_malloc_helper));<br><span class="hljs-number">41.</span><br><span class="hljs-number">42.</span>	  <span class="hljs-keyword">return</span> ret;<br><span class="hljs-number">43.</span>	&#125;<br></code></pre></td></tr></table></figure><p>  内存池的分配方式高效并且不会产生碎片，这在 <code>memp</code> 内存池这一章已经讲过了，<code>mem</code> 的主要优点在于可以对不同内存大小的分配更加的灵活。以上的分配的策略主要是：</p><blockquote><ol><li>查找当前内存是否存在大于需求的内存池。存在将返回内存池的<code>label</code></li><li>通过<code>label</code>查找该内存池的空闲块看是否存在空闲内存，不存在将分配失败。</li></ol></blockquote><p>当然，如果 使能了<code>MEM_USE_POOLS_TRY_BIGGER_POOL</code>宏的话，将再次搜索下一个大于需求内存的<code>label</code>，直到找到或者全遍历。</p><hr><h6 id="使用内存堆分配"><a class="markdownIt-Anchor" href="#使用内存堆分配"></a> 使用内存堆分配</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>	mem_malloc(<span class="hljs-type">mem_size_t</span> size)<br><span class="hljs-number">2.</span>	&#123;<br><span class="hljs-number">3.</span>	  <span class="hljs-type">mem_size_t</span> ptr, ptr2;<br><span class="hljs-number">4.</span>	  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem</span> *<span class="hljs-title">mem</span>, *<span class="hljs-title">mem2</span>;</span><br><span class="hljs-number">5.</span>	<span class="hljs-meta">#<span class="hljs-keyword">if</span> LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT</span><br><span class="hljs-number">6.</span>	  <span class="hljs-type">u8_t</span> local_mem_free_count = <span class="hljs-number">0</span>;<br><span class="hljs-number">7.</span>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */</span></span><br><span class="hljs-number">8.</span>	  LWIP_MEM_ALLOC_DECL_PROTECT();<br><span class="hljs-number">9.</span><br><span class="hljs-number">10.</span>	  <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-number">11.</span>	    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-number">12.</span>	  &#125;<br><span class="hljs-number">13.</span><br><span class="hljs-number">14.</span>	  <span class="hljs-comment">/* Expand the size of the allocated memory region so that we can</span><br><span class="hljs-comment">15.	     adjust for alignment. */</span><br><span class="hljs-number">16.</span>	  size = LWIP_MEM_ALIGN_SIZE(size);<br><span class="hljs-number">17.</span><br><span class="hljs-number">18.</span>	  <span class="hljs-keyword">if</span>(size &lt; MIN_SIZE_ALIGNED) &#123;<br><span class="hljs-number">19.</span>	    <span class="hljs-comment">/* every data block must be at least MIN_SIZE_ALIGNED long */</span><br><span class="hljs-number">20.</span>	    size = MIN_SIZE_ALIGNED;  <span class="hljs-comment">//保证最小的内存空间，避免过小的内存碎片化</span><br><span class="hljs-number">21.</span>	  &#125;<br><span class="hljs-number">22.</span><br><span class="hljs-number">23.</span>	  <span class="hljs-keyword">if</span> (size &gt; MEM_SIZE_ALIGNED) &#123;<br><span class="hljs-number">24.</span>	    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-number">25.</span>	  &#125;<br><span class="hljs-number">26.</span><br><span class="hljs-number">27.</span>	  <span class="hljs-comment">/* protect the heap from concurrent access */</span><br><span class="hljs-number">28.</span>	  sys_mutex_lock(&amp;mem_mutex);<br><span class="hljs-number">29.</span>	  LWIP_MEM_ALLOC_PROTECT();<br><span class="hljs-number">30.</span>	<span class="hljs-meta">#<span class="hljs-keyword">if</span> LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT</span><br><span class="hljs-number">31.</span>	  <span class="hljs-comment">/* run as long as a mem_free disturbed mem_malloc or mem_trim */</span><br><span class="hljs-number">32.</span>	  <span class="hljs-keyword">do</span> &#123;<br><span class="hljs-number">33.</span>	    local_mem_free_count = <span class="hljs-number">0</span>;<br><span class="hljs-number">34.</span>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */</span></span><br><span class="hljs-number">35.</span><br><span class="hljs-number">36.</span>	    <span class="hljs-comment">/* Scan through the heap searching for a free block that is big enough,</span><br><span class="hljs-comment">37.	     * beginning with the lowest free block.</span><br><span class="hljs-comment">38.	     */</span><br><span class="hljs-number">39.</span>	    <span class="hljs-comment">//搜索空闲内存</span><br><span class="hljs-number">40.</span>	    <span class="hljs-keyword">for</span> (ptr = (<span class="hljs-type">mem_size_t</span>)((<span class="hljs-type">u8_t</span> *)lfree - ram); ptr &lt; MEM_SIZE_ALIGNED - size;  ptr = ((<span class="hljs-keyword">struct</span> mem *)(<span class="hljs-type">void</span> *)&amp;ram[ptr])-&gt;next) &#123;<br><span class="hljs-number">41.</span>	      mem = (<span class="hljs-keyword">struct</span> mem *)(<span class="hljs-type">void</span> *)&amp;ram[ptr];  <span class="hljs-comment">//获取内存块首地址</span><br><span class="hljs-number">42.</span>	<span class="hljs-meta">#<span class="hljs-keyword">if</span> LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT</span><br><span class="hljs-number">43.</span>	      mem_free_count = <span class="hljs-number">0</span>;<br><span class="hljs-number">44.</span>	      LWIP_MEM_ALLOC_UNPROTECT();<br><span class="hljs-number">45.</span>	      <span class="hljs-comment">/* allow mem_free or mem_trim to run */</span><br><span class="hljs-number">46.</span>	      LWIP_MEM_ALLOC_PROTECT();<br><span class="hljs-number">47.</span>	      <span class="hljs-keyword">if</span> (mem_free_count != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-number">48.</span>	        <span class="hljs-comment">/* If mem_free or mem_trim have run, we have to restart since they</span><br><span class="hljs-comment">49.	           could have altered our current struct mem. */</span><br><span class="hljs-number">50.</span>	        local_mem_free_count = <span class="hljs-number">1</span>;<br><span class="hljs-number">51.</span>	        <span class="hljs-keyword">break</span>;<br><span class="hljs-number">52.</span>	      &#125;<br><span class="hljs-number">53.</span>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */</span></span><br><span class="hljs-number">54.</span>	       <span class="hljs-comment">//查找空闲内存是否大于需求的内存</span><br><span class="hljs-number">55.</span>	      <span class="hljs-keyword">if</span> ((!mem-&gt;used) &amp;&amp; (mem-&gt;next - (ptr + SIZEOF_STRUCT_MEM)) &gt;= size) &#123;<br><span class="hljs-number">56.</span>	        <span class="hljs-comment">/* mem is not used and at least perfect fit is possible:</span><br><span class="hljs-comment">57.	         * mem-&gt;next - (ptr + SIZEOF_STRUCT_MEM) gives us the &#x27;user data size&#x27; of mem */</span><br><span class="hljs-number">58.</span>	        <span class="hljs-keyword">if</span> (mem-&gt;next - (ptr + SIZEOF_STRUCT_MEM) &gt;= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) &#123;  <span class="hljs-comment">//查看内存后边的空闲内存是否可以继续维持一个空闲内存块</span><br><span class="hljs-number">59.</span>	          <span class="hljs-comment">/* (in addition to the above, we test if another struct mem (SIZEOF_STRUCT_MEM) containing</span><br><span class="hljs-comment">60.	           * at least MIN_SIZE_ALIGNED of data also fits in the &#x27;user data space&#x27; of &#x27;mem&#x27;)</span><br><span class="hljs-comment">61.	           * -&gt; split large block, create empty remainder,</span><br><span class="hljs-comment">62.	           * remainder must be large enough to contain MIN_SIZE_ALIGNED data: if</span><br><span class="hljs-comment">63.	           * mem-&gt;next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,</span><br><span class="hljs-comment">64.	           * struct mem would fit in but no data between mem2 and mem2-&gt;next</span><br><span class="hljs-comment">65.	           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty</span><br><span class="hljs-comment">66.	           *       region that couldn&#x27;t hold data, but when mem-&gt;next gets freed,</span><br><span class="hljs-comment">67.	           *       the 2 regions would be combined, resulting in more free memory</span><br><span class="hljs-comment">68.	           */</span><br><span class="hljs-number">69.</span>	          ptr2 = ptr + SIZEOF_STRUCT_MEM + size; <span class="hljs-comment">//分配内存后边的内存地址</span><br><span class="hljs-number">70.</span>	          <span class="hljs-comment">/* create mem2 struct */</span><br><span class="hljs-number">71.</span>	          mem2 = (<span class="hljs-keyword">struct</span> mem *)(<span class="hljs-type">void</span> *)&amp;ram[ptr2]; <span class="hljs-comment">//后边内存形成一个新的内存块</span><br><span class="hljs-number">72.</span>	          mem2-&gt;used = <span class="hljs-number">0</span>;<br><span class="hljs-number">73.</span>	          mem2-&gt;next = mem-&gt;next;<br><span class="hljs-number">74.</span>	          mem2-&gt;prev = ptr;<br><span class="hljs-number">75.</span>	          <span class="hljs-comment">/* and insert it between mem and mem-&gt;next */</span><br><span class="hljs-number">76.</span>	          mem-&gt;next = ptr2;<br><span class="hljs-number">77.</span>	          mem-&gt;used = <span class="hljs-number">1</span>;<br><span class="hljs-number">78.</span><br><span class="hljs-number">79.</span>	          <span class="hljs-keyword">if</span> (mem2-&gt;next != MEM_SIZE_ALIGNED) &#123;  <span class="hljs-comment">//不是尾部结束块需要将其指向前面的内存块，形成双向链表</span><br><span class="hljs-number">80.</span>	            ((<span class="hljs-keyword">struct</span> mem *)(<span class="hljs-type">void</span> *)&amp;ram[mem2-&gt;next])-&gt;prev = ptr2;<br><span class="hljs-number">81.</span>	          &#125;<br><span class="hljs-number">82.</span>	          MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));<br><span class="hljs-number">83.</span>	        &#125;<br><span class="hljs-number">84.</span>	        <span class="hljs-keyword">else</span> &#123;   <span class="hljs-comment">//后边内存过小，出现碎片化</span><br><span class="hljs-number">85.</span>	          <span class="hljs-comment">/* (a mem2 struct does no fit into the user data space of mem and mem-&gt;next will always</span><br><span class="hljs-comment">86.	           * be used at this point: if not we have 2 unused structs in a row, plug_holes should have</span><br><span class="hljs-comment">87.	           * take care of this).</span><br><span class="hljs-comment">88.	           * -&gt; near fit or excact fit: do not split, no mem2 creation</span><br><span class="hljs-comment">89.	           * also can&#x27;t move mem-&gt;next directly behind mem, since mem-&gt;next</span><br><span class="hljs-comment">90.	           * will always be used at this point!</span><br><span class="hljs-comment">91.	           */</span><br><span class="hljs-number">92.</span>	          mem-&gt;used = <span class="hljs-number">1</span>;<br><span class="hljs-number">93.</span>	          MEM_STATS_INC_USED(used, mem-&gt;next - (<span class="hljs-type">mem_size_t</span>)((<span class="hljs-type">u8_t</span> *)mem - ram));<br><span class="hljs-number">94.</span>	        &#125;<br><span class="hljs-number">95.</span>	<span class="hljs-meta">#<span class="hljs-keyword">if</span> LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT</span><br><span class="hljs-number">96.</span>	mem_malloc_adjust_lfree:<br><span class="hljs-number">97.</span>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */</span></span><br><span class="hljs-number">98.</span>	        <span class="hljs-keyword">if</span> (mem == lfree) &#123; <span class="hljs-comment">//Ifree更新到新的空闲内存地址</span><br><span class="hljs-number">99.</span>	          <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem</span> *<span class="hljs-title">cur</span> =</span> lfree;<br><span class="hljs-number">100.</span>	          <span class="hljs-comment">/* Find next free block after mem and update lowest free pointer */</span><br><span class="hljs-number">101.</span>	          <span class="hljs-keyword">while</span> (cur-&gt;used &amp;&amp; cur != ram_end) &#123;<br><span class="hljs-number">102.</span>	<span class="hljs-meta">#<span class="hljs-keyword">if</span> LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT</span><br><span class="hljs-number">103.</span>	            mem_free_count = <span class="hljs-number">0</span>;<br><span class="hljs-number">104.</span>	            LWIP_MEM_ALLOC_UNPROTECT();<br><span class="hljs-number">105.</span>	            <span class="hljs-comment">/* prevent high interrupt latency... */</span><br><span class="hljs-number">106.</span>	            LWIP_MEM_ALLOC_PROTECT();<br><span class="hljs-number">107.</span>	            <span class="hljs-keyword">if</span> (mem_free_count != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-number">108.</span>	              <span class="hljs-comment">/* If mem_free or mem_trim have run, we have to restart since they</span><br><span class="hljs-comment">109.	                 could have altered our current struct mem or lfree. */</span><br><span class="hljs-number">110.</span>	              <span class="hljs-keyword">goto</span> mem_malloc_adjust_lfree;<br><span class="hljs-number">111.</span>	            &#125;<br><span class="hljs-number">112.</span>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */</span></span><br><span class="hljs-number">113.</span>	            cur = (<span class="hljs-keyword">struct</span> mem *)(<span class="hljs-type">void</span> *)&amp;ram[cur-&gt;next];<br><span class="hljs-number">114.</span>	          &#125;<br><span class="hljs-number">115.</span>	          lfree = cur;<br><span class="hljs-number">116.</span>	          LWIP_ASSERT(<span class="hljs-string">&quot;mem_malloc: !lfree-&gt;used&quot;</span>, ((lfree == ram_end) || (!lfree-&gt;used)));<br><span class="hljs-number">117.</span>	        &#125;<br><span class="hljs-number">118.</span>	        LWIP_MEM_ALLOC_UNPROTECT();<br><span class="hljs-number">119.</span>	        sys_mutex_unlock(&amp;mem_mutex);<br><span class="hljs-number">120.</span>	        LWIP_ASSERT(<span class="hljs-string">&quot;mem_malloc: allocated memory not above ram_end.&quot;</span>,<br><span class="hljs-number">121.</span>	         (<span class="hljs-type">mem_ptr_t</span>)mem + SIZEOF_STRUCT_MEM + size &lt;= (<span class="hljs-type">mem_ptr_t</span>)ram_end);<br><span class="hljs-number">122.</span>	        LWIP_ASSERT(<span class="hljs-string">&quot;mem_malloc: allocated memory properly aligned.&quot;</span>,<br><span class="hljs-number">123.</span>	         ((<span class="hljs-type">mem_ptr_t</span>)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == <span class="hljs-number">0</span>);<br><span class="hljs-number">124.</span>	        LWIP_ASSERT(<span class="hljs-string">&quot;mem_malloc: sanity check alignment&quot;</span>,<br><span class="hljs-number">125.</span>	          (((<span class="hljs-type">mem_ptr_t</span>)mem) &amp; (MEM_ALIGNMENT<span class="hljs-number">-1</span>)) == <span class="hljs-number">0</span>);<br><span class="hljs-number">126.</span><br><span class="hljs-number">127.</span>	        <span class="hljs-keyword">return</span> (<span class="hljs-type">u8_t</span> *)mem + SIZEOF_STRUCT_MEM; <span class="hljs-comment">//返回申请的内存地址</span><br><span class="hljs-number">128.</span>	      &#125;<br><span class="hljs-number">129.</span>	    &#125;<br><span class="hljs-number">130.</span>	<span class="hljs-meta">#<span class="hljs-keyword">if</span> LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT</span><br><span class="hljs-number">131.</span>	    <span class="hljs-comment">/* if we got interrupted by a mem_free, try again */</span><br><span class="hljs-number">132.</span>	  &#125; <span class="hljs-keyword">while</span>(local_mem_free_count != <span class="hljs-number">0</span>);<br><span class="hljs-number">133.</span>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */</span></span><br><span class="hljs-number">134.</span>	  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, (<span class="hljs-string">&quot;mem_malloc: could not allocate %&quot;</span>S16_F<span class="hljs-string">&quot; bytes\n&quot;</span>, (<span class="hljs-type">s16_t</span>)size));<br><span class="hljs-number">135.</span>	  MEM_STATS_INC(err);<br><span class="hljs-number">136.</span>	  LWIP_MEM_ALLOC_UNPROTECT();<br><span class="hljs-number">137.</span>	  sys_mutex_unlock(&amp;mem_mutex);<br><span class="hljs-number">138.</span>	  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//申请失败</span><br><span class="hljs-number">139.</span>	&#125;<br></code></pre></td></tr></table></figure><p>  由上边的源码分析可知，内存堆的分配只要是通过<code>struct mem</code> 结构来形成一个双向的链表进行管理的，而管理整个内存链的过程中，如何区分已使用的内存和空闲的内存块呢? 于是引入<code>used</code>字段，因此，在这个内存链中，<code>used</code>字段将至关重要。还有一点大家需要明白，<code>mem</code>分配和<code>memp</code>分配有一个较大的差异，<code>memp</code>分配会将以使用的内存从空闲内存链中去除，而<code>mem</code>中，整个内存是一个完整的内存链，因此即使内存已经分配出去还是存在于系统的内存堆链中。</p><hr><h4 id="内存的释放"><a class="markdownIt-Anchor" href="#内存的释放"></a> 内存的释放</h4><p>内存的申请存在两种方式，那么必然对应着两种释放方式。</p><h5 id="内存池分配方式的释放"><a class="markdownIt-Anchor" href="#内存池分配方式的释放"></a> 内存池分配方式的释放</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>	<span class="hljs-type">void</span><br><span class="hljs-number">2.</span>	mem_free(<span class="hljs-type">void</span> *rmem)<br><span class="hljs-number">3.</span>	&#123;<br><span class="hljs-number">4.</span>	  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">memp_malloc_helper</span> *<span class="hljs-title">hmem</span>;</span><br><span class="hljs-number">5.</span><br><span class="hljs-number">6.</span>	  LWIP_ASSERT(<span class="hljs-string">&quot;rmem != NULL&quot;</span>, (rmem != <span class="hljs-literal">NULL</span>));<br><span class="hljs-number">7.</span>	  LWIP_ASSERT(<span class="hljs-string">&quot;rmem == MEM_ALIGN(rmem)&quot;</span>, (rmem == LWIP_MEM_ALIGN(rmem)));<br><span class="hljs-number">8.</span><br><span class="hljs-number">9.</span>	  <span class="hljs-comment">/* get the original struct memp_malloc_helper */</span><br><span class="hljs-number">10.</span>	  hmem = (<span class="hljs-keyword">struct</span> memp_malloc_helper*)(<span class="hljs-type">void</span>*)((<span class="hljs-type">u8_t</span>*)rmem - LWIP_MEM_ALIGN_SIZE(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> memp_malloc_helper)));  <span class="hljs-comment">//找到分配的真正首地址</span><br><span class="hljs-number">11.</span><br><span class="hljs-number">12.</span>	  LWIP_ASSERT(<span class="hljs-string">&quot;hmem != NULL&quot;</span>, (hmem != <span class="hljs-literal">NULL</span>));<br><span class="hljs-number">13.</span>	  LWIP_ASSERT(<span class="hljs-string">&quot;hmem == MEM_ALIGN(hmem)&quot;</span>, (hmem == LWIP_MEM_ALIGN(hmem)));<br><span class="hljs-number">14.</span>	  LWIP_ASSERT(<span class="hljs-string">&quot;hmem-&gt;poolnr &lt; MEMP_MAX&quot;</span>, (hmem-&gt;poolnr &lt; MEMP_MAX));<br><span class="hljs-number">15.</span><br><span class="hljs-number">16.</span>	  <span class="hljs-comment">/* and put it in the pool we saved earlier */</span><br><span class="hljs-number">17.</span>	  memp_free(hmem-&gt;poolnr, hmem);  <span class="hljs-comment">//通过struct memp_malloc_helper结构得到pool类型，hmem得到首地址，从而进行释放</span><br><span class="hljs-number">18.</span>	&#125;<br></code></pre></td></tr></table></figure><p>  其实，对于内存池的申请比较简单，这里就不讲了，读者可以通过我们的上一篇关于<code>memp</code>的文章来学习，这里带过。。</p><hr><h5 id="内存堆分配方式的释放"><a class="markdownIt-Anchor" href="#内存堆分配方式的释放"></a> 内存堆分配方式的释放</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>	<span class="hljs-type">void</span><br><span class="hljs-number">2.</span>	mem_free(<span class="hljs-type">void</span> *rmem)<br><span class="hljs-number">3.</span>	&#123;<br><span class="hljs-number">4.</span>	  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem</span> *<span class="hljs-title">mem</span>;</span><br><span class="hljs-number">5.</span>	  LWIP_MEM_FREE_DECL_PROTECT();<br><span class="hljs-number">6.</span><br><span class="hljs-number">7.</span>	  <span class="hljs-keyword">if</span> (rmem == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">//合法性检查</span><br><span class="hljs-number">8.</span>	    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, (<span class="hljs-string">&quot;mem_free(p == NULL) was called.\n&quot;</span>));<br><span class="hljs-number">9.</span>	    <span class="hljs-keyword">return</span>;<br><span class="hljs-number">10.</span>	  &#125;<br><span class="hljs-number">11.</span>	  LWIP_ASSERT(<span class="hljs-string">&quot;mem_free: sanity check alignment&quot;</span>, (((<span class="hljs-type">mem_ptr_t</span>)rmem) &amp; (MEM_ALIGNMENT<span class="hljs-number">-1</span>)) == <span class="hljs-number">0</span>);<br><span class="hljs-number">12.</span><br><span class="hljs-number">13.</span>	  LWIP_ASSERT(<span class="hljs-string">&quot;mem_free: legal memory&quot;</span>, (<span class="hljs-type">u8_t</span> *)rmem &gt;= (<span class="hljs-type">u8_t</span> *)ram &amp;&amp;<br><span class="hljs-number">14.</span>	    (<span class="hljs-type">u8_t</span> *)rmem &lt; (<span class="hljs-type">u8_t</span> *)ram_end);<br><span class="hljs-number">15.</span>	  <span class="hljs-comment">//合法性检查</span><br><span class="hljs-number">16.</span>	  <span class="hljs-keyword">if</span> ((<span class="hljs-type">u8_t</span> *)rmem &lt; (<span class="hljs-type">u8_t</span> *)ram || (<span class="hljs-type">u8_t</span> *)rmem &gt;= (<span class="hljs-type">u8_t</span> *)ram_end) &#123;<br><span class="hljs-number">17.</span>	    SYS_ARCH_DECL_PROTECT(lev);<br><span class="hljs-number">18.</span>	    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, (<span class="hljs-string">&quot;mem_free: illegal memory\n&quot;</span>));<br><span class="hljs-number">19.</span>	    <span class="hljs-comment">/* protect mem stats from concurrent access */</span><br><span class="hljs-number">20.</span>	    SYS_ARCH_PROTECT(lev);<br><span class="hljs-number">21.</span>	    MEM_STATS_INC(illegal);<br><span class="hljs-number">22.</span>	    SYS_ARCH_UNPROTECT(lev);<br><span class="hljs-number">23.</span>	    <span class="hljs-keyword">return</span>;<br><span class="hljs-number">24.</span>	  &#125;<br><span class="hljs-number">25.</span>	  <span class="hljs-comment">/* protect the heap from concurrent access */</span><br><span class="hljs-number">26.</span>	  LWIP_MEM_FREE_PROTECT();<br><span class="hljs-number">27.</span>	  <span class="hljs-comment">/* Get the corresponding struct mem ... */</span><br><span class="hljs-number">28.</span>	  mem = (<span class="hljs-keyword">struct</span> mem *)(<span class="hljs-type">void</span> *)((<span class="hljs-type">u8_t</span> *)rmem - SIZEOF_STRUCT_MEM);  <span class="hljs-comment">//获取真实的内存首地址</span><br><span class="hljs-number">29.</span>	  <span class="hljs-comment">/* ... which has to be in a used state ... */</span><br><span class="hljs-number">30.</span>	  LWIP_ASSERT(<span class="hljs-string">&quot;mem_free: mem-&gt;used&quot;</span>, mem-&gt;used);<br><span class="hljs-number">31.</span>	  <span class="hljs-comment">/* ... and is now unused. */</span><br><span class="hljs-number">32.</span>	  mem-&gt;used = <span class="hljs-number">0</span>;  <span class="hljs-comment">//释放内存</span><br><span class="hljs-number">33.</span><br><span class="hljs-number">34.</span>	  <span class="hljs-keyword">if</span> (mem &lt; lfree) &#123; <span class="hljs-comment">//ifree指针的更新</span><br><span class="hljs-number">35.</span>	    <span class="hljs-comment">/* the newly freed struct is now the lowest */</span><br><span class="hljs-number">36.</span>	    lfree = mem;<br><span class="hljs-number">37.</span>	  &#125;<br><span class="hljs-number">38.</span><br><span class="hljs-number">39.</span>	  MEM_STATS_DEC_USED(used, mem-&gt;next - (<span class="hljs-type">mem_size_t</span>)(((<span class="hljs-type">u8_t</span> *)mem - ram)));<br><span class="hljs-number">40.</span><br><span class="hljs-number">41.</span>	  <span class="hljs-comment">/* finally, see if prev or next are free also */</span><br><span class="hljs-number">42.</span>	  plug_holes(mem);  <span class="hljs-comment">//内存合并</span><br><span class="hljs-number">43.</span>	<span class="hljs-meta">#<span class="hljs-keyword">if</span> LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT</span><br><span class="hljs-number">44.</span>	  mem_free_count = <span class="hljs-number">1</span>;<br><span class="hljs-number">45.</span>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */</span></span><br><span class="hljs-number">46.</span>	  LWIP_MEM_FREE_UNPROTECT();<br><span class="hljs-number">47.</span>	&#125;<br></code></pre></td></tr></table></figure><p>由上可以，内存堆的释放同样比较简单，主要是两个工作。</p><blockquote><ol><li>释放内存，及将used字段清0。</li><li>检查释放内存的前后，如果存在空闲内存将进行内存的合并。</li></ol></blockquote><p>当然，<code>mem</code> 中还存在其他的一些功能函数，如 <code>void *mem_trim(void *rmem, mem_size_t newsize)</code>，进行内存的压缩等等。读者可根据兴趣自行阅读和分析。</p><p>最后在指出一点，就是当系统使用了默认的<code>c</code>分配函数，如<code>malloc</code>和<code>free</code>是，将存在如下的内存分配函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>	<span class="hljs-type">void</span> *<span class="hljs-title function_">mem_calloc</span><span class="hljs-params">(<span class="hljs-type">mem_size_t</span> count, <span class="hljs-type">mem_size_t</span> size)</span><br>2.	&#123;<br><span class="hljs-number">3.</span>	  <span class="hljs-type">void</span> *p;<br><span class="hljs-number">4.</span><br><span class="hljs-number">5.</span>	  <span class="hljs-comment">/* allocate &#x27;count&#x27; objects of size &#x27;size&#x27; */</span><br><span class="hljs-number">6.</span>	  p = mem_malloc(count * size);<br><span class="hljs-number">7.</span>	  <span class="hljs-keyword">if</span> (p) &#123;<br><span class="hljs-number">8.</span>	    <span class="hljs-comment">/* zero the memory */</span><br><span class="hljs-number">9.</span>	    <span class="hljs-built_in">memset</span>(p, <span class="hljs-number">0</span>, count * size);<br><span class="hljs-number">10.</span>	  &#125;<br><span class="hljs-number">11.</span>	  <span class="hljs-keyword">return</span> p;<br><span class="hljs-number">12.</span>	&#125;<br></code></pre></td></tr></table></figure><p>其同样完成两个工作。</p><blockquote><ol><li>内存的分配</li><li>对分配的内存进行清0操作，<code>maybe</code> 这样的清0操作将使得数据更安全。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> mem_free</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mem_free free</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> mem_malloc</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mem_malloc malloc</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> mem_calloc</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mem_calloc calloc</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></blockquote><p>  这是使用 <code>c</code> 系统函数分配的声明和定义，这里我就不一一讲解了，读者可以自行在 <code>mem.h</code> 函数中查找，这也就是模块化编程的最大优点，模块间相互区里，耦合性较低。关于 <code>mem</code> 内存堆的相关问题的分析就到这里，再见</p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" class="category-chain-item">网络协议</a> <span>></span> <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/LWIP/" class="category-chain-item">LWIP</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%8E%9F%E5%88%9B/">#原创</a> <a href="/tags/TCPIP/">#TCPIP</a> <a href="/tags/LWIP/">#LWIP</a> <a href="/tags/MEM/">#MEM</a></div></div><div class="license-box my-3"><div class="license-title"><div>LWIP之Mem原理</div><div>http://example.com/2018/09/24/linux/lwip/mem/220714/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>EtcFly</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2018年9月24日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2024年3月5日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/07/15/python/basedata/run/234405/" title="Python基础类型和运算符"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Python基础类型和运算符</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2018/09/24/linux/lwip/memp/220646/" title="LWIP之Memp原理"><span class="hidden-mobile">LWIP之Memp原理</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="waline"></div><script type="text/javascript">Fluid.utils.loadComments("#waline",(function(){Fluid.utils.createCssLink("https://lib.baomitu.com/waline/2.14.1/waline.min.css"),Fluid.utils.createScript("https://lib.baomitu.com/waline/2.14.1/waline.min.js",(function(){var i=Object.assign({serverURL:"https://etcfly.top:14000/",path:"window.location.pathname",meta:["nick","mail","link"],requiredMeta:["nick"],lang:"zh-CN",emoji:["https://unpkg.com/@waline/emojis@1.1.0/qq"],dark:'html[data-user-color-scheme="dark"]',wordLimit:0,pageSize:10},{el:"#waline",path:window.location.pathname});Waline.init(i),Fluid.utils.waitElementVisible("#waline .vcontent",()=>{var i="#waline .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://github.com/EtcFly" target="_blank" rel="nofollow noopener"><span>Copyright</span></a> <i class="iconfont icon-copyright"></i> <a href="https://etcfly.top:14100/share/yqTLFDlP/%E4%BB%97%E5%89%91%E8%B5%B0%E5%A4%A9%E6%B6%AF" target="_blank" rel="nofollow noopener"><span>2018-2024 EtcFly</span></a><div style="font-size:.85rem"><span>总访问量 <span style="color:#000" id="PVstatic">0</span> 次&nbsp</span> <span>总访客数 <span style="color:#000" id="UVstatic">0</span> 人&nbsp</span> <span>当前在线 <span style="color:#000" id="ACTstatic">0</span> 人&nbsp</span><script src="https://etcfly.top:14200/statistics" defer></script></div><div style="font-size:.85rem"><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="js/duration.js"></script></div></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener"></a> </span><span><a href="http://beian.miit.gov.cn/2023000858" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" alt="police-icon"> <span>浙ICP备2023000858号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/jquery.min.js"></script><script src="/live2d-widget/autoload.js"></script><script src="/js/star.js"></script><script src="/js/ribbon.min.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>