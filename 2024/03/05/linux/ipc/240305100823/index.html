<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="EtcFly"><meta name="keywords" content=""><meta name="description" content="版权归作者所有, 转载请保留该部分声明。本文作者：EtcFly原文地址：https:&#x2F;&#x2F;etcfly.top              2.5. Socket   以上几种同步机制都是同一主机内的进程通讯, 为了实现不同主机之间的进程通信, 引入socket套接字通信机制, socket套接字分为几种, 其中AF_UNIX可以实现同一主机内的进程高效通信, 后序将详细讲解"><meta property="og:type" content="article"><meta property="og:title" content="linux进程通信-socket"><meta property="og:url" content="http://example.com/2024/03/05/linux/ipc/240305100823/"><meta property="og:site_name" content="仗剑走天涯"><meta property="og:description" content="版权归作者所有, 转载请保留该部分声明。本文作者：EtcFly原文地址：https:&#x2F;&#x2F;etcfly.top              2.5. Socket   以上几种同步机制都是同一主机内的进程通讯, 为了实现不同主机之间的进程通信, 引入socket套接字通信机制, socket套接字分为几种, 其中AF_UNIX可以实现同一主机内的进程高效通信, 后序将详细讲解"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/linux.png"><meta property="article:published_time" content="2024-03-05T10:08:23.000Z"><meta property="article:modified_time" content="2024-03-05T03:41:03.000Z"><meta property="article:author" content="EtcFly"><meta property="article:tag" content="原创"><meta property="article:tag" content="ipc"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/img/linux.png"><title>linux进程通信-socket 仗剑走天涯</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/fluid-extention.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:4},web_analytics:{enable:!0,follow_dnt:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"3AEufnWAJdp8cFODp1DXvrQU-MdYXbMMI",app_key:"mGJiL6xVvYv21ygqfynJoCyO",server_url:null,path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Strive For Dream</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="linux进程通信-socket"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-03-05 10:08" pubdate>2024年3月5日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 26k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 216 分钟 </span><span id="vvdpost_container_page_pvuv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="vvdpost_value_page_pv">0</span> 次&nbsp&nbsp <i class="iconfont icon-users" aria-hidden="true"></i> <span id="vvdpost_value_page_uv">0</span> 人</span><script>console.log(window.location.pathname);var httpRequest=new XMLHttpRequest;httpRequest.open("POST","https://etcfly.top:14200/poststats",!0),httpRequest.setRequestHeader("Content-type","application/json"),httpRequest.send(JSON.stringify(window.location.pathname)),httpRequest.onreadystatechange=function(){if(4==httpRequest.readyState&&200==httpRequest.status){var e=httpRequest.responseText,t=JSON.parse(e);console.log(t.pv);var o=document.querySelector("#vvdpost_container_page_pvuv");if(console.log(o),o){var n=document.querySelector("#vvdpost_value_page_pv");console.log(n);var s=document.querySelector("#vvdpost_value_page_uv");console.log(s),s&&s&&(n.innerText=t.pv,s.innerText=t.uv,o.style.display="inline")}}}</script></div></div></div></div></div></div><script async src="https://etcfly.top:14100/script.js" data-website-id="1a5c096d-21e5-4556-99b0-28c810c9c868"></script></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">linux进程通信-socket</h1><p class="note note-info">本文最后更新于：2024年3月5日 凌晨</p><div class="markdown-body"><div class="note note-success"><p>版权归作者所有, 转载请保留该部分声明。<br>本文作者：EtcFly<br>原文地址：<a target="_blank" rel="noopener" href="https://etcfly.top">https://etcfly.top</a></p></div><hr><h3 id="25-socket"><a class="markdownIt-Anchor" href="#25-socket"></a> 2.5. Socket</h3><p>  以上几种同步机制都是同一主机内的进程通讯, 为了实现不同主机之间的进程通信, 引入<code>socket</code>套接字通信机制, <code>socket</code>套接字分为几种, 其中<code>AF_UNIX</code>可以实现同一主机内的进程高效通信, 后序将详细讲解, 这里首先从基础的<code>socket</code>套接字概念开始。</p><p>  在<code>unix</code>系统中, 存在很多的网络协议, 如以太网, 令牌环网, 红外, 蓝牙等等, 这些协议往往存在差异, 如果每一种协议都需要对应用提供一套编程接口, 那么应用开发人员需要熟悉每一套接口, 这将大大增加开发人员的负担。 为了解决这个问题, <code>unix/linux</code>开发者引入了<code>socket</code>抽象层, 屏蔽了底层协议细节, 开发人员只需要熟悉一套编程接口即可完成相关协议的操作, 而对于协议开发者而言, 如果需要新增一种协议支持, 也只需要向<code>socket</code>抽象层注册相关协议接口即可(<code>sock_register/sock_unregister</code>)。</p><p><strong>分层图</strong></p><p><img src="/2024/03/05/linux/ipc/240305100823/socket%E5%88%86%E5%B1%82%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="socket分层图.png"></p><p>如上图, 在<code>Unix/Linux</code>系统中，<code>Socket</code>的实现分为三层，第一层是 <code>GLIBC</code> 接口层, 提供同一的用户访问接口，第二层是 <code>BSD</code> 接口层, 在<code>kernel</code>中<code>socket</code>中实现, 主要实现一个统一的协议接入框架, 支持协议注册扩展，第三层是 具体的协议层（如<code>Unix socket</code>、<code>inet socket</code>、<code>inet6 socket</code>等）。</p><p><img src="/2024/03/05/linux/ipc/240305100823/socket%E8%B0%83%E7%94%A8%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="socket调用图.png"></p><p>根据不同的协议, <code>inet socket</code>层是不同的, 不同协议通过<code>socket</code>层提供的注册接口进行添加和删除, 具体结构如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proto_ops</span> &#123;</span><br>	<span class="hljs-type">int</span>		family;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span>	*<span class="hljs-title">owner</span>;</span><br>	<span class="hljs-type">int</span>		(*release)   (<span class="hljs-keyword">struct</span> socket *sock);<br>	<span class="hljs-type">int</span>		(*bind)	     (<span class="hljs-keyword">struct</span> socket *sock,<br>				      <span class="hljs-keyword">struct</span> sockaddr *myaddr,<br>				      <span class="hljs-type">int</span> sockaddr_len);<br>	<span class="hljs-type">int</span>		(*connect)   (<span class="hljs-keyword">struct</span> socket *sock,<br>				      <span class="hljs-keyword">struct</span> sockaddr *vaddr,<br>				      <span class="hljs-type">int</span> sockaddr_len, <span class="hljs-type">int</span> flags);<br>	<span class="hljs-type">int</span>		(*socketpair)(<span class="hljs-keyword">struct</span> socket *sock1,<br>				      <span class="hljs-keyword">struct</span> socket *sock2);<br>	<span class="hljs-type">int</span>		(*accept)    (<span class="hljs-keyword">struct</span> socket *sock,<br>				      <span class="hljs-keyword">struct</span> socket *newsock, <span class="hljs-type">int</span> flags);<br>	<span class="hljs-type">int</span>		(*getname)   (<span class="hljs-keyword">struct</span> socket *sock,<br>				      <span class="hljs-keyword">struct</span> sockaddr *addr,<br>				      <span class="hljs-type">int</span> *sockaddr_len, <span class="hljs-type">int</span> peer);<br>	<span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span>	<span class="hljs-params">(*poll)</span>	     <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-keyword">struct</span> socket *sock,</span><br><span class="hljs-params">				      <span class="hljs-keyword">struct</span> poll_table_struct *wait)</span>;<br>	<span class="hljs-type">int</span>		(*ioctl)     (<span class="hljs-keyword">struct</span> socket *sock, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd,<br>				      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg);<br>	<span class="hljs-type">int</span>	 	(*compat_ioctl) (<span class="hljs-keyword">struct</span> socket *sock, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd,<br>				      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg);<br>	<span class="hljs-type">int</span>		(*listen)    (<span class="hljs-keyword">struct</span> socket *sock, <span class="hljs-type">int</span> len);<br>	<span class="hljs-type">int</span>		(*shutdown)  (<span class="hljs-keyword">struct</span> socket *sock, <span class="hljs-type">int</span> flags);<br>	<span class="hljs-type">int</span>		(*setsockopt)(<span class="hljs-keyword">struct</span> socket *sock, <span class="hljs-type">int</span> level,<br>				      <span class="hljs-type">int</span> optname, <span class="hljs-type">char</span> __user *optval, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> optlen);<br>	<span class="hljs-type">int</span>		(*getsockopt)(<span class="hljs-keyword">struct</span> socket *sock, <span class="hljs-type">int</span> level,<br>				      <span class="hljs-type">int</span> optname, <span class="hljs-type">char</span> __user *optval, <span class="hljs-type">int</span> __user *optlen);<br>	<span class="hljs-type">int</span>		(*compat_setsockopt)(<span class="hljs-keyword">struct</span> socket *sock, <span class="hljs-type">int</span> level,<br>				      <span class="hljs-type">int</span> optname, <span class="hljs-type">char</span> __user *optval, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> optlen);<br>	<span class="hljs-type">int</span>		(*compat_getsockopt)(<span class="hljs-keyword">struct</span> socket *sock, <span class="hljs-type">int</span> level,<br>				      <span class="hljs-type">int</span> optname, <span class="hljs-type">char</span> __user *optval, <span class="hljs-type">int</span> __user *optlen);<br>	<span class="hljs-type">int</span>		(*sendmsg)   (<span class="hljs-keyword">struct</span> kiocb *iocb, <span class="hljs-keyword">struct</span> socket *sock,<br>				      <span class="hljs-keyword">struct</span> msghdr *m, <span class="hljs-type">size_t</span> total_len);<br>	<span class="hljs-type">int</span>		(*recvmsg)   (<span class="hljs-keyword">struct</span> kiocb *iocb, <span class="hljs-keyword">struct</span> socket *sock,<br>				      <span class="hljs-keyword">struct</span> msghdr *m, <span class="hljs-type">size_t</span> total_len,<br>				      <span class="hljs-type">int</span> flags);<br>	<span class="hljs-type">int</span>		(*mmap)	     (<span class="hljs-keyword">struct</span> file *file, <span class="hljs-keyword">struct</span> socket *sock,<br>				      <span class="hljs-keyword">struct</span> vm_area_struct * vma);<br>	<span class="hljs-type">ssize_t</span>		(*sendpage)  (<span class="hljs-keyword">struct</span> socket *sock, <span class="hljs-keyword">struct</span> page *page,<br>				      <span class="hljs-type">int</span> offset, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> flags);<br>	<span class="hljs-type">ssize_t</span> 	(*splice_read)(<span class="hljs-keyword">struct</span> socket *sock,  <span class="hljs-type">loff_t</span> *ppos,<br>				       <span class="hljs-keyword">struct</span> pipe_inode_info *pipe, <span class="hljs-type">size_t</span> len, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags);<br>&#125;;<br></code></pre></td></tr></table></figure><p>如下是<code>af_inet</code>注册信息:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proto_ops</span> <span class="hljs-title">inet_stream_ops</span> =</span> &#123;<br>	.family		   = PF_INET,<br>	.owner		   = THIS_MODULE,<br>	.release	   = inet_release,<br>	.bind		   = inet_bind,<br>	.connect	   = inet_stream_connect,<br>	.socketpair	   = sock_no_socketpair,<br>	.accept		   = inet_accept,<br>	.getname	   = inet_getname,<br>	.poll		   = tcp_poll,<br>	.ioctl		   = inet_ioctl,<br>	.listen		   = inet_listen,<br>	.shutdown	   = inet_shutdown,<br>	.setsockopt	   = sock_common_setsockopt,<br>	.getsockopt	   = sock_common_getsockopt,<br>	.sendmsg	   = tcp_sendmsg,<br>	.recvmsg	   = sock_common_recvmsg,<br>	.mmap		   = sock_no_mmap,<br>	.sendpage	   = tcp_sendpage,<br>	.splice_read	   = tcp_splice_read,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><br>	.compat_setsockopt = compat_sock_common_setsockopt,<br>	.compat_getsockopt = compat_sock_common_getsockopt,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proto_ops</span> <span class="hljs-title">inet_dgram_ops</span> =</span> &#123;<br>	.family		   = PF_INET,<br>	.owner		   = THIS_MODULE,<br>	.release	   = inet_release,<br>	.bind		   = inet_bind,<br>	.connect	   = inet_dgram_connect,<br>	.socketpair	   = sock_no_socketpair,<br>	.accept		   = sock_no_accept,<br>	.getname	   = inet_getname,<br>	.poll		   = udp_poll,<br>	.ioctl		   = inet_ioctl,<br>	.listen		   = sock_no_listen,<br>	.shutdown	   = inet_shutdown,<br>	.setsockopt	   = sock_common_setsockopt,<br>	.getsockopt	   = sock_common_getsockopt,<br>	.sendmsg	   = inet_sendmsg,<br>	.recvmsg	   = sock_common_recvmsg,<br>	.mmap		   = sock_no_mmap,<br>	.sendpage	   = inet_sendpage,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><br>	.compat_setsockopt = compat_sock_common_setsockopt,<br>	.compat_getsockopt = compat_sock_common_getsockopt,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><p>以上关于协议注册以及管理后序在对源码进行分析, 这里主要针对基础知识和概念进行讲解, 接下来我们主要针对<code>glibc</code>层系统接口进行讲解和测试。</p><hr><p>  通常来说, <code>unix/linux</code>网络编程相关的接口可以分为几类:</p><ul><li>网络字节序转换接口(<code>inet_pton</code>, <code>inet_ntop</code>, <code>htons</code>, <code>ntohs</code>等)</li><li>网络服务转换和查询相关接口(<code>getaddrinfo</code>, <code>getnameinfo</code>, <code>gethostname</code>, <code>getservent</code>, <code>getservbyname</code>等)</li><li>通用<code>socket</code>接口(<code>bind</code>, <code>connect</code>, <code>send</code>, <code>getpeername</code>, <code>getsockname</code>, <code>accept</code>, <code>recv</code>)等</li><li><code>socket</code>属性接口(<code>getsockopt</code>, <code>setsockopt</code>, <code>fcntl</code>)等</li></ul><p>所涉及头文件如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">arpa/:<br>    netdb.h: 系统网络db数据库相关服务<br>netinet/: internet相关头文件<br>    in.h: 网络字节序转换相关api头文件<br>net/: 网络链路相关头文件<br></code></pre></td></tr></table></figure><p>这些头文件分属不同的目录, 各目录也各不相同, 所以我们要了解这些目录的意义才能更好的理解各头文件, 避免代码编写过程中头文件胡乱包含。接下来将按照上述分类来分别对各类接口进行讲解。</p><hr><h4 id="251-网络字节序转换接口"><a class="markdownIt-Anchor" href="#251-网络字节序转换接口"></a> 2.5.1 网络字节序转换接口</h4><p>  字节序一般都是针对不同主机而言, 由于不同主机存在不同的大小端, 因此在进行协议通讯时会出现数据歧义, 因此引入字节序的概念，而在<code>tcp/ip</code>协议中规定采用大端格式作为网络字节序通信。</p><p><code>linux</code>中引入如下字节序转换接口:</p><table><thead><tr><th style="text-align:left">接口名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>htons</code></td><td style="text-align:left">主机字节序(<code>host</code>)转为网络字节序(<code>network</code>), 转换字节为<code>short</code></td></tr><tr><td style="text-align:left"><code>ntohs</code></td><td style="text-align:left">网络字节序(<code>network</code>)转为主机字节序(<code>host</code>), 转换字节为<code>short</code></td></tr><tr><td style="text-align:left"><code>htonl</code></td><td style="text-align:left">主机字节序(<code>host</code>)转为网络字节序(<code>network</code>), 转换字节为<code>long</code></td></tr><tr><td style="text-align:left"><code>ntohl</code></td><td style="text-align:left">网络字节序(<code>network</code>)转为主机字节序(<code>host</code>), 转换字节为<code>long</code></td></tr></tbody></table><p>对于一些情况下, 可能还需要将网络地址转换为对应的字符型来进行显示或者反之, 可以采用如下接口:</p><table><thead><tr><th style="text-align:left">接口名</th><th style="text-align:left">描述</th><th style="text-align:center">支持协议</th><th style="text-align:center">是否可正确处理<code>255.255.255.255</code>地址</th><th style="text-align:center">是否过时</th></tr></thead><tbody><tr><td style="text-align:left"><code>inet_addr</code></td><td style="text-align:left">将点分十进制的地址字符串转换为字节的主机地址</td><td style="text-align:center"><code>ipv4</code></td><td style="text-align:center">否</td><td style="text-align:center">是</td></tr><tr><td style="text-align:left"><code>inet_network</code></td><td style="text-align:left">将点分十进制的地址字符串转换为字节的网络地址</td><td style="text-align:center"><code>ipv4</code></td><td style="text-align:center">否</td><td style="text-align:center">是</td></tr><tr><td style="text-align:left"><code>inet_aton</code></td><td style="text-align:left">将点分十进制地址字符串转换为字节的网络地址, 但是支持<code>a.b.c.d</code>,<code>a.b.c</code>,<code>a.b</code>,<code>a</code>等字符串格式</td><td style="text-align:center"><code>ipv4</code></td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td style="text-align:left"><code>inet_ntoa</code></td><td style="text-align:left">将字节的网络地址转换为点分十进制的字符串</td><td style="text-align:center"><code>ipv4</code></td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td style="text-align:left"><code>inet_pton</code></td><td style="text-align:left">将点分十进制的地址字符串转换为字节的网络地址,</td><td style="text-align:center"><code>ipv4/ipv6</code></td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:left"><code>inet_ntop</code></td><td style="text-align:left">将字节的网络地址转换为字节的主机地址,</td><td style="text-align:center"><code>ipv4/ipv6</code></td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr></tbody></table><h4 id="252-网络服务转换和查询相关接口"><a class="markdownIt-Anchor" href="#252-网络服务转换和查询相关接口"></a> 2.5.2 网络服务转换和查询相关接口</h4><p>  网络查询相关的接口用于查询系统网络<code>db</code>数据库相关服务, 提供域名到<code>ip</code>, 端口号到服务， 协议到端口等转换服务或者相反的服务查询, 一般系统<code>db</code>数据库查询文件包括:</p><ul><li><code>/etc/protocols</code>： 描述网络协议名和协议号对应关系(如<code>tcp</code>是<code>6</code>)</li><li><code>/etc/services</code>: 描述网络服务和端口号以及所使用协议的对应关系(如<code>ssh</code>是<code>22</code>端口, 使用<code>tcp</code>)</li><li><code>/etc/hosts</code>: 描述本地主机名和<code>ip</code>的静态映射关系</li><li><code>/etc/networks</code>：描述网络名称和网络地址的对应关系(作用是允许系统管理员定义和命名不同的网络，并将这些网络与其对应的<code>IP</code>地址关联起来。这对于管理复杂网络配置时很有用)</li></ul><p>为了方便这些对应关系的查询, 系统为这些网络<code>db</code>数据库提供了查询接口, 其中带<code>r</code>表示接口可重入版本, 如下:<br><img src="/2024/03/05/linux/ipc/240305100823/socket%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E8%BD%AC%E6%8D%A2%E6%8E%A5%E5%8F%A3%E8%A7%86%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="socket网络服务转换接口视图.png"></p><p>这些函数里面<code>setXXXent</code>和<code>endXXXent</code>用于打开和关闭对应的主机数据库, 以便可以通过<code>getXXXent</code>遍历主机数据库, 该接口一次调用返回一条记录。</p><hr><h5 id="2521-hostent"><a class="markdownIt-Anchor" href="#2521-hostent"></a> 2.5.2.1 hostent</h5><p>首先我们定义一个<code>struct hostent</code>结构的打印信息方便查看结果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">print_hostent</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> hostent *ent)</span> <br>&#123;<br>	<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name:%s len:%d\n&quot;</span>, ent-&gt;h_name, ent-&gt;h_length);<br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; ent-&gt;h_addr_list[i] != <span class="hljs-literal">NULL</span>; i++) &#123;<br>		<span class="hljs-type">char</span> buf[INET_ADDRSTRLEN];<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;addr:%s\n&quot;</span>, inet_ntop(ent-&gt;h_addrtype, ent-&gt;h_addr_list[i], buf, <span class="hljs-keyword">sizeof</span>(buf)));<br>	&#125;<br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; ent-&gt;h_aliases[i] != <span class="hljs-literal">NULL</span>; i++) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;alias: %s\n&quot;</span>, ent-&gt;h_aliases[<span class="hljs-number">0</span>]);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>gethostent</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hostent</span> *<span class="hljs-title">ent</span>;</span><br>	sethostent(<span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">while</span> ((ent=gethostent()) != <span class="hljs-literal">NULL</span>) &#123;<br>		print_hostent(ent);<br>	&#125;<br>	endhostent();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>gethostbyname</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hostent</span> *<span class="hljs-title">h</span> =</span> gethostbyname(<span class="hljs-string">&quot;etcfly.top&quot;</span>);<br><span class="hljs-keyword">if</span> (h != <span class="hljs-literal">NULL</span>) &#123;<br>	print_hostent(h);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>gethostbyaddr</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">in_addr_t</span> addr = inet_network(<span class="hljs-string">&quot;47.174.205.116&quot;</span>);<br>h = gethostbyaddr(&amp;addr, <span class="hljs-keyword">sizeof</span>(addr), AF_INET);<br><span class="hljs-keyword">if</span> (h != <span class="hljs-literal">NULL</span>) &#123;<br>	print_hostent(h);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>	herror(<span class="hljs-string">&quot;by addr&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>gethostent_r</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hostent</span> *<span class="hljs-title">ent</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hostent</span> <span class="hljs-title">res</span>;</span><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br><span class="hljs-type">int</span> errcode = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>ent = <span class="hljs-literal">NULL</span>;<br><br>sethostent(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">while</span> ((ret=gethostent_r(&amp;res, buf, <span class="hljs-keyword">sizeof</span>(buf), &amp;ent, &amp;errcode)) == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (ent != <span class="hljs-literal">NULL</span>) &#123;<br>        print_hostent(ent);<br>    &#125;<br>&#125;<br>endhostent();<br></code></pre></td></tr></table></figure><ul><li><code>gethostbyaddr_r | gethostbyname_r</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hostent</span> *<span class="hljs-title">ent</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hostent</span> <span class="hljs-title">res</span>;</span><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br><span class="hljs-type">int</span> errcode = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>ent = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">inaddr</span>;</span><br>inaddr.s_addr = inet_addr(<span class="hljs-string">&quot;116.205.174.47&quot;</span>);<br>ent = <span class="hljs-literal">NULL</span>;<br>ret = gethostbyaddr_r(&amp;inaddr, <span class="hljs-keyword">sizeof</span>(inaddr), AF_INET, &amp;res, buf, <span class="hljs-keyword">sizeof</span>(buf), &amp;ent, &amp;errcode);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span> &amp;&amp; ent != <span class="hljs-literal">NULL</span>) &#123;<br>	print_hostent(ent);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>	herror(<span class="hljs-string">&quot;error:&quot;</span>);<br>&#125;<br><br>ret = gethostbyname_r(<span class="hljs-string">&quot;etcfly.top&quot;</span>, &amp;res, buf, <span class="hljs-keyword">sizeof</span>(buf), &amp;ent, &amp;errcode);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span> &amp;&amp; ent != <span class="hljs-literal">NULL</span>) &#123;<br>	print_hostent(ent);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>	herror(<span class="hljs-string">&quot;error:&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="2522-netent"><a class="markdownIt-Anchor" href="#2522-netent"></a> 2.5.2.2 netent</h5><p>  首先定义如下函数用于测试过程中数据打印显示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">print_netent</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> netent *ent)</span><br>&#123;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name:%s addr_type:%x\r\n&quot;</span>, ent-&gt;n_name, ent-&gt;n_addrtype);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;netNumber:%X\r\n&quot;</span>, ent-&gt;n_net);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; ent-&gt;n_aliases[i] != <span class="hljs-literal">NULL</span>; i++) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;addr:%s\r\n&quot;</span>, ent-&gt;n_aliases[i]);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//! find database in /etc/networks</span><br>setnetent(<span class="hljs-number">0</span>);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">netent</span> *<span class="hljs-title">netent</span>;</span><br><span class="hljs-keyword">while</span> ((netent=getnetent()) != <span class="hljs-literal">NULL</span>) &#123;<br>	print_netent(netent);<br>&#125;<br>endnetent();<br><br>netent = getnetbyname(<span class="hljs-string">&quot;link-local&quot;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != netent) &#123;<br>	print_netent(netent);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>	herror(<span class="hljs-string">&quot;netname fail&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2523-protoent"><a class="markdownIt-Anchor" href="#2523-protoent"></a> 2.5.2.3 protoent</h5><p>  同样定义测试打印代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">print_protoent</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> protoent *ent)</span><br>&#123;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name:%s protol:%d\r\n&quot;</span>, ent-&gt;p_name, ent-&gt;p_proto);<br>	<span class="hljs-type">int</span> i;<br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; ent-&gt;p_aliases[i] != <span class="hljs-literal">NULL</span>; i++) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;alias:%s\r\n&quot;</span>, ent-&gt;p_aliases[i]);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">test_protocol</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-comment">//! find database in /etc/protocols</span><br>	setprotoent(<span class="hljs-number">0</span>);<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">protoent</span> *<span class="hljs-title">protoent</span>;</span><br>	<span class="hljs-keyword">while</span> ((protoent=getprotoent()) != <span class="hljs-literal">NULL</span>) &#123;<br>		print_protoent(protoent);<br>	&#125;<br>	endprotoent();<br><br>	protoent = getprotobyname(<span class="hljs-string">&quot;icmp&quot;</span>);<br>	<span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != protoent) &#123;<br>		print_protoent(protoent);<br>	&#125;<br>	protoent = getprotobynumber(<span class="hljs-number">6</span>);<br>	<span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != protoent) &#123;<br>		print_protoent(protoent);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2524-servent"><a class="markdownIt-Anchor" href="#2524-servent"></a> 2.5.2.4 servent</h5><p>  定义测试打印代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">print_servent</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> servent *ent)</span><br>&#123;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name: %s \r\n&quot;</span>, ent-&gt;s_name);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;port:%d protol:%s\r\n&quot;</span>, ntohs(ent-&gt;s_port), ent-&gt;s_proto);<br>	<span class="hljs-type">int</span> i;<br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; ent-&gt;s_aliases[i] != <span class="hljs-literal">NULL</span>; i++) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;alias:%s\r\n&quot;</span>, ent-&gt;s_aliases[i]);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">test_server</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-comment">//! find database in /etc/services</span><br>	setservent(<span class="hljs-number">0</span>);<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">servent</span> *<span class="hljs-title">servent</span>;</span><br>	<span class="hljs-keyword">while</span> ((servent=getservent()) != <span class="hljs-literal">NULL</span>) &#123;<br>		print_servent(servent);<br>	&#125;<br>	endservent();<br><br>	servent = getservbyname(<span class="hljs-string">&quot;ssh&quot;</span>, <span class="hljs-string">&quot;tcp&quot;</span>);<br>	<span class="hljs-keyword">if</span> (servent != <span class="hljs-literal">NULL</span>) &#123;<br>		print_servent(servent);<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		herror(<span class="hljs-string">&quot;get servernt fail&quot;</span>);<br>	&#125;<br>	servent = getservbyport(htons(<span class="hljs-number">22</span>), <span class="hljs-string">&quot;tcp&quot;</span>);<br>	<span class="hljs-keyword">if</span> (servent != <span class="hljs-literal">NULL</span>) &#123;<br>		print_servent(servent);<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		herror(<span class="hljs-string">&quot;get servernt fail&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="2525-getaddrinfo-getnameinfo"><a class="markdownIt-Anchor" href="#2525-getaddrinfo-getnameinfo"></a> 2.5.2.5 getaddrinfo | getnameinfo</h5><p>  以上介绍的服务转换相关接口基本都已经过时, 目前新的<code>posix</code>接口推荐使用<code>getaddrinfo</code>和<code>getnameinfo</code>来替代, 新的接口支持<code>ipv4</code>和<code>ipv6</code>, 并且支持可重入, 功能更加强大, 操作更加安全。</p><p><strong>原型:</strong></p><p><code>int getaddrinfo(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res);</code></p><ul><li><code>node</code>: 需要查询的主机名</li><li><code>service</code>: 需要查询的服务名</li><li><code>hints</code>: 查询过滤模版, 对查询结果进行过滤</li><li><code>res</code>: 返回的查询结果(链式结构返回别名等信息)</li></ul><p>说明:</p><blockquote><p><code>hint</code> 过滤模版可以基于协议类型, 协议族类型等进行过滤, 但是未使用的部分保持为0</p></blockquote><p><strong>测试代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">test_getaddinfo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span> *<span class="hljs-title">result</span> =</span> <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span> <span class="hljs-title">hint</span>;</span><br>	<span class="hljs-built_in">memset</span>(&amp;hint, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(hint));<br>	hint.ai_flags |= AI_PASSIVE | AI_NUMERICSERV | AI_CANONNAME ;<br>	hint.ai_family = AF_INET;<br>	hint.ai_protocol = IPPROTO_TCP;<br><br>	<span class="hljs-type">int</span> ret = getaddrinfo(<span class="hljs-string">&quot;etcfly.top&quot;</span>, <span class="hljs-literal">NULL</span>, &amp;hint, &amp;result);<br>	<span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error code:%s&quot;</span>, gai_strerror(ret));<br>		<span class="hljs-keyword">return</span> ;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == result) &#123;<br>		<span class="hljs-keyword">return</span> ;<br>	&#125;<br><br>	<span class="hljs-keyword">while</span> (result != <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> *<span class="hljs-title">addr</span> =</span> (<span class="hljs-keyword">struct</span> sockaddr_in *)result-&gt;ai_addr;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;aiflag:%d family:%s\r\n&quot;</span>, result-&gt;ai_flags, show_proto_family(result-&gt;ai_family));<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;socktype:%s aiprotocol:%s\r\n&quot;</span>, show_socktype(result-&gt;ai_socktype), \<br>														show_proto(result-&gt;ai_protocol));<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ai_canonname:%s\r\n&quot;</span>, result-&gt;ai_canonname);<br><br>		<span class="hljs-type">char</span> buff[<span class="hljs-keyword">sizeof</span> <span class="hljs-string">&quot;255.255.255.255.&quot;</span>];<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;addr:%s len:%d port:%d\r\n&quot;</span>, inet_ntop(addr-&gt;sin_family, &amp;addr-&gt;sin_addr, buff, <span class="hljs-keyword">sizeof</span>(buff)), result-&gt;ai_addrlen, ntohs(addr-&gt;sin_port));<br>		result = result-&gt;ai_next;<br>	&#125;<br>	freeaddrinfo(result);<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>getnameinfo</strong></p><p><strong>原型:</strong></p><p><code>int getnameinfo(const struct sockaddr *addr, socklen_t addrlen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, int flags);</code></p><ul><li><code>addr</code>: 需要查询的主机<code>ip</code>和端口</li><li><code>addrlen</code>: 主机地址长度</li><li><code>host</code>: <code>buffer</code>存储查询后的主机名</li><li><code>hostlen</code>: <code>host</code>缓存大小</li><li><code>serv</code>: 存储通过端口号查询的服务名</li><li><code>servlen</code>: <code>serv</code>缓存大小</li><li><code>flags</code> : 行为控制标志</li></ul><p><strong>注意</strong>:</p><blockquote><p><code>host</code>和<code>serv</code>不能同时为<code>NULL</code></p></blockquote><p><strong>测试用例2</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">test_getnameinfo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">addr</span>;</span><br>	<span class="hljs-built_in">memset</span>(&amp;addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(addr));<br>	inet_pton(AF_INET, <span class="hljs-string">&quot;116.205.174.47&quot;</span>, &amp;addr.sin_addr.s_addr);<br>	addr.sin_family = AF_INET;<br>	addr.sin_port = htons(<span class="hljs-number">23</span>);<br><br>	<span class="hljs-type">char</span> hostname[<span class="hljs-number">100</span>];<br>	<span class="hljs-type">char</span> servname[<span class="hljs-number">100</span>];<br>	<span class="hljs-type">int</span> flags = <span class="hljs-number">0</span>;<br><br>	flags |= NI_DGRAM;<br>	<span class="hljs-type">int</span> ret = getnameinfo((<span class="hljs-keyword">struct</span> sockaddr *)&amp;addr, <span class="hljs-keyword">sizeof</span>(addr), \<br>	hostname, <span class="hljs-keyword">sizeof</span>(hostname), servname, <span class="hljs-keyword">sizeof</span>(servname), flags);<br>	<span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;errcode:%s\r\n&quot;</span>, gai_strerror(ret));<br>		<span class="hljs-keyword">return</span> ;<br>	&#125;<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hostname:%s\r\n&quot;</span>, hostname);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;servname:%s\r\n&quot;</span>, servname);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><ol><li><code>herror</code> 函数 和 <code>gai_strerror</code> 以及<code>errno</code>的区别:<ul><li><code>herror</code> 函数用于由<code>DNS</code> 函数（如<code>gethostbyname</code> <code>gethostbyaddr</code>）产生的错误打印到标准错误流中。它会将<code>DNS</code> 函数的错误码（通常是<code>h_errno</code> 变量中的值）转换成相应的可读的错误消息，并输出到标准错误流中。</li><li><code>gai_strerror</code> 函数用于将<code>getaddrinfo</code>、<code>getnameinfo</code>等函数产生的错误码转换成对应的可读的错误消息。这些函数返回的错误码通常是在标准库中定义的特定的错误码，而不是像 <code>h_errno</code> 那样。</li><li><code>errno</code> 是一个全局变量，用于记录发生在<code>C</code>标准库函数调用中的错误。它通常用于标识系统函数调用失败的原因。</li></ul></li></ol><hr><h4 id="253-通用socket接口"><a class="markdownIt-Anchor" href="#253-通用socket接口"></a> 2.5.3 通用socket接口</h4><p>  通用<code>socket</code>接口有很多, 比如<code>bind</code>, <code>listen</code>, <code>accept</code>, <code>recv</code>, <code>send</code>等等, 这些接口实现了应用程序便捷访问各类协议栈的功能，在了解之前, 先来看一下整个接口的总览。</p><table><thead><tr><th style="text-align:left">接口名</th><th style="text-align:left">功能</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left"><code>socket</code></td><td style="text-align:left">创建一个套接字</td><td style="text-align:left">-</td></tr><tr><td style="text-align:left"><code>bind</code></td><td style="text-align:left">为套接字绑定一个地址</td><td style="text-align:left">-</td></tr><tr><td style="text-align:left"><code>listen</code></td><td style="text-align:left">设置套接字为监听状态并设置连接队列满时最大挂起连接数量</td><td style="text-align:left">仅针对<code>SOCK_STREAM</code>和<code>SOCK_SEQPACKET</code>类型</td></tr><tr><td style="text-align:left"><code>accept</code></td><td style="text-align:left">监听并接受连接的套接字请求</td><td style="text-align:left">-</td></tr><tr><td style="text-align:left"><code>connect</code></td><td style="text-align:left">连接指定地址套接字</td><td style="text-align:left">-</td></tr><tr><td style="text-align:left"><code>recv</code></td><td style="text-align:left">接受<code>socket</code>数据</td><td style="text-align:left">可用于<code>udp</code>, 但是无法辨认源地址</td></tr><tr><td style="text-align:left"><code>send</code></td><td style="text-align:left">发送<code>socket</code>数据</td><td style="text-align:left">-</td></tr><tr><td style="text-align:left"><code>recvfrom</code></td><td style="text-align:left">接受<code>socket</code>地址并返回发送端地址</td><td style="text-align:left">-</td></tr><tr><td style="text-align:left"><code>sendto</code></td><td style="text-align:left">发送<code>socket</code>数据到指定地址</td><td style="text-align:left">-</td></tr><tr><td style="text-align:left"><code>close</code></td><td style="text-align:left">关闭<code>socket</code></td><td style="text-align:left">-</td></tr><tr><td style="text-align:left"><code>getsockname</code></td><td style="text-align:left">返回当前套接字地址</td><td style="text-align:left">-</td></tr><tr><td style="text-align:left"><code>getpeername</code></td><td style="text-align:left">返回远端套接字地址</td><td style="text-align:left">-</td></tr><tr><td style="text-align:left"><code>sendmsg</code></td><td style="text-align:left">同时发送多个缓冲区数据</td><td style="text-align:left">好处是多个缓冲区数据发送仅一次系统调用, 效率高</td></tr><tr><td style="text-align:left"><code>recvmsg</code></td><td style="text-align:left">同时接受数据到多个缓冲区</td><td style="text-align:left">-</td></tr><tr><td style="text-align:left"><code>select</code></td><td style="text-align:left">捕获多个文件描述直到一个或多个<code>ready</code></td><td style="text-align:left">最大支持不超过<code>FD_SETSIZE</code>文件描述符(可被信号中断)</td></tr><tr><td style="text-align:left"><code>poll</code></td><td style="text-align:left">捕获多个文件描述符事件</td><td style="text-align:left">相比<code>slelect</code>效率更高, 同时没有<code>FD_SETSIZE</code>限制</td></tr></tbody></table><h5 id="2531-服务端和客户端实现"><a class="markdownIt-Anchor" href="#2531-服务端和客户端实现"></a> 2.5.3.1 服务端和客户端实现</h5><p>下面将分别实现<code>tcp</code>客户端、<code>tcp</code>服务端、<code>upd</code>客户端、<code>udp</code>服务端来说明通用接口的用法。</p><ul><li>tcp 客户端</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">tcp_client</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-type">int</span> ret;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server</span>;</span><br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;start tcp client ... \r\n&quot;</span>);<br><br>	<span class="hljs-type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);<br>	<span class="hljs-keyword">if</span> (sockfd &lt; <span class="hljs-number">0</span>) &#123;<br>		perror(<span class="hljs-string">&quot;socket create fail&quot;</span>);<br>		<span class="hljs-keyword">return</span> ;<br>	&#125;<br><br>	<span class="hljs-built_in">memset</span>(&amp;server, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(server));<br>	server.sin_family = AF_INET;<br>	server.sin_port = htons(<span class="hljs-number">9000</span>); <span class="hljs-comment">//server port</span><br>	inet_pton(AF_INET, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, &amp;server.sin_addr);<br><br>	<span class="hljs-comment">//for Reliable connection</span><br>	<span class="hljs-type">int</span> retryCnt = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span> (retryCnt &lt; <span class="hljs-number">5</span>) &#123;<br>		ret = connect(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;server, <span class="hljs-keyword">sizeof</span>(server));<br>		<span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>			perror(<span class="hljs-string">&quot;connect dst server fail&quot;</span>);<br>			sleep(retryCnt&lt;&lt;<span class="hljs-number">1</span>);<br>			<span class="hljs-keyword">continue</span>;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span> (retryCnt &gt;= <span class="hljs-number">5</span>) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connect fail too many, client to close\r\n&quot;</span>);<br>		close(sockfd);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	<span class="hljs-type">char</span> buff[<span class="hljs-number">512</span>];<br>	<span class="hljs-type">int</span> len, send_len;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>		len = <span class="hljs-built_in">snprintf</span>(buff, <span class="hljs-keyword">sizeof</span>(buff), <span class="hljs-string">&quot;this is a test, and client send message to server, index:%d\r\n&quot;</span>, i);<br>		buff[len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>		send_len = <span class="hljs-number">0</span>;<br><br>		<span class="hljs-keyword">while</span> (send_len &lt; len) &#123;<br>			<span class="hljs-type">int</span> tmp = send(sockfd, &amp;buff[send_len], len-send_len, <span class="hljs-number">0</span>);<br>			<span class="hljs-keyword">if</span> (tmp &lt; <span class="hljs-number">0</span>) &#123;<br>				perror(<span class="hljs-string">&quot;send message fail&quot;</span>);<br>				sleep(<span class="hljs-number">2</span>);<br>				<span class="hljs-keyword">continue</span>;<br>			&#125;<br><br>			send_len += tmp;<br>		&#125;<br>	&#125;<br><br>	close(sockfd);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>tcp 服务端</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">tcp_server</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SOCKET_LISTEN 5</span><br>	<span class="hljs-type">int</span> ret;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server</span>;</span><br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;start tcp server ... \r\n&quot;</span>);<br><br>	<span class="hljs-type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);<br>	<span class="hljs-keyword">if</span> (sockfd &lt; <span class="hljs-number">0</span>) &#123;<br>		perror(<span class="hljs-string">&quot;socket create fail&quot;</span>);<br>		<span class="hljs-keyword">return</span> ;<br>	&#125;<br><br>	<span class="hljs-built_in">memset</span>(&amp;server, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(server));<br>	server.sin_family = AF_INET;<br>	server.sin_port = htons(<span class="hljs-number">9000</span>); <span class="hljs-comment">//server port</span><br>	server.sin_addr.s_addr = INADDR_ANY;<br><br>	ret = bind(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;server, <span class="hljs-keyword">sizeof</span>(server));<br>	<span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>		perror(<span class="hljs-string">&quot;bind fail&quot;</span>);<br>		close(sockfd);<br>		<span class="hljs-keyword">return</span> ;<br>	&#125;<br><br>	ret = listen(sockfd, MAX_SOCKET_LISTEN);<br>	<span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>		perror(<span class="hljs-string">&quot;listen fail&quot;</span>);<br>		close(sockfd);<br>		<span class="hljs-keyword">return</span> ;<br>	&#125;<br><br>	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>		<span class="hljs-type">socklen_t</span> client_len = <span class="hljs-keyword">sizeof</span>(client);<br>		<span class="hljs-built_in">memset</span>(&amp;client, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(client));<br><br>		<span class="hljs-type">int</span> client_sockfd = accept(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client, &amp;client_len);<br>		<span class="hljs-keyword">if</span> (client_sockfd == <span class="hljs-number">-1</span>) &#123;<br>			perror(<span class="hljs-string">&quot;accept fail&quot;</span>);<br>			sleep(<span class="hljs-number">2</span>);<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br><br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv new connect, client %s port %d\r\n&quot;</span>, inet_ntoa(client.sin_addr), ntohs(client.sin_port));<br><br>		<span class="hljs-type">char</span> recv_buff[<span class="hljs-number">512</span>];<br>		<span class="hljs-comment">//recv client message and send it back</span><br>		<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>			<span class="hljs-type">int</span> len = recv(client_sockfd, recv_buff, <span class="hljs-keyword">sizeof</span>(recv_buff), <span class="hljs-number">0</span>);<br>			<span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">0</span>) &#123;<br>				perror(<span class="hljs-string">&quot;recv message err&quot;</span>);<br>				<span class="hljs-keyword">break</span>;<br>			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//remote client disconnect</span><br>				<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client %s port:%d disconnect\r\n&quot;</span>, inet_ntoa(client.sin_addr), ntohs(client.sin_port));<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br><br>			recv_buff[len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv len: %d data: %s&quot;</span>, len, recv_buff);<br>		&#125;<br>		close(client_sockfd);<br>	&#125;<br>	close(sockfd);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>udp 客户端</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">udp_client</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-type">int</span> ret;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server</span>;</span><br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;start udp client ... \r\n&quot;</span>);<br><br>	<span class="hljs-type">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);<br>	<span class="hljs-keyword">if</span> (sockfd &lt; <span class="hljs-number">0</span>) &#123;<br>		perror(<span class="hljs-string">&quot;socket create fail&quot;</span>);<br>		<span class="hljs-keyword">return</span> ;<br>	&#125;<br><br>	<span class="hljs-type">char</span> send_buff[<span class="hljs-number">512</span>];<br>	<span class="hljs-type">int</span> len, send_len;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serveraddr</span>;</span><br>	<span class="hljs-built_in">memset</span>(&amp;serveraddr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(serveraddr));<br>	serveraddr.sin_port = htons(<span class="hljs-number">9000</span>);<br>	serveraddr.sin_family = AF_INET;<br>	inet_pton(AF_INET, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, &amp;serveraddr.sin_addr);<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>		len = <span class="hljs-built_in">snprintf</span>(send_buff, <span class="hljs-keyword">sizeof</span>(send_buff), <span class="hljs-string">&quot;this is a udp test, index: %d\r\n&quot;</span>, i);<br>		send_buff[len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>		send_len = <span class="hljs-number">0</span>;<br><br>		<span class="hljs-keyword">while</span> (send_len &lt; len) &#123;<br>			<span class="hljs-type">int</span> tmp = sendto(sockfd, &amp;send_buff[send_len], len-send_len, <span class="hljs-number">0</span>, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;serveraddr, <span class="hljs-keyword">sizeof</span>(serveraddr));<br>			<span class="hljs-keyword">if</span> (tmp &lt; <span class="hljs-number">0</span>) &#123;<br>				perror(<span class="hljs-string">&quot;send message fail&quot;</span>);<br>				sleep(<span class="hljs-number">2</span>);<br>				<span class="hljs-keyword">continue</span>;<br>			&#125;<br><br>			send_len += tmp;<br>		&#125;<br>	&#125;<br>	close(sockfd);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>udp 服务端</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">udp_server</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-type">int</span> ret;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server</span>;</span><br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;start udp server ... \r\n&quot;</span>);<br><br>	<span class="hljs-type">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);<br>	<span class="hljs-keyword">if</span> (sockfd &lt; <span class="hljs-number">0</span>) &#123;<br>		perror(<span class="hljs-string">&quot;socket create fail&quot;</span>);<br>		<span class="hljs-keyword">return</span> ;<br>	&#125;<br><br>	<span class="hljs-built_in">memset</span>(&amp;server, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(server));<br>	server.sin_family = AF_INET;<br>	server.sin_port = htons(<span class="hljs-number">9000</span>); <span class="hljs-comment">//server port</span><br>	server.sin_addr.s_addr = INADDR_ANY;<br><br>	ret = bind(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;server, <span class="hljs-keyword">sizeof</span>(server));<br>	<span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>		perror(<span class="hljs-string">&quot;bind fail&quot;</span>);<br>		close(sockfd);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	<span class="hljs-type">char</span> recv_buff[<span class="hljs-number">512</span>];<br>	<span class="hljs-type">int</span> recv_len = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>	<span class="hljs-type">socklen_t</span> client_len = <span class="hljs-keyword">sizeof</span>(client);<br>	<span class="hljs-built_in">memset</span>(&amp;client, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(client));<br><br>	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>		recv_len = recvfrom(sockfd, recv_buff, <span class="hljs-keyword">sizeof</span>(recv_buff), <span class="hljs-number">0</span>, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client, &amp;client_len);<br>		<span class="hljs-keyword">if</span> (recv_len &lt; <span class="hljs-number">0</span>) &#123;<br>			perror(<span class="hljs-string">&quot;recv data fail&quot;</span>);<br>			sleep(<span class="hljs-number">2</span>);<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br><br>		recv_buff[recv_len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv %s port:%d len: %d data: %s&quot;</span>, inet_ntoa(client.sin_addr), ntohs(client.sin_port), recv_len, recv_buff);<br>	&#125;<br><br>	close(sockfd);<br>&#125;<br></code></pre></td></tr></table></figure><hr><ul><li>使用<code>sendmsg</code>和<code>recvmsg</code>接受</li></ul><h5 id="2532-select和poll用法"><a class="markdownIt-Anchor" href="#2532-select和poll用法"></a> 2.5.3.2 select和poll用法</h5><ol><li><code>select</code> 检测 <code>tcp connect</code></li></ol><blockquote><p>通常来说<code>connect</code>用于面向连接的套接字编程, 一般来说如果连接建立未完成之前<code>connect</code>接口将一直阻塞直到完成, 为了使用<code>select</code>实现连接检测的目的, 需要设置套接字接口为非阻塞状态, 并使用<code>select</code>来检测套接字是否可写。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> sockid = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);<br><span class="hljs-keyword">if</span> (sockid &lt; <span class="hljs-number">0</span>) &#123;<br>	perror(<span class="hljs-string">&quot;socket fail&quot;</span>);<br>	<span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server</span>;</span><br><span class="hljs-built_in">memset</span>(&amp;server, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(server));<br>server.sin_family = AF_INET;<br>server.sin_port = htons(<span class="hljs-number">9008</span>);<br>inet_aton(<span class="hljs-string">&quot;116.205.174.47&quot;</span>, &amp;server.sin_addr);<br><br><span class="hljs-type">int</span> flags = fcntl(sockid, F_GETFL);<br>flags |= O_NONBLOCK;<br>fcntl(sockid, F_SETFL, flags);<br><br><span class="hljs-type">int</span> ret = connect(sockid, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;server, <span class="hljs-keyword">sizeof</span>(server));<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span> &amp;&amp; errno != EINPROGRESS) &#123;<br>	perror(<span class="hljs-string">&quot;connect fail&quot;</span>);<br>	close(sockid);<br>	<span class="hljs-keyword">return</span> ;<br>&#125;<br><br>fd_set rset, wset, eset;<br><br>FD_ZERO(&amp;wset);<br>FD_ZERO(&amp;eset);<br>FD_ZERO(&amp;rset);<br><br>FD_SET(sockid, &amp;rset);<br>FD_SET(sockid, &amp;wset);<br>FD_SET(sockid, &amp;eset);<br><br>ret = select(sockid+<span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>, &amp;wset, &amp;eset, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>	close(sockid);<br>	<span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connect timeout \r\n&quot;</span>);<br>	close(sockid);<br>	<span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><code>select</code> 检测 <code>tcp accept</code> 连接</li></ol><blockquote><p><code>accept</code>用于接受一个客户端的连接请求并返回新的套接字, 当连接监听过程中通常会阻塞,</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">select_accept</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-type">int</span> sockid = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);<br>	<span class="hljs-keyword">if</span> (sockid &lt; <span class="hljs-number">0</span>) &#123;<br>		perror(<span class="hljs-string">&quot;sock fail&quot;</span>);<br>		<span class="hljs-keyword">return</span> ;<br>	&#125;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_addr</span>;</span><br>	<span class="hljs-built_in">memset</span>(&amp;server_addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(server_addr));<br>	server_addr.sin_family = AF_INET;<br>	server_addr.sin_port = htons(<span class="hljs-number">9008</span>);<br>	server_addr.sin_addr.s_addr = INADDR_ANY;<br><br>	<span class="hljs-type">int</span> ret = bind(sockid, (<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *)&amp;server_addr, <span class="hljs-keyword">sizeof</span>(server_addr));<br>	<span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>		perror(<span class="hljs-string">&quot;bind fail&quot;</span>);<br>		close(sockid);<br>		<span class="hljs-keyword">return</span> ;<br>	&#125;<br><br>	ret = listen(sockid, <span class="hljs-number">5</span>);<br>	<span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>		perror(<span class="hljs-string">&quot;listen fail&quot;</span>);<br>		close(sockid);<br>		<span class="hljs-keyword">return</span> ;<br>	&#125;<br><br>	fd_set rfds, efds;<br>again:<br>	FD_ZERO(&amp;rfds);<br>	FD_ZERO(&amp;efds);<br><br>	FD_SET(sockid, &amp;rfds);<br>	FD_SET(sockid, &amp;efds);<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">timeout</span> =</span> &#123;<br>		.tv_sec = <span class="hljs-number">5</span>,<br>		.tv_usec = <span class="hljs-number">0</span>,<br>	&#125;;<br><br>	ret = select(sockid+<span class="hljs-number">1</span>, &amp;rfds, <span class="hljs-literal">NULL</span>, &amp;efds, &amp;timeout);<br>	<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>		perror(<span class="hljs-string">&quot;select fail&quot;</span>);<br>		close(sockid);<br>		<span class="hljs-keyword">return</span> ;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123;<br>		perror(<span class="hljs-string">&quot;select timeout&quot;</span>);<br>		<span class="hljs-keyword">goto</span> again;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (FD_ISSET(sockid, &amp;efds) != <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;efds set\r\n&quot;</span>);<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (FD_ISSET(sockid, &amp;rfds) != <span class="hljs-number">0</span>) &#123;<br>		ret = accept(sockid, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>		<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>			perror(<span class="hljs-string">&quot;accept fail&quot;</span>);<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-type">const</span> <span class="hljs-type">char</span> *psend = <span class="hljs-string">&quot;this is a test&quot;</span>;<br>			send(ret, psend, <span class="hljs-built_in">strlen</span>(psend), <span class="hljs-number">0</span>);<br>			close(ret);<br>		&#125;<br>	&#125;<br>	close(sockid);<br>	<span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><code>select</code> 实现单线程多路 <code>tcp</code> 连接</li></ol><blockquote><p>通常由于<code>accept</code>是阻塞性进行处理新到来的连接, 因此通常一个线程只能处理一个<code>socket</code>连接, 可以使用<code>select</code>的技巧实现单线程来监听多路<code>socket</code>连接建立、接受、发送, 具体参考如下例子:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">tcp_server_select_muli</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SOCKET_LISTEN 5</span><br>	<span class="hljs-type">int</span> ret;<br>	<span class="hljs-type">int</span> flag;<br>	<span class="hljs-type">int</span> maxsockfd = <span class="hljs-number">0</span>;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcp_serv_manage</span> <span class="hljs-title">serv_ma</span>;</span><br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;start tcp select server ... \r\n&quot;</span>);<br><br>	<span class="hljs-type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);<br>	<span class="hljs-keyword">if</span> (sockfd &lt; <span class="hljs-number">0</span>) &#123;<br>		perror(<span class="hljs-string">&quot;socket create fail&quot;</span>);<br>		<span class="hljs-keyword">return</span> ;<br>	&#125;<br><br>	flag =<span class="hljs-number">1</span>;<br>	setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, <span class="hljs-keyword">sizeof</span>(flag)); <span class="hljs-comment">//set sockfd option</span><br><br>	<span class="hljs-built_in">memset</span>(&amp;server, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(server));<br>	server.sin_family = AF_INET;<br>	server.sin_port = htons(<span class="hljs-number">9000</span>); <span class="hljs-comment">//server port</span><br>	server.sin_addr.s_addr = INADDR_ANY;<br><br>	ret = bind(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;server, <span class="hljs-keyword">sizeof</span>(server));<br>	<span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>		perror(<span class="hljs-string">&quot;bind fail&quot;</span>);<br>		close(sockfd);<br>		<span class="hljs-keyword">return</span> ;<br>	&#125;<br><br>	ret = listen(sockfd, MAX_SOCKET_LISTEN);<br>	<span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>		perror(<span class="hljs-string">&quot;listen fail&quot;</span>);<br>		close(sockfd);<br>		<span class="hljs-keyword">return</span> ;<br>	&#125;<br><br>	init_tcp_client(&amp;serv_ma);<br>	serv_ma.servfd = sockfd;<br>	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>		fd_set rfds, efds;<br><br>		FD_ZERO(&amp;rfds);<br>		FD_ZERO(&amp;efds);<br>		maxsockfd = <span class="hljs-number">0</span>;<br><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; serv_ma.client_cnt; i++) &#123;<br>			FD_SET(serv_ma.clientfd[i], &amp;rfds);<br>			FD_SET(serv_ma.clientfd[i], &amp;efds);<br>			maxsockfd = maxsockfd &lt; serv_ma.clientfd[i] ? serv_ma.clientfd[i] : maxsockfd;<br>		&#125;<br>		FD_SET(serv_ma.servfd, &amp;rfds);<br>		FD_SET(serv_ma.servfd, &amp;efds);<br>		maxsockfd = maxsockfd &lt; serv_ma.servfd ? serv_ma.servfd : maxsockfd;<br><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">timeout</span> =</span> &#123;<br>			.tv_sec = <span class="hljs-number">5</span>,<br>			.tv_usec = <span class="hljs-number">0</span>,<br>		&#125;;<br>		ret = select(maxsockfd+<span class="hljs-number">1</span>, &amp;rfds, <span class="hljs-literal">NULL</span>, &amp;efds, &amp;timeout);<br>		<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>			perror(<span class="hljs-string">&quot;select fail&quot;</span>);<br>			sleep(<span class="hljs-number">2</span>);<br>			<span class="hljs-keyword">continue</span>;<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; serv_ma.client_cnt; i++) &#123;<br>			<span class="hljs-keyword">if</span> (FD_ISSET(serv_ma.clientfd[i], &amp;efds)) &#123;<br>				perror(<span class="hljs-string">&quot;client fd fail&quot;</span>);<br>				del_tcp_client(&amp;serv_ma, serv_ma.clientfd[i]);<br>				sleep(<span class="hljs-number">2</span>);<br>				<span class="hljs-keyword">continue</span>;<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-keyword">if</span> (FD_ISSET(serv_ma.servfd, &amp;efds)) &#123;<br>			perror(<span class="hljs-string">&quot;serv fd fail&quot;</span>);<br>			sleep(<span class="hljs-number">2</span>);<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br><br>		<span class="hljs-keyword">if</span> (FD_ISSET(serv_ma.servfd, &amp;rfds)) &#123;<br>			<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">clientAddr</span>;</span><br>			<span class="hljs-type">socklen_t</span> len = <span class="hljs-keyword">sizeof</span>(clientAddr);<br>			<span class="hljs-built_in">memset</span>(&amp;clientAddr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(clientAddr));<br>			<span class="hljs-type">int</span> newclient = accept(serv_ma.servfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;clientAddr, &amp;len);<br>			<span class="hljs-keyword">if</span> (newclient == <span class="hljs-number">-1</span>) &#123;<br>				perror(<span class="hljs-string">&quot;accept client fail&quot;</span>);<br>				sleep(<span class="hljs-number">2</span>);<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>			add_tcp_client(&amp;serv_ma, newclient);<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;new client connect %s:%d\r\n&quot;</span>, inet_ntoa(clientAddr.sin_addr), ntohs(clientAddr.sin_port));<br>		&#125;<br><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; serv_ma.client_cnt; i++) &#123;<br>			<span class="hljs-keyword">if</span> (FD_ISSET(serv_ma.clientfd[i], &amp;rfds)) &#123;<br>				<span class="hljs-type">char</span> buff[<span class="hljs-number">512</span>];<br>				<span class="hljs-type">int</span> len = recv(serv_ma.clientfd[i], buff, <span class="hljs-keyword">sizeof</span>(buff), <span class="hljs-number">0</span>);<br>				<span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">0</span>) &#123;<br>					perror(<span class="hljs-string">&quot;recv sockfd fail&quot;</span>);<br>					<span class="hljs-keyword">continue</span>;<br>				&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>					<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;diconnect client\r\n&quot;</span>);<br>					close(serv_ma.clientfd[i]);<br>					del_tcp_client(&amp;serv_ma, serv_ma.clientfd[i]);<br>					<span class="hljs-keyword">continue</span>;<br>				&#125;<br>				buff[len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>				send(serv_ma.clientfd[i], buff, len, <span class="hljs-number">0</span>);<br>			&#125;<br>		&#125;<br>	&#125;<br>	close(serv_ma.servfd);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li><code>poll</code> 的用法</li></ol><blockquote><p><code>poll</code>和<code>select</code>都可用于监听套接字, 但是<code>select</code>最大只支持监听<code>FD_SETSIZE</code>个文件句柄, 而<code>poll</code>则没有此限制, 其次<code>poll</code>在监听较多文件句柄时具有更好的性能, <code>select</code>属于较早在<code>BSD</code>系统中出现, 而<code>poll</code>首次则是在<code>System V Release 3</code>系统引入, 总的来说<code>poll</code>比<code>select</code>更加推荐。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">test_poll</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-type">int</span> sockid;<br>	sockid = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);<br>	<span class="hljs-keyword">if</span> (sockid &lt; <span class="hljs-number">0</span>) &#123;<br>		perror(<span class="hljs-string">&quot;sockid fail&quot;</span>);<br>		<span class="hljs-keyword">return</span> ;<br>	&#125;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_addr</span>;</span><br>	<span class="hljs-built_in">memset</span>(&amp;server_addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(server_addr));<br>	server_addr.sin_family = AF_INET;<br>	server_addr.sin_port = htons(<span class="hljs-number">9008</span>);<br>	inet_pton(AF_INET, <span class="hljs-string">&quot;116.205.174.47&quot;</span>, &amp;server_addr.sin_addr);<br><br>	<span class="hljs-type">int</span> ret = connect(sockid, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;server_addr, <span class="hljs-keyword">sizeof</span>(server_addr));<br>	<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>		perror(<span class="hljs-string">&quot;connect fail&quot;</span>);<br>		close(sockid);<br>		<span class="hljs-keyword">return</span> ;<br>	&#125;<br><br>	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">fds</span>;</span><br>		fds.fd = sockid;<br>		fds.events = POLLIN | POLLPRI | POLLERR;<br>		fds.revents = <span class="hljs-number">0</span>;<br>		ret = poll(&amp;fds, <span class="hljs-number">1</span>, <span class="hljs-number">5000</span>);<br>		<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>			perror(<span class="hljs-string">&quot;poll fail&quot;</span>);<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br><br>		<span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;timeout connect:%ld\r\n&quot;</span>, time(<span class="hljs-literal">NULL</span>));<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br><br>		<span class="hljs-keyword">if</span> (fds.revents &amp; POLLIN) &#123;<br>			<span class="hljs-type">char</span> buf[<span class="hljs-number">1000</span>];<br>			<span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(buf));<br>			<span class="hljs-type">int</span> len = recv(sockid, buf, <span class="hljs-keyword">sizeof</span>(buf), <span class="hljs-number">0</span>);<br>			<span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">0</span>) &#123;<br>				perror(<span class="hljs-string">&quot;recv fail\r\n&quot;</span>);<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br><br>			<span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>				<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;link disconnect\r\n&quot;</span>);<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;data recv len:%d %s&quot;</span>, len, buf);<br>		&#125;<br><br>		<span class="hljs-keyword">if</span> (fds.revents &amp; POLLERR) &#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;poll err\r\n&quot;</span>);<br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;poll:%d\r\n&quot;</span>, fds.revents);<br>	&#125;<br>	close(sockid);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="254-socket属性接口"><a class="markdownIt-Anchor" href="#254-socket属性接口"></a> 2.5.4 socket属性接口</h4><p>  有时候通用的<code>socket</code>无法达成特定的目的, 这时候我们还需要通过<code>socket</code>属性相关的接口来对协议栈进行细微参数的调整, 比如对于<code>tcpip</code>协议而言， 对于<code>telnet/ssh</code>类型的服务, 可能需要关闭默认的<code>nagle</code>算法, 对于服务端或者多网口设备, 可能需要允许端口和<code>ip</code>的重绑定等等。如下列举了常用的一些属性:</p><table><thead><tr><th style="text-align:left"><strong>level</strong></th><th style="text-align:left">属性名</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left"><code>SOL_SOCKET</code></td><td style="text-align:left"><code>SO_REUSEADDR</code></td><td style="text-align:left">允许在绑定套接字时重用处于 <code>TIME_WAIT</code> 状态的本地地址和端口</td></tr><tr><td style="text-align:left"><code>SOL_SOCKET</code></td><td style="text-align:left"><code>SO_REUSEPORT</code></td><td style="text-align:left">允许多个套接字绑定到相同的地址和端口, 从而实现负载均衡和并发处理。</td></tr><tr><td style="text-align:left"><code>SOL_SOCKET</code></td><td style="text-align:left"><code>SO_BROADCAST</code></td><td style="text-align:left">广播标志(对<code>datagram</code>套接字有效, <code>stream</code>套接字无效)</td></tr><tr><td style="text-align:left"><code>SOL_SOCKET</code></td><td style="text-align:left"><code>SO_SNDBUF</code></td><td style="text-align:left">设置发送缓冲区大小</td></tr><tr><td style="text-align:left"><code>SOL_SOCKET</code></td><td style="text-align:left"><code>SO_RCVBUF</code></td><td style="text-align:left">设置接受缓冲区大小</td></tr><tr><td style="text-align:left"><code>SOL_SOCKET</code></td><td style="text-align:left"><code>SO_RCVLOWAT</code></td><td style="text-align:left">设置接受水位, 仅当接受缓存中有大于最低水位的数据, <code>recv</code>才返回，否则阻塞等待。这个机制并不影响<code>select</code>和<code>poll</code>机制, 只要有一个字节接受, <code>select/poll</code>也会标记套接字为可读</td></tr><tr><td style="text-align:left"><code>SOL_SOCKET</code></td><td style="text-align:left"><code>SO_SNDLOWAT</code></td><td style="text-align:left"><code>linux</code>不可设置</td></tr><tr><td style="text-align:left"><code>SOL_SOCKET</code></td><td style="text-align:left"><code>SO_KEEPALIVE</code></td><td style="text-align:left">设置和获取系统是否保活状态</td></tr><tr><td style="text-align:left"><code>SOL_SOCKET</code></td><td style="text-align:left"><code>SO_RCVTIMEO</code></td><td style="text-align:left">设置套接字接受超时时间(超时返回-1)</td></tr><tr><td style="text-align:left"><code>SOL_SOCKET</code></td><td style="text-align:left"><code>SO_SNDTIMEO</code></td><td style="text-align:left">设置套接字发送超时时间</td></tr><tr><td style="text-align:left"><code>SOL_SOCKET</code></td><td style="text-align:left"><code>SO_ACCEPTCONN</code></td><td style="text-align:left">设置或获取套接字<code>listen</code>标志</td></tr><tr><td style="text-align:left"><code>SOL_TCP</code></td><td style="text-align:left"><code>TCP_NODELAY</code></td><td style="text-align:left">禁止<code>nagle</code>算法</td></tr><tr><td style="text-align:left"><code>SOL_TCP</code></td><td style="text-align:left"><code>TCP_MAXSEG</code></td><td style="text-align:left">设置协议栈最大段大小(<code>MSS</code>)</td></tr><tr><td style="text-align:left"><code>SOL_TCP</code></td><td style="text-align:left"><code>TCP_KEEPIDLE</code></td><td style="text-align:left">设置<code>tcp</code>的空闲时间(超过空闲时间将发送保活报文检测对端是否存活)</td></tr><tr><td style="text-align:left"><code>SOL_TCP</code></td><td style="text-align:left"><code>TCP_KEEPINTVL</code></td><td style="text-align:left">设置保活间隔</td></tr><tr><td style="text-align:left"><code>SOL_TCP</code></td><td style="text-align:left"><code>TCP_KEEPCNT</code></td><td style="text-align:left">设置保活重试次数</td></tr><tr><td style="text-align:left"><code>SOL_TCP</code></td><td style="text-align:left"><code>TCP_SYNCNT</code></td><td style="text-align:left">设置<code>tcp sync</code>次数</td></tr><tr><td style="text-align:left"><code>SOL_UDP</code></td><td style="text-align:left"><code>UDP_NO_CHECK6_TX</code></td><td style="text-align:left"><code>udp</code> <code>ipv6</code>发送不校验数据</td></tr><tr><td style="text-align:left"><code>SOL_UDP</code></td><td style="text-align:left"><code>UDP_NO_CHECK6_RX</code></td><td style="text-align:left"><code>udp</code> <code>ipv6</code>接受不校验数据</td></tr><tr><td style="text-align:left"><code>SOL_IP</code></td><td style="text-align:left"><code>IP_TOS</code></td><td style="text-align:left">设置<code>ip</code>服务质量</td></tr><tr><td style="text-align:left"><code>SOL_IP</code></td><td style="text-align:left"><code>IP_TTL</code></td><td style="text-align:left">设置<code>ip ttl</code></td></tr></tbody></table><p><strong>操作接口</strong></p><ul><li><p><code>int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);</code><br><strong>功能</strong>: 获取套接字通用属性<br><strong>参数</strong>:</p><ul><li><code>sockfd</code>: 套接字</li><li><code>level</code>: 协议<code>leval</code>(如<code>SOL_SOCKET</code>)</li><li><code>optname</code>: 返回的属性内容</li><li><code>optlen</code>: 返回的<code>optname</code>长度<br><strong>返回</strong>：-1： 获取失败 0: 成功</li></ul></li><li><p><code>int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);</code><br><strong>功能</strong>: 设置套接字通用属性<br><strong>参数</strong>:</p><ul><li><code>sockfd</code>: 套接字</li><li><code>level</code>: 协议<code>leval</code>(如<code>SOL_SOCKET</code>)</li><li><code>optname</code>: 设置的属性内容</li><li><code>optlen</code>: 设置的属性长度<br><strong>返回</strong>：-1： 设置失败 0: 成功</li></ul></li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Linux%E5%85%A5%E9%97%A8/" class="category-chain-item">Linux入门</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%8E%9F%E5%88%9B/">#原创</a> <a href="/tags/ipc/">#ipc</a></div></div><div class="license-box my-3"><div class="license-title"><div>linux进程通信-socket</div><div>http://example.com/2024/03/05/linux/ipc/240305100823/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>EtcFly</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年3月5日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2024年3月5日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2024/09/08/openwrt/wireguard/212900/" title="使用360t7刷openwrt系统"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">使用360t7刷openwrt系统</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/03/05/linux/ipc/240305100814/" title="linux进程通信-共享存储"><span class="hidden-mobile">linux进程通信-共享存储</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="waline"></div><script type="text/javascript">Fluid.utils.loadComments("#waline",(function(){Fluid.utils.createCssLink("https://lib.baomitu.com/waline/2.14.1/waline.min.css"),Fluid.utils.createScript("https://lib.baomitu.com/waline/2.14.1/waline.min.js",(function(){var i=Object.assign({serverURL:"https://etcfly.top:14000/",path:"window.location.pathname",meta:["nick","mail","link"],requiredMeta:["nick"],lang:"zh-CN",emoji:["https://unpkg.com/@waline/emojis@1.1.0/qq"],dark:'html[data-user-color-scheme="dark"]',wordLimit:0,pageSize:10},{el:"#waline",path:window.location.pathname});Waline.init(i),Fluid.utils.waitElementVisible("#waline .vcontent",()=>{var i="#waline .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://github.com/EtcFly" target="_blank" rel="nofollow noopener"><span>Copyright</span></a> <i class="iconfont icon-copyright"></i> <a href="https://etcfly.top:14100/share/yqTLFDlP/%E4%BB%97%E5%89%91%E8%B5%B0%E5%A4%A9%E6%B6%AF" target="_blank" rel="nofollow noopener"><span>2018-2024 EtcFly</span></a><div style="font-size:.85rem"><span>总访问量 <span style="color:#000" id="PVstatic">0</span> 次&nbsp</span> <span>总访客数 <span style="color:#000" id="UVstatic">0</span> 人&nbsp</span> <span>当前在线 <span style="color:#000" id="ACTstatic">0</span> 人&nbsp</span><script src="https://etcfly.top:14200/statistics" defer></script></div><div style="font-size:.85rem"><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="js/duration.js"></script></div></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener"></a> </span><span><a href="http://beian.miit.gov.cn/2023000858" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" alt="police-icon"> <span>浙ICP备2023000858号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/jquery.min.js"></script><script src="/live2d-widget/autoload.js"></script><script src="/js/star.js"></script><script src="/js/ribbon.min.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>