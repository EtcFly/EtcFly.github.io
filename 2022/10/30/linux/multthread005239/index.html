<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="EtcFly"><meta name="keywords" content=""><meta name="description" content="版权归作者所有, 转载请保留该部分声明。本文作者：EtcFly原文地址：https:&#x2F;&#x2F;etcfly.top              简介   进程是系统资源的最小的分配单元, 对于进程而言, 其拥有固定大小的虚拟空间, 因此进程只有一个栈,。对于线程而言, 其是系统最小的执行单元, 每一个线程都拥有自己完整的上下文, 因此，每一个线程具有自己的栈空间, 一个进程中,"><meta property="og:type" content="article"><meta property="og:title" content="linux多线程"><meta property="og:url" content="http://example.com/2022/10/30/linux/multthread005239/"><meta property="og:site_name" content="仗剑走天涯"><meta property="og:description" content="版权归作者所有, 转载请保留该部分声明。本文作者：EtcFly原文地址：https:&#x2F;&#x2F;etcfly.top              简介   进程是系统资源的最小的分配单元, 对于进程而言, 其拥有固定大小的虚拟空间, 因此进程只有一个栈,。对于线程而言, 其是系统最小的执行单元, 每一个线程都拥有自己完整的上下文, 因此，每一个线程具有自己的栈空间, 一个进程中,"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/linux.png"><meta property="article:published_time" content="2022-10-30T00:52:39.000Z"><meta property="article:modified_time" content="2024-03-05T03:41:03.000Z"><meta property="article:author" content="EtcFly"><meta property="article:tag" content="原创"><meta property="article:tag" content="linux"><meta property="article:tag" content="多线程"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/img/linux.png"><title>linux多线程 仗剑走天涯</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/fluid-extention.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:4},web_analytics:{enable:!0,follow_dnt:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"3AEufnWAJdp8cFODp1DXvrQU-MdYXbMMI",app_key:"mGJiL6xVvYv21ygqfynJoCyO",server_url:null,path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Strive For Dream</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="linux多线程"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-10-30 00:52" pubdate>2022年10月30日 凌晨</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 42k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 351 分钟 </span><span id="vvdpost_container_page_pvuv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="vvdpost_value_page_pv">0</span> 次&nbsp&nbsp <i class="iconfont icon-users" aria-hidden="true"></i> <span id="vvdpost_value_page_uv">0</span> 人</span><script>console.log(window.location.pathname);var httpRequest=new XMLHttpRequest;httpRequest.open("POST","https://etcfly.top:14200/poststats",!0),httpRequest.setRequestHeader("Content-type","application/json"),httpRequest.send(JSON.stringify(window.location.pathname)),httpRequest.onreadystatechange=function(){if(4==httpRequest.readyState&&200==httpRequest.status){var e=httpRequest.responseText,t=JSON.parse(e);console.log(t.pv);var o=document.querySelector("#vvdpost_container_page_pvuv");if(console.log(o),o){var n=document.querySelector("#vvdpost_value_page_pv");console.log(n);var s=document.querySelector("#vvdpost_value_page_uv");console.log(s),s&&s&&(n.innerText=t.pv,s.innerText=t.uv,o.style.display="inline")}}}</script></div></div></div></div></div></div><script async src="https://etcfly.top:14100/script.js" data-website-id="1a5c096d-21e5-4556-99b0-28c810c9c868"></script></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">linux多线程</h1><p class="note note-info">本文最后更新于：2024年3月5日 凌晨</p><div class="markdown-body"><div class="note note-success"><p>版权归作者所有, 转载请保留该部分声明。<br>本文作者：EtcFly<br>原文地址：<a target="_blank" rel="noopener" href="https://etcfly.top">https://etcfly.top</a></p></div><hr><h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3><p>  进程是系统资源的最小的分配单元, 对于进程而言, 其拥有固定大小的虚拟空间, 因此进程只有一个栈,。对于线程而言, 其是系统最小的执行单元, 每一个线程都拥有自己完整的上下文, 因此，每一个线程具有自己的栈空间, 一个进程中, 所有的线程共享系统进程的空间资源。同时，对于进程而言, 各进程资源是相互独立的, 如果进程进程之间的资源共享需要很多的信号同步, 这是比较麻烦的, 线程之间共享进程空间所有资源, 因此线程对于资源共享更加友好。</p><h4 id="进程和线程对比"><a class="markdownIt-Anchor" href="#进程和线程对比"></a> 进程和线程对比</h4><h5 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h5><p><strong>优点:</strong> 资源相互独立, 不会相互干扰<br><strong>缺点:</strong></p><ul><li>一个进程需要耗费更多的系统资源开销</li><li>多个进程之间进行资源共享比较繁琐, 需要大量的信号同步</li></ul><h5 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h5><p><strong>优点:</strong></p><ul><li>比较轻量, 系统资源占用少, 启动速度快</li><li>资源之间共享比较方便, 各线程之间共享进程资源。</li></ul><p><strong>缺点:</strong></p><ul><li>线程间共享系统资源, 会存在相互干扰(如相互的内存踩踏之类)</li></ul><hr><h3 id="线程创建"><a class="markdownIt-Anchor" href="#线程创建"></a> 线程创建</h3><table><thead><tr><th>进程原语</th><th>线程原语</th><th>描述</th></tr></thead><tbody><tr><td><code>fork</code></td><td><code>pthread_create</code></td><td>创建新的控制流</td></tr><tr><td><code>exit</code></td><td><code>pthread_exit</code></td><td>从现有控制流退出</td></tr><tr><td><code>waitpid</code></td><td><code>pthread_join</code></td><td>从控制流得到等待退出状态</td></tr><tr><td><code>atexit</code></td><td><code>pthread_cancel_push</code></td><td>注册在退出控制流时调用的函数</td></tr><tr><td><code>getpid</code></td><td><code>pthread_self</code></td><td>获取控制流的<code>ID</code></td></tr><tr><td><code>abort</code></td><td><code>pthread_cancel</code></td><td>请求控制流的非正常退出</td></tr></tbody></table><h4 id="线程创建接口"><a class="markdownIt-Anchor" href="#线程创建接口"></a> 线程创建接口</h4><p>  linux下线程作为最小得到执行单元, 可以以相对于进程快速、高效、占用资源小等优点被广泛使用，目前<code>linux</code>下<code>pthread</code>采用的是<code>glibc</code>的线程库, 内核部分并不包括线程相关实现, 想看线程实现的可以参考 <a target="_blank" rel="noopener" href="https://github.com/lattera/glibc">glibc</a>。<br>  另外, 进程启动的<code>main</code>属于主线程, 主线程中是不能直接<code>return</code>的, 这默认为进程结束, 所以假设主线程启动其他线程后需要退出, 需要使用线程退出接口<code>pthread_exit</code>, 但是该限制在非主线程并不存在。</p><p><strong>线程的创建有如下接口:</strong></p><table><thead><tr><th style="text-align:center">序号</th><th>接口名称</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td><code>pthread_create</code></td><td>线程创建</td></tr><tr><td style="text-align:center">2</td><td><code>pthread_exit</code></td><td>线程退出</td></tr><tr><td style="text-align:center">3</td><td><code>pthread_join</code></td><td>线程同步等待子线程状态</td></tr><tr><td style="text-align:center">4</td><td><code>pthread_detach</code></td><td>线程分离, 子线程资源由操作系统回收</td></tr><tr><td style="text-align:center">5</td><td><code>pthread_self</code></td><td>获取当前线程自身</td></tr><tr><td style="text-align:center">6</td><td><code>pthread_equal</code></td><td>线程比对</td></tr><tr><td style="text-align:center">7</td><td><code>pthread_cancel</code></td><td>线程退出信号</td></tr><tr><td style="text-align:center">8</td><td><code>pthread_cleanup_push</code></td><td>线程清理push</td></tr><tr><td style="text-align:center">9</td><td><code>pthread_cleanup_pop</code></td><td>线程清理弹出</td></tr></tbody></table><p>  使用线程库需要在编译时连接相关的线程库, 可加入编译选项<code>-lpthread</code>, 编码时包含相关的头文件<code>pthread.h</code>即可, 线程句柄定义为<code>pthread_t</code>, 其具体定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-type">pthread_t</span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>pthread_create</code>: 创建一个线程, 并提供一个回调进行执行</p><ul><li><strong>返回</strong>: 0表示创建成功 其他创建失败</li><li><strong>注意</strong>: 提供的线程体回调需要以<code>void *(*__start_routine) (void *)</code>函数原型提供。</li><li><strong>示例</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">old_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">pthread_t</span> *tid = (<span class="hljs-type">pthread_t</span> *)arg;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;old thread start! tid:%lX\r\n&quot;</span>, *tid);<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">pthread_t</span> tid1;<br><span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != pthread_create(&amp;tid1, <span class="hljs-literal">NULL</span>, old_thread, (<span class="hljs-type">void</span> *)&amp;tid1))<br>&#123;<br>    perror(<span class="hljs-string">&quot;can&#x27;t creat threda!&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_exit</code>： 主动退出一个线程</p><ul><li><strong>参数</strong>： 线程的退出代码, 非主线程也可以使用<code>return</code>, 是等价的</li><li><strong>返回</strong>: 0表示创建成功 其他创建失败</li><li><strong>示例</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">old_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">pthread_t</span> *tid = (<span class="hljs-type">pthread_t</span> *)arg;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;old thread start! tid:%lX\r\n&quot;</span>, *tid);<br>    pthread_exit((<span class="hljs-type">void</span> *)<span class="hljs-number">199</span>);<span class="hljs-comment">//等价return (void*)199;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_join</code>： 线程同步等待子线程状态</p><ul><li><p><strong>作用</strong>：</p><ul><li><p>当线程处于结合状态(还有一个分离状态), 可以调用该接口获取特定线程的退出状态, 该线程会阻塞等待线程, 直到被等待线程退出, 此时, 等待线程的线程(<code>pthread_join</code>调用线程)会被激活, 并释放被等待线程的栈空间, 获取退出状态等。如果在结合状态没有调用<code>pthread_join</code>直接退出, 会导致被等待线程栈泄漏, 无法回收。</p></li><li><p>当处于分离状态, 创建线程时无需等待被创建线程返回, 两个线程间分离, 被创建线程由系统接管，退出时由系统释放其栈资源。</p></li></ul></li><li><p><strong>返回</strong>: 0 表示正常 , 其他出错</p><ul><li>当在分离状态调用<code>pthread_join</code>系统会返回<code>EINVAL</code>的错误。</li></ul></li><li><p><strong>示例</strong>:</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-type">void</span> *ret;<br><span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != pthread_join(tid1, &amp;ret))<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread join err!\r\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_detach</code>: 线程分离, 子线程资源由操作系统回收</p><ul><li><strong>作用</strong>：设置线程为分离状态, 线程退出由系统释放栈空间</li><li><strong>返回</strong>：0 表示正常 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_t</span> tid;<br><br>.... <span class="hljs-comment">//创建线程</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != pthread_detach(tid))<br>&#123;<br>    perror(<span class="hljs-string">&quot;pthread detach fail!&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_self</code>： 获取当前线程自身</p><ul><li><strong>作用</strong>：获取线程自身</li><li><strong>返回</strong>：线程自身的句柄, 类型<code>pthread_t</code></li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_t</span> tid;<br>tid = pthread_self();<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_equal</code>：线程比对</p><ul><li><p><strong>作用</strong>：由于不同平台对<code>pthread_t</code>类型的实现是不一样的, 有的是<code>int</code>, 其他可能是<code>long int</code>, 因此, 为了保持对上接口一致, 使用统一接口进行比较。</p></li><li><p><strong>返回</strong>：0 表示不相等 1相等</p></li><li><p><strong>示例</strong>:</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (pthread_equal(*tid, pthread_self()) != <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is thread self!\r\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_cancel</code>: 线程退出信号</p><ul><li><p><strong>作用</strong>：向一个线程发送退出信号, 类似进程中的<code>kill</code>发送进程信号一样。不过该退出信号时可取消的, 接口<code>pthread_setcancelstate</code>可以修改线程的取消状态, 分别为 <strong><code>PTHREAD_CANCEL_DISABLE</code></strong> / <strong><code>PTHREAD_CANCEL_ENABLE</code></strong>。</p><ul><li>默认情况下, <code>pthread_cancel</code>调用并不等待线程终止, 线程在取消信号发出还会继续运行, 一直运行到某一个取消点(取消点是线程检查它是否被取消的一个位置, 如果此时取消信号刚好存在, 线程会执行退出操作, 不在继续执行)。通常情况下标准的<code>POSIX</code>系统接口基本都是取消点。</li></ul></li><li><p><strong>返回</strong>：无返回</p></li><li><p><strong>示例</strong>:</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (pthread_cancel(tid) != <span class="hljs-number">0</span>)<br>&#123;<br>    perror(<span class="hljs-string">&quot;thread cancel!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_cleanup_pop</code>: 线程清理弹出</p></li><li><p><code>pthread_cleanup_push</code>: 线程清理push</p><ul><li><strong>作用</strong>：当线程退出的时候, 有时候可能需要进行一些清理工作, 这时候就需要该函数来 “安装” 清理程序了。通常情况下如果线程按照我们预期退出, 清理工作线程自行处理即可。但是如果是使用<code>pthread_cancel</code>这类信号退出, 由于其取消点比较多(很多<code>POSIX</code>调用都是), 这时候就需要清理释放相关资源。<ul><li>当线程执行以下动作会触发清理函数<ul><li>调用<code>pthread_exit</code></li><li>响应取消请求的时候</li><li><code>pthread_cleanup_pop</code>参数为非0的时候。0不调用。</li></ul></li><li><code>pthread_cleanup_push</code> 和 <code>pthread_cleanup_pop</code> 由宏来实现的, 所以需要成对出现。</li></ul></li><li><strong>返回</strong>：无返回</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">old_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">pthread_t</span> *tid = (<span class="hljs-type">pthread_t</span> *)arg;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;old thread start! tid:%lX\r\n&quot;</span>, *tid);<br>    pthread_cleanup_push(show_clean_cb, <span class="hljs-string">&quot;old thread clean 1&quot;</span>);<br>    pthread_cleanup_push(show_clean_cb, <span class="hljs-string">&quot;old thread clean 2&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;old thread complete!\r\n&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (pthread_equal(*tid, pthread_self()) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is thread self!\r\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this diff thread is %lX\r\n&quot;</span>, pthread_self());<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;wait sleep to cancel!\r\n&quot;</span>);<br>    &#125;<br><br>    pthread_cleanup_pop((<span class="hljs-type">int</span> <span class="hljs-type">long</span>)arg);<br>    pthread_cleanup_pop((<span class="hljs-type">int</span> <span class="hljs-type">long</span>)arg);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread to cancel finish!\r\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)<span class="hljs-number">455</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="线程属性接口"><a class="markdownIt-Anchor" href="#线程属性接口"></a> 线程属性接口</h4><h5 id="相关线程属性接口列表"><a class="markdownIt-Anchor" href="#相关线程属性接口列表"></a> 相关线程属性接口列表</h5><table><thead><tr><th>接口名</th><th>备注</th></tr></thead><tbody><tr><td><code>pthread_attr_init</code></td><td>线程属性设为默认值</td></tr><tr><td><code>pthread_attr_destroy</code></td><td>线程属性销毁</td></tr><tr><td><code>pthread_attr_getdetachstate</code></td><td>获取线程分离状态</td></tr><tr><td><code>pthread_attr_setdetachstate</code></td><td>设置线程分离状态</td></tr><tr><td><code>pthread_attr_getstack</code></td><td>获取线程堆栈(<code>pthread_attr_getstackadd</code>r已经废弃)</td></tr><tr><td><code>pthread_attr_setstack</code></td><td>设置线程堆栈(<code>pthread_attr_setstackaddr</code>已经废弃)</td></tr><tr><td><code>pthread_attr_getstacksize</code></td><td>获取线程堆栈大小</td></tr><tr><td><code>pthread_attr_setstacksize</code></td><td>设置线程堆栈大小</td></tr><tr><td><code>pthread_attr_getguardsize</code></td><td>获取警戒位置大小</td></tr><tr><td><code>pthread_attr_setguardsize</code></td><td>设置警戒位置大小(堆栈溢出警戒)</td></tr></tbody></table><h5 id="接口详情"><a class="markdownIt-Anchor" href="#接口详情"></a> 接口详情</h5><ul><li><p><code>pthread_attr_init</code>: 线程属性设为默认值</p><ul><li><p><strong>作用</strong>: 设置线程属性的默认值, 一般<code>pthread_create(&amp;tid, NULL, cb, cb_arg)</code> 设置为默认值。有时候通过该接口会<code>malloc</code>申请一定量的属性空间, 因此, 使用完一定要通过<code>destroy</code>来进行释放。</p></li><li><p><strong>参数:</strong> 待设置的线程属性值</p></li><li><p><strong>返回</strong>： 0 表示成功 其他失败</p></li><li><p><strong>示例</strong>:</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_attr_t</span> init_attr;<br>pthread_attr_init(&amp;init_attr);<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_attr_destroy</code>： 线程属性销毁</p><ul><li><p><strong>作用</strong>: 将<code>pthread_attr_init</code>接口设置的属性变量设置为无效值, 同时释放其通过<code>malloc</code>申请的属性空间。由于<code>pthread</code>相关线程属性都是传值的, 所以不用担心指针传递错误释放了属性空间。</p></li><li><p><strong>参数:</strong> 待释放线程属性变量指针</p></li><li><p><strong>返回</strong>： 0 表示成功 其他失败</p></li><li><p><strong>示例</strong>:</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_attr_t</span> init_attr;<br>pthread_attr_init(&amp;init_attr);<br><br><span class="hljs-comment">// .... 线程创建</span><br><br>pthread_attr_destroy(&amp;init_attr); <span class="hljs-comment">// init attr是按值传递, 这里可以销毁</span><br></code></pre></td></tr></table></figure></li><li><p><code>pthread_attr_getdetachstate</code>： 获取线程分离状态</p><ul><li><p><strong>作用</strong>: 通常情况下线程创建以后是以结合状态运行, 即创建线程负责其创建的线程栈资源的回收工作, 通常我们可以使用<code>pthread_detach</code>来进行分离, 但是有时候想在线程创建的一开始就直接创建一个分离线程，那么可以通过此类接口获取和设置分离线程状态。</p></li><li><p><strong>参数:</strong> 线程属性变量指针</p></li><li><p><strong>返回</strong>： 0 表示成功 其他失败</p></li><li><p><strong>示例</strong>:</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">show_detach_state</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *stat)</span><br>&#123;<br>    <span class="hljs-type">int</span> detachState;<br>    EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_attr_getdetachstate(stat, &amp;detachState)); <span class="hljs-comment">//获取默认状态</span><br>    <span class="hljs-keyword">if</span> (detachState == PTHREAD_CREATE_DETACHED)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get detach state!\r\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get joinable state!\r\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_attr_setdetachstate</code>: 设置线程分离状态</p><ul><li><strong>作用</strong>: 设置线程的分离状态</li><li><strong>参数:</strong> 线程属性变量指针以及对应状态</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_attr_t</span> init_attr;<br><br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_attr_init(&amp;init_attr));<br>pthread_attr_setdetachstate(&amp;init_attr, PTHREAD_CREATE_DETACHED); <span class="hljs-comment">//如果系统不设置detach, 然后有没有join等待, 线程会存在栈泄漏的风险</span><br></code></pre></td></tr></table></figure></li><li><p><code>pthread_attr_getstack</code>： 获取线程堆栈(<code>pthread_attr_getstackaddr</code>已经废弃)</p><ul><li><strong>作用</strong>: 默认情况下<code>linux</code>线程的堆栈是创建是系统自动申请的, 通常来说<code>8M</code>左右, 具体看系统实现, 可以通过<code>pthread_attr_getstacksize</code>接口来获取, 如果想手动的获取或者设置线程的堆栈, 那么可以调用此类函数进行。</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">show_stack_addr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *attr)</span><br>&#123;<br>    <span class="hljs-type">void</span> *addr;<br>    <span class="hljs-type">size_t</span> size;<br>    EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_attr_getstack(attr, &amp;addr, &amp;size));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get stack address:%p size:%ld\r\n&quot;</span>, addr, size);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_attr_setstack</code>： 设置线程堆栈(<code>pthread_attr_setstackaddr</code>已经废弃)</p><ul><li><strong>作用</strong>: 设置线程的栈空间, 可以手动指定一个内存空间。</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_attr_t</span> init_attr;<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> buffer[<span class="hljs-number">800</span> * <span class="hljs-number">1024</span>] __attribute__((aligned(<span class="hljs-number">32</span>)));<br><br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_attr_init(&amp;init_attr));<br>pthread_attr_setstack(&amp;init_attr, &amp;buffer[<span class="hljs-number">0</span>], <span class="hljs-keyword">sizeof</span>(buffer));<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_attr_getstacksize</code>: 获取线程堆栈大小</p><ul><li><strong>作用</strong>: 获取堆栈的大小</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> stacksize;<br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_attr_getstacksize(attr, &amp;stacksize));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get stack size:%ld\r\n&quot;</span>, stacksize);<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_attr_setstacksize</code>: 设置线程堆栈大小</p><ul><li><strong>作用</strong>: 设置堆栈的大小</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_attr_t</span> init_attr;<br><br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_attr_init(&amp;init_attr));<br>pthread_attr_setstacksize(&amp;init_attr, <span class="hljs-number">8000</span> * <span class="hljs-number">1024ul</span>);<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_attr_getguardsize</code>: 获取警戒位置大小</p><ul><li><strong>作用</strong>: 获取系统的栈保护空间大小(也就是一个线程栈后面连续的一定空间内存, 用于作为警戒保护空间), 通常来说是以页大小对齐(<code>linux</code>下页空间大小通常为<code>4k</code>)。</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">show_guard_size</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *attr)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> size;<br>    EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_attr_getguardsize(attr, &amp;size));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get guard size:%ld\r\n&quot;</span>, size);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_attr_setguardsize</code>: 设置警戒位置大小(堆栈溢出警戒)</p><ul><li><strong>作用</strong>: 设置警戒空间大小</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_attr_t</span> init_attr;<br><br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_attr_init(&amp;init_attr));<br>pthread_attr_setstack(&amp;init_attr, &amp;buffer[<span class="hljs-number">0</span>], <span class="hljs-keyword">sizeof</span>(buffer));<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="线程同步"><a class="markdownIt-Anchor" href="#线程同步"></a> 线程同步</h3><h4 id="互斥锁"><a class="markdownIt-Anchor" href="#互斥锁"></a> 互斥锁</h4><p>  在一个多线程的系统里, 经常需要共同访问一些公共的系统资源, 如果一个线程对这些公共资源进行了修改, 而其他线程的执行又依赖这些协同资源的值和状态, 那么就存在并发访问的问题, 于是如何处理多线程之间的数据共享而避免并发的错误就较为重要。<br>  互斥锁(<code>mutex</code>)从本质上说是一把锁，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量上的锁。对互斥量进行加锁以后，任何其他试图再次对互斥锁加锁的线程将会阻塞直到当前线程释放该互斥锁。<ins>如果释放互斥锁时有多个线程阻塞，所有在该互斥锁上的阻塞线程都会变成可运行状态，第一个变为运行状态的线程可以对互斥锁加锁，其他线程将会看到互斥锁依然被锁住，只能回去再次等待它重新变为可用。</ins><br>  递归锁（<code>Recursive Lock</code>）也称为可重入互斥锁（<code>reentrant mutex</code>），是互斥锁的一种，同一线程对其多次加锁不会产生死锁。递归锁会使用引用计数机制，以便可以从同一线程多次加锁、解锁，当加锁、解锁次数相等时，锁才可以被其他线程获取。</p><h5 id="互斥锁创建"><a class="markdownIt-Anchor" href="#互斥锁创建"></a> 互斥锁创建</h5><table><thead><tr><th>接口名</th><th>备注</th></tr></thead><tbody><tr><td><code>pthread_mutex_init</code></td><td>互斥量初始化</td></tr><tr><td><code>pthread_mutex_destroy</code></td><td>互斥量销毁</td></tr><tr><td><code>pthread_mutex_trylock</code></td><td>互斥量尝试加锁</td></tr><tr><td><code>pthread_mutex_lock</code></td><td>互斥量加锁</td></tr><tr><td><code>pthread_mutex_timedlock</code></td><td>带超时的互斥量加锁</td></tr><tr><td><code>pthread_mutex_unlock</code></td><td>互斥量解锁</td></tr></tbody></table><hr><h5 id="互斥锁常用接口"><a class="markdownIt-Anchor" href="#互斥锁常用接口"></a> 互斥锁常用接口</h5><ul><li><p><code>pthread_mutex_init</code>: 互斥量初始化</p><ul><li><strong>作用</strong>: 初始化一个互斥量</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;<br>ret = pthread_mutex_init(&amp;lock, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != ret)<br>&#123;<br>    perror(<span class="hljs-string">&quot;mutex init err!&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_mutex_destroy</code>: 互斥量销毁</p><ul><li><strong>作用</strong>: 互斥量销毁, 一般互斥量<code>init</code>的时候会有一些动态内存申请需要释放, 同时其他的值设置为非法值</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;<br>ret = pthread_mutex_init(&amp;lock, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != ret)<br>&#123;<br>    perror(<span class="hljs-string">&quot;mutex init err!&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><br>pthread_mutex_destroy(&amp;lock);<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_mutex_trylock</code>: 互斥量尝试加锁</p><ul><li><strong>作用</strong>: 尝试对互斥锁进行加锁, 当无法加锁返回错误而不会阻塞。</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">mutex_try_wait_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;<br><br>    pthread_mutex_init(&amp;lock, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s thread start!\r\n&quot;</span>, __FUNCTION__);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == pthread_mutex_trylock(&amp;lock))<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is [%s] thread!！！！！\r\n&quot;</span>, __FUNCTION__);<br>            sleep(<span class="hljs-number">3</span>);<br>            pthread_mutex_unlock(&amp;lock);<br>            usleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is [%s] try fail!！！！！\r\n&quot;</span>, __FUNCTION__);<br>            sleep(<span class="hljs-number">1</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_mutex_lock</code>: 互斥量加锁</p><ul><li><strong>作用</strong>: 对互斥锁进行加锁, 如果互斥锁已经被占用, 那么将被阻塞。</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">mutex_wait_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s thread start!\r\n&quot;</span>, __FUNCTION__);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        pthread_mutex_lock(&amp;lock);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is [%s] thread!！！！！\r\n&quot;</span>, __FUNCTION__);<br>        sleep(<span class="hljs-number">2</span>);<br>        pthread_mutex_unlock(&amp;lock);<br>        usleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>    pthread_exit((<span class="hljs-type">void</span> *)<span class="hljs-number">199</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_mutex_timedlock</code>: 带超时的互斥量加锁</p><ul><li><strong>作用</strong>: 当互斥锁被占用, 那么将阻塞, 直到超时时间到达返回。</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">mutex_timeout_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s thread start!\r\n&quot;</span>, __FUNCTION__);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">tv</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span> <span class="hljs-title">ts</span>;</span><br>        gettimeofday(&amp;tv, <span class="hljs-literal">NULL</span>);<br><br>        ts.tv_sec = tv.tv_sec + <span class="hljs-number">1</span>;<br>        ts.tv_nsec = tv.tv_usec;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == pthread_mutex_timedlock(&amp;lock, &amp;ts))<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is [%s] thread!！！！！\r\n&quot;</span>, __FUNCTION__);<br>            sleep(<span class="hljs-number">1</span>);<br>            pthread_mutex_unlock(&amp;lock);<br>            usleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is [%s] timeout------\r\n&quot;</span>, __FUNCTION__);<br>            sleep(<span class="hljs-number">1</span>);<br>        &#125;<br><br>    &#125;<br>    pthread_exit((<span class="hljs-type">void</span> *)<span class="hljs-number">199</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_mutex_unlock</code>: 互斥量解锁</p><ul><li><strong>作用</strong>: 当互斥锁被占用的时候, 用于解除占用。</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">mutex_wait_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s thread start!\r\n&quot;</span>, __FUNCTION__);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        pthread_mutex_lock(&amp;lock);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is [%s] thread!！！！！\r\n&quot;</span>, __FUNCTION__);<br>        sleep(<span class="hljs-number">2</span>);<br>        pthread_mutex_unlock(&amp;lock);<br>        usleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>    pthread_exit((<span class="hljs-type">void</span> *)<span class="hljs-number">199</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="互斥锁属性"><a class="markdownIt-Anchor" href="#互斥锁属性"></a> 互斥锁属性</h5><table><thead><tr><th>接口名</th><th>备注</th></tr></thead><tbody><tr><td><code>pthread_mutexattr_init</code></td><td>互斥量属性初始化默认值</td></tr><tr><td><code>pthread_mutexattr_destroy</code></td><td>互斥量属性销毁</td></tr><tr><td><code>pthread_mutexattr_getpshared</code></td><td>互斥量属性获取共享状态</td></tr><tr><td><code>pthread_mutexattr_setpshared</code></td><td>互斥量属性设置共享状态</td></tr><tr><td><code>pthread_mutexattr_gettype</code></td><td>互斥量获取类型</td></tr><tr><td><code>pthread_mutexattr_settype</code></td><td>互斥量设置类型</td></tr><tr><td><code>pthread_mutexattr_getrobust</code></td><td>获取互斥量健壮状态</td></tr><tr><td><code>pthread_mutexattr_getrobust_np</code></td><td></td></tr><tr><td><code>pthread_mutexattr_setrobust</code></td><td>设置互斥量健壮状态</td></tr><tr><td><code>pthread_mutexattr_setrobust_np</code></td><td></td></tr><tr><td><code>pthread_mutex_consistent</code></td><td>恢复互斥量状态</td></tr></tbody></table><hr><h5 id="互斥锁常见属性接口"><a class="markdownIt-Anchor" href="#互斥锁常见属性接口"></a> 互斥锁常见属性接口</h5><ul><li><p><code>pthread_mutexattr_init</code>: 互斥量属性初始化为默认值</p><ul><li><strong>作用</strong>: 当互斥锁被占用的时候, 用于解除占用。</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_mutexattr_t</span> mutex_attr;<br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_mutexattr_init(&amp;mutex_attr));<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_mutexattr_destroy</code>: 互斥量属性销毁</p><ul><li><strong>作用</strong>: 销毁互斥量属性, <code>pthread</code>里面所有的参数都是传值, 所以当一个属性创建成功以后, 一定要及时的销毁该属性, 因为可能涉及到<code>malloc</code>动态分配的内存, 导致系统发生内存泄漏。</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_mutexattr_t</span> mutex_attr;<br><br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_mutexattr_init(&amp;mutex_attr));<br>ret = pthread_mutex_init(&amp;lock, &amp;mutex_attr);<br><span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != ret)<br>&#123;<br>    pthread_mutexattr_destroy(&amp;mutex_attr);<br>    perror(<span class="hljs-string">&quot;mutex init err!&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br>pthread_mutexattr_destroy(&amp;mutex_attr);<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_mutexattr_getpshared</code>: 互斥量属性获取共享状态</p><ul><li><strong>作用</strong>: 获取一个互斥锁属性的共享状态。</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">show_mutex_attr_sharedStatus</span><span class="hljs-params">(<span class="hljs-type">pthread_mutexattr_t</span> *initMutexAttr)</span><br>&#123;<br>    <span class="hljs-type">int</span> share;<br>    EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_mutexattr_getpshared(initMutexAttr, &amp;share));<br>    <span class="hljs-keyword">switch</span> (share)<br>    &#123;<br>    <span class="hljs-keyword">case</span> PTHREAD_PROCESS_PRIVATE:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get share PTHREAD_PROCESS_PRIVATE\r\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> PTHREAD_PROCESS_SHARED:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get share PTHREAD_PROCESS_SHARED\r\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_mutexattr_setpshared</code>: 互斥量属性设置共享状态</p><ul><li><strong>作用</strong>: 设置互斥锁属性的共享状态, 通常情况下, 需要映射一个进程共享内存, 然后进行互斥锁的共享。(通常其取值: <code>PTHREAD_PROCESS_PRIVATE</code> / <code>PTHREAD_PROCESS_SHARE</code>)</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_mutexattr_setpshared(&amp;mutex_attr, PTHREAD_PROCESS_PRIVATE));<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_mutexattr_gettype</code>: 互斥量获取类型</p><ul><li><strong>作用</strong>: 获取互斥锁属性的类型, 其类型主要要四个。</li></ul><table><thead><tr><th>类型</th><th>备注</th></tr></thead><tbody><tr><td><code>PTHREAD_MUTEX_NORMAL</code></td><td>普通互斥量</td></tr><tr><td><code>PTHREAD_MUTEX_RECURSIVE</code></td><td>递归互斥锁</td></tr><tr><td><code>PTHREAD_MUTEX_ERRORCHECK</code></td><td>错误检查类型互斥锁</td></tr><tr><td><code>PTHREAD_MUTEX_DEFAULT</code></td><td>默认互斥锁(上面三种之一, 具体依赖系统实现)</td></tr></tbody></table><ul><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">show_mutex_attr_type</span><span class="hljs-params">(<span class="hljs-type">pthread_mutexattr_t</span> *initMutexAttr)</span><br>&#123;<br>    <span class="hljs-type">int</span> type;<br>    EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_mutexattr_gettype(initMutexAttr, &amp;type));<br>    <span class="hljs-keyword">switch</span> (type)<br>    &#123;<br>    <span class="hljs-keyword">case</span> PTHREAD_MUTEX_NORMAL:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;show type PTHREAD_MUTEX_NORMAL\r\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> PTHREAD_MUTEX_RECURSIVE:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;show type PTHREAD_MUTEX_RECURSIVE\r\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> PTHREAD_MUTEX_ERRORCHECK:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;show type PTHREAD_MUTEX_ERRORCHECK\r\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;show type PTHREAD_MUTEX_DEFAULT\r\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_mutexattr_settype</code>: 互斥量设置类</p><ul><li><strong>作用</strong>: 设置互斥锁属性类型。</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_mutexattr_t</span> mutex_attr;<br><span class="hljs-type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;<br><br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_mutexattr_init(&amp;mutex_attr));<br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_mutexattr_settype(&amp;mutex_attr, PTHREAD_MUTEX_NORMAL));<br><br>pthread_mutex_init(&amp;lock, &amp;mutex_attr);<br>pthread_mutexattr_destroy(&amp;mutex_attr);<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_mutexattr_getrobust</code>: 获取互斥量健壮状态</p><ul><li><strong>作用</strong>: 获取互斥量属性健壮状态。</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">show_mutex_attr_getrobust</span><span class="hljs-params">(<span class="hljs-type">pthread_mutexattr_t</span> *initMutexAttr)</span><br>&#123;<br>    <span class="hljs-type">int</span> robust;<br>    EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_mutexattr_getrobust(initMutexAttr, &amp;robust));<br>    <span class="hljs-keyword">switch</span> (robust)<br>    &#123;<br>    <span class="hljs-keyword">case</span> PTHREAD_MUTEX_STALLED:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;show robust: PTHREAD_MUTEX_STALLED\r\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> PTHREAD_MUTEX_ROBUST:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;show robust: PTHREAD_MUTEX_ROBUST\r\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_mutexattr_setrobust</code> : 设置互斥量健壮状态</p><ul><li><p><strong>作用</strong>: 设置互斥锁的强健属性, 如: 当一个互斥锁被其他线程占用, 但是该线程在结束前并未释放该互斥锁, 那么通常情况下其他线程将处于永久阻塞状态。假设设置了强健属性, 那么被等待线程将返回一个<code>EOWNERDEAD</code>错误。并结束阻塞状态。</p></li><li><p><strong>参数:</strong> 线程属性变量指针</p></li></ul><table><thead><tr><th>参数</th><th>备注</th></tr></thead><tbody><tr><td><code>PTHREAD_MUTEX_STALLED</code></td><td>正常状态(互斥锁将一直等待)</td></tr><tr><td><code>PTHREAD_MUTEX_ROBUST</code></td><td>互斥锁将直接返回<code>EOWNERDEAD</code>错误结束阻塞</td></tr></tbody></table><ul><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_mutexattr_t</span> mutex_attr;<br><br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_mutexattr_init(&amp;mutex_attr));<br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_mutexattr_setrobust(&amp;mutex_attr, PTHREAD_MUTEX_ROBUST));<br><br>pthread_mutexattr_destroy(&amp;mutex_attr);<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_mutex_consistent</code>: 恢复互斥量状态</p><ul><li><strong>作用</strong>: 当互斥锁被占用的时候, 但是占用的线程的已经结束了, 通常等待该互斥量的线程将一直处于阻塞状态, 当设置了强健属性以后, 互斥量会返回一个错误, 但是如果此时调用解锁互斥量, 其他线程又调用了加锁, 那么该互斥量将永久无法使用, 此时需要调用<code>pthread_mutex_consistent</code>接口恢复互斥量原始状态。然后在进行加锁。</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">mutex_robust_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s thread start!\r\n&quot;</span>, __FUNCTION__);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> ret;<br>        ret = pthread_mutex_lock(&amp;lock);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != ret)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (EOWNERDEAD == ret)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pthread_mutex_consistent solve!\r\n&quot;</span>);<br>                EXEC_RETURN_ZERO(pthread_mutex_consistent(&amp;lock) == <span class="hljs-number">0</span>); <span class="hljs-comment">//恢复到阻塞之前的状态</span><br>                EXEC_RETURN_ZERO(pthread_mutex_unlock(&amp;lock) == <span class="hljs-number">0</span>);<br>                EXEC_RETURN_ZERO(pthread_mutex_lock(&amp;lock) == <span class="hljs-number">0</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ower lock fail!\r\n&quot;</span>);<br>                sleep(<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is [%s] thread!！！！！\r\n&quot;</span>, __FUNCTION__);<br>        sleep(<span class="hljs-number">2</span>);<br>        EXEC_RETURN_ZERO(pthread_mutex_unlock(&amp;lock) == <span class="hljs-number">0</span>);<br>        usleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>    pthread_exit((<span class="hljs-type">void</span> *)<span class="hljs-number">199</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="读写锁"><a class="markdownIt-Anchor" href="#读写锁"></a> 读写锁</h4><h5 id="读写锁创建"><a class="markdownIt-Anchor" href="#读写锁创建"></a> 读写锁创建</h5><p>  互斥锁可以很好的解决多个线程共享共同资源的问题, 有时候, 我们需要大量的对一个公共资源进行读取但是却很少修改, 那么如果使用互斥量来进行资源共享, 会导致效率低下, 因为我们仅仅在写操作的时候才需要去锁着这个资源, 鉴于这种场景, 读写锁就产生了。</p><table><thead><tr><th>函数</th><th>备注</th></tr></thead><tbody><tr><td><code>pthread_rwlock_init</code></td><td>读写锁初始化</td></tr><tr><td><code>pthread_rwlock_destroy</code></td><td>读写锁销毁</td></tr><tr><td><code>pthread_rwlock_rdlock</code></td><td>读锁加锁</td></tr><tr><td><code>pthread_rwlock_tryrdlock</code></td><td>尝试读锁加锁</td></tr><tr><td><code>pthread_rwlock_timedrdlock</code></td><td>带超时的读加锁</td></tr><tr><td><code>pthread_rwlock_wrlock</code></td><td>写加锁</td></tr><tr><td><code>pthread_rwlock_trywrlock</code></td><td>尝试写加锁</td></tr><tr><td><code>pthread_rwlock_timedwrlock</code></td><td>带超时的写加锁</td></tr><tr><td><code>pthread_rwlock_unlock</code></td><td>解锁</td></tr></tbody></table><ul><li><p><code>pthread_rwlock_init</code>: 读写锁初始化</p><ul><li><strong>作用</strong>: 当互斥锁被占用的时候, 但是占用的线程的已经结束了, 通常等待该互斥量的线程将一直处于阻塞状态, 当设置了强健属性以后, 互斥量会返回一个错误, 但是如果此时调用解锁互斥量, 其他线程又调用了加锁, 那么该互斥量将永久无法使用, 此时需要调用<code>pthread_mutex_consistent</code>接口恢复互斥量原始状态。然后在进行加锁。</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_rwlock_t</span> lock = PTHREAD_RWLOCK_INITIALIZER;<br><span class="hljs-keyword">if</span> (pthread_rwlock_init(&amp;lock, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>)<br>&#123;<br>    perror(<span class="hljs-string">&quot;rwlock init fail!&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_rwlock_destroy</code>: 读写锁销毁</p><ul><li><strong>作用</strong>: 销毁一个读写锁</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_rwlock_t</span> lock = PTHREAD_RWLOCK_INITIALIZER;<br><span class="hljs-keyword">if</span> (pthread_rwlock_init(&amp;lock, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>)<br>&#123;<br>    perror(<span class="hljs-string">&quot;rwlock init fail!&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><br>... <span class="hljs-comment">// 其他动作</span><br><br>pthread_rwlock_destroy(&amp;lock);<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_rwlock_rdlock</code>: 读锁加锁</p><ul><li><strong>作用</strong>: 读加锁</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_exec_task0</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s thread start!\r\n&quot;</span>, __FUNCTION__);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == pthread_rwlock_rdlock(&amp;lock))  <span class="hljs-comment">//进行读加锁</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is task[0] thread!\r\n&quot;</span>);<br>            usleep(<span class="hljs-number">100</span>*<span class="hljs-number">1000</span>);<br>            pthread_rwlock_unlock(&amp;lock);<br>            usleep(<span class="hljs-number">323</span>*<span class="hljs-number">1000</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            sleep(<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;task0 get rwlock [fail]\r\n&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_rwlock_tryrdlock</code>: 尝试读锁加锁</p><ul><li><strong>作用</strong>: 尝试读加锁</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_exec_task2</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s thread start!\r\n&quot;</span>, __FUNCTION__);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == pthread_rwlock_tryrdlock(&amp;lock))<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is task[2] thread!\r\n&quot;</span>);<br>            usleep(<span class="hljs-number">170</span>*<span class="hljs-number">1000</span>);<br>            pthread_rwlock_unlock(&amp;lock);<br>            usleep(<span class="hljs-number">520</span>*<span class="hljs-number">1000</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            sleep(<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;try get rdlock [fail]!\r\n&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_rwlock_timedrdlock</code>: 带超时的读加锁</p><ul><li><strong>作用</strong>: 带超市的读加锁</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_exec_task3</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s thread start!\r\n&quot;</span>, __FUNCTION__);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span> <span class="hljs-title">spec</span>;</span><br><br>        clock_gettime(CLOCK_REALTIME, &amp;spec);<br>        spec.tv_sec += <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == pthread_rwlock_timedrdlock(&amp;lock, &amp;spec))<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is task[3] thread!\r\n&quot;</span>);<br>            usleep(<span class="hljs-number">230</span>*<span class="hljs-number">1000</span>);<br>            pthread_rwlock_unlock(&amp;lock);<br>            usleep(<span class="hljs-number">470</span>*<span class="hljs-number">1000</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;rdlock timeout [fail]\r\n&quot;</span>);<br>            sleep(<span class="hljs-number">3</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_rwlock_wrlock</code>: 写加锁</p><ul><li><strong>作用</strong>: 写加锁</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">wr_exec_task0</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s thread start!\r\n&quot;</span>, __FUNCTION__);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (pthread_rwlock_wrlock(&amp;lock) == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is [wr --&gt; 0] thread!!!!!\r\n&quot;</span>);<br>            sleep(<span class="hljs-number">1</span>);<br>            pthread_rwlock_unlock(&amp;lock);<br>            sleep(<span class="hljs-number">7</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            usleep(<span class="hljs-number">1000</span>*<span class="hljs-number">1510</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread0 wr lock get [fail]\r\n&quot;</span>);<br>        &#125;<br>    &#125;<br>    pthread_exit((<span class="hljs-type">void</span> *)<span class="hljs-number">199</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_rwlock_trywrlock</code>: 尝试写加锁</p><ul><li><strong>作用</strong>: 尝试写加锁</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">wr_exec_task1</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s thread start!\r\n&quot;</span>, __FUNCTION__);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (pthread_rwlock_trywrlock(&amp;lock) == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is [wr --&gt; 1] thread!!!!!\r\n&quot;</span>);<br>            sleep(<span class="hljs-number">1</span>);<br>            pthread_rwlock_unlock(&amp;lock);<br>            sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            usleep(<span class="hljs-number">1000</span>*<span class="hljs-number">1000</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread1 wr try lock get [fail]\r\n&quot;</span>);<br>        &#125;<br>    &#125;<br>    pthread_exit((<span class="hljs-type">void</span> *)<span class="hljs-number">199</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_rwlock_timedwrlock</code>: 带超时的写加锁</p><ul><li><strong>作用</strong>: 带超市的写加锁</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">wr_exec_task2</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s thread start!\r\n&quot;</span>, __FUNCTION__);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span> <span class="hljs-title">spec</span>;</span><br><br>        clock_gettime(CLOCK_REALTIME, &amp;spec);<br>        spec.tv_sec += <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">if</span> (pthread_rwlock_timedwrlock(&amp;lock, &amp;spec) == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is [wr ---&gt; 2] thread!!!!!\r\n&quot;</span>);<br>            sleep(<span class="hljs-number">3</span>);<br>            pthread_rwlock_unlock(&amp;lock);<br>            sleep(<span class="hljs-number">5</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            sleep(<span class="hljs-number">4</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread2 wr timeout get [fail]\r\n&quot;</span>);<br>        &#125;<br>    &#125;<br>    pthread_exit((<span class="hljs-type">void</span> *)<span class="hljs-number">199</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_rwlock_unlock</code>: 解锁</p><ul><li><strong>作用</strong>: 解锁</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == pthread_rwlock_rdlock(&amp;lock))<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is task[1] thread!\r\n&quot;</span>);<br>    usleep(<span class="hljs-number">150</span>*<span class="hljs-number">1000</span>);<br>    pthread_rwlock_unlock(&amp;lock);<br>    usleep(<span class="hljs-number">721</span>*<span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="读写锁属性"><a class="markdownIt-Anchor" href="#读写锁属性"></a> 读写锁属性</h5><table><thead><tr><th>函数</th><th>备注</th></tr></thead><tbody><tr><td><code>pthread_rwlockattr_init</code></td><td>读写锁属性初始化</td></tr><tr><td><code>pthread_rwlockattr_destroy</code></td><td>读写锁属性销毁</td></tr><tr><td><code>pthread_rwlockattr_getpshared</code></td><td>获取共享状态</td></tr><tr><td><code>pthread_rwlockattr_setpshared</code></td><td>设置共享状态</td></tr></tbody></table><ul><li><p><code>pthread_rwlockattr_init</code>: 读写锁初始化</p><ul><li><strong>作用</strong>: 解锁</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_rwlockattr_t</span> rwlock_attr;<br><br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_rwlockattr_init(&amp;rwlock_attr));<br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_rwlockattr_setpshared(&amp;rwlock_attr, PTHREAD_PROCESS_PRIVATE)); <span class="hljs-comment">//设置私有锁</span><br><br><span class="hljs-keyword">if</span> (pthread_rwlock_init(&amp;lock, &amp;rwlock_attr) != <span class="hljs-number">0</span>)<br>&#123;<br>    perror(<span class="hljs-string">&quot;rwlock init fail!&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_rwlockattr_destroy(&amp;rwlock_attr));<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_rwlockattr_destroy</code>: 读写锁属性销毁</p><ul><li><strong>作用</strong>: 读写锁属性销毁</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_rwlockattr_t</span> rwlock_attr;<br><br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_rwlockattr_init(&amp;rwlock_attr));<br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_rwlockattr_setpshared(&amp;rwlock_attr, PTHREAD_PROCESS_PRIVATE)); <span class="hljs-comment">//设置私有锁</span><br><br><span class="hljs-keyword">if</span> (pthread_rwlock_init(&amp;lock, &amp;rwlock_attr) != <span class="hljs-number">0</span>)<br>&#123;<br>    perror(<span class="hljs-string">&quot;rwlock init fail!&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_rwlockattr_destroy(&amp;rwlock_attr)); <span class="hljs-comment">//销毁属性</span><br></code></pre></td></tr></table></figure></li><li><p><code>pthread_rwlockattr_getpshared</code>: 获取读写锁的共享状态</p><ul><li><strong>作用</strong>: 获取读写锁的共享状态</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> share;<br>pthread_rwlockattr_getpshared(&amp;rwlock_attr, &amp;share);<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_rwlockattr_setpshared</code>: 尝试读锁加锁</p><ul><li><strong>作用</strong>: 解锁</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_rwlockattr_t</span> rwlock_attr;<br><br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_rwlockattr_init(&amp;rwlock_attr));<br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_rwlockattr_setpshared(&amp;rwlock_attr, PTHREAD_PROCESS_PRIVATE)); <span class="hljs-comment">//设置私有锁</span><br><br><span class="hljs-keyword">if</span> (pthread_rwlock_init(&amp;lock, &amp;rwlock_attr) != <span class="hljs-number">0</span>)<br>&#123;<br>    perror(<span class="hljs-string">&quot;rwlock init fail!&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_rwlockattr_destroy(&amp;rwlock_attr));<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="条件变量"><a class="markdownIt-Anchor" href="#条件变量"></a> 条件变量</h4><h5 id="条件变量创建"><a class="markdownIt-Anchor" href="#条件变量创建"></a> 条件变量创建</h5><p>  当我们需要修改某一共享资源的时候, 需要提供互斥锁来进行资源保护, 假设存在一个场景, 我们修改共享资源, 修改完以后需要及时的同步另一个线程当前的改变, 那么如果使用以往的经验可能需要两个步骤：</p><ul><li>对互斥量进行修改</li><li>修改后发送一个同步信号同步其他线程。</li></ul><p>如果按照以往的经验, 该操作有几种实现方式:</p><ol><li>使用一个互斥量来对共享变量进行修改</li><li>在加锁范围内进行条件判断, 进行轮训</li></ol><p>如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>&#123;<br>    pthread_mutex_lock(&amp;mutex);<br>    iCount++;<br>    pthread_mutex_unlock(&amp;mutex);<br>&#125;<br><br><span class="hljs-comment">//thread 2:</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>&#123;<br>    pthread_mutex_lock(&amp;mutex);<br>    <span class="hljs-keyword">if</span>(iCount &gt;= <span class="hljs-number">100</span>)<br>    &#123;<br>        iCount = <span class="hljs-number">0</span>;<br>    &#125;<br>    pthread_mutex_unlock(&amp;mutex);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这种操作确实同样解决问题, 但是反复的加锁和解锁, 检测轮训会大大降低系统性能的降低。方法2.</p><ol><li>使用一个互斥锁进行全局共享变量修改</li><li>使用一个信号量进行同步</li></ol><p>其效果和条件变量效果一致, 但是条件变量更加健壮, 使用方法2存在一个问题, 假设我们修改了资源, 在进行同步的时候, 另一个线程还没有进入等待状态, 这时候就存在信号丢失的风险, 但是条件锁由于前期加锁, 所以条件等待线程会被直接阻塞。</p><p><strong>优势</strong>: 用于多个线程的信号同步, 如一个线程修改了资源, 其他几个线程共享该资源的情况。通常条件等待是需要<code>while</code>来判断的, 如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">pthread_mutex_lock(&amp;lock);<br><span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 条件变量index表示资源是否还存在</span><br>&#123;<br>    pthread_cond_wait(&amp;cond_wait); <span class="hljs-comment">//进入阻塞前lock解锁挂起</span><br><br>    <span class="hljs-comment">//返回后pthread_mutex_lock加锁</span><br>&#125;<br><br>pthread_mutex_unlock(&amp;lock);<br></code></pre></td></tr></table></figure><h5 id="条件变量和信号量的区别"><a class="markdownIt-Anchor" href="#条件变量和信号量的区别"></a> 条件变量和信号量的区别</h5><ul><li>最大的区别应该是使用条件变量可以一次唤醒所有等待者，但信号量不行。</li><li>信号量有一个表示状态的值，而条件变量是没有的，没有地方记录唤醒（发送信号）过多少次，也没有地方记录唤醒线程（<code>wait</code>返回）过多少次。从实现上来说一个信号量可以是用<code>mutex + counter + condition variable</code> 实现的。因为信号量有一个状态，如果想精准的同步，那么信号量可能会有特殊的地方。信号量可以解决条件变量中存在的唤醒丢失问题。</li><li>在<code>Posix.1</code>基本原理一文声称，有了互斥锁和条件变量还提供信号量的原因是：“本标准提供信号量的主要目的是提供一种进程间同步的方式，这些进程可能共享也可能不共享内存区。互斥锁和条件变量是作为线程间的同步机制说明的，这些线程总是共享(某个)内存区。” 尽管信号量的意图在于进程间同步，互斥锁和条件变量的意图在于线程间同步，但是信号量也可用于线程间，互斥锁和条件变量也可用于进程间。信号量最有用的场景是用以指明可用资源的数量。</li></ul><p><strong>经典的一句话：</strong><br>互斥量是信号量的一种特例，互斥量的本质是一把锁。<code>A mutex is basically a lock that we set (lock) before accessing a shared resource and release (unlock) when we’re done</code></p><table><thead><tr><th>函数</th><th>备注</th></tr></thead><tbody><tr><td><code>pthread_cond_init</code></td><td>条件变量初始化</td></tr><tr><td><code>pthread_cond_destroy</code></td><td>条件变量销毁</td></tr><tr><td><code>pthread_cond_signal</code></td><td>发送信号</td></tr><tr><td><code>pthread_cond_broadcast</code></td><td>广播信号</td></tr><tr><td><code>pthread_cond_wait</code></td><td>等待信号</td></tr><tr><td><code>pthread_cond_timedwait</code></td><td>带超时的等待信号</td></tr></tbody></table><ul><li><p><code>pthread_cond_init</code>: 条件变量初始化</p><ul><li><strong>作用</strong>: 对条件变量进行初始化</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;<br><span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != pthread_cond_init(&amp;cond, <span class="hljs-literal">NULL</span>))<br>&#123;<br>    perror(<span class="hljs-string">&quot;mutex init error!&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_cond_destroy</code>: 条件变量销毁</p><ul><li><strong>作用</strong>: 对条件变量进行销毁</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;<br><span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != pthread_cond_init(&amp;cond, <span class="hljs-literal">NULL</span>))<br>&#123;<br>    perror(<span class="hljs-string">&quot;mutex init error!&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br>pthread_cond_destroy(&amp;cond);<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_cond_signal</code>: 发送信号</p><ul><li><strong>作用</strong>: 发送一个同步信号唤醒等待线程, 一次只能唤醒一个线程</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">signal_send_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s thread start!\r\n&quot;</span>, __FUNCTION__);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        pthread_mutex_lock(&amp;lock);<br>        <span class="hljs-comment">/*在这里进行保护数据的操作*/</span><br>        usleep(<span class="hljs-number">100</span>*<span class="hljs-number">1000</span>);<br>        pthread_mutex_unlock(&amp;lock);<br><br>        usleep(<span class="hljs-number">300</span>*<span class="hljs-number">1000</span>); <span class="hljs-comment">//等待线程切换, 其他线程进入wait状态, 避免丢信号</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == pthread_cond_signal(&amp;cond)) <span class="hljs-comment">//发送信号, 正常不需要加锁</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%s] send ok!\r\n&quot;</span>, __FUNCTION__);<br>            sleep(<span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            sleep(<span class="hljs-number">5</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%s] send fail!\r\n&quot;</span>, __FUNCTION__);<br>        &#125;<br>    &#125;<br>    pthread_exit((<span class="hljs-type">void</span> *)<span class="hljs-number">199</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_cond_broadcast</code>: 广播信号</p><ul><li><strong>作用</strong>: 发送一个同步信号唤醒所有的等待线程</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">signal_broadcase_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s thread start!\r\n&quot;</span>, __FUNCTION__);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        pthread_mutex_lock(&amp;lock);<br>        <span class="hljs-comment">/*在这里进行数据的操作*/</span><br>        usleep(<span class="hljs-number">200</span>*<span class="hljs-number">1000</span>);<br>        pthread_mutex_unlock(&amp;lock);<br><br>        usleep(<span class="hljs-number">200</span>*<span class="hljs-number">1000</span>); <span class="hljs-comment">//等待线程切换, 其他线程进入wait状态, 避免丢信号</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == pthread_cond_broadcast(&amp;cond))<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%s] send ok!\r\n&quot;</span>, __FUNCTION__);<br>            sleep(<span class="hljs-number">7</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            sleep(<span class="hljs-number">3</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%s] send fail!\r\n&quot;</span>, __FUNCTION__);<br>        &#125;<br>    &#125;<br>    pthread_exit((<span class="hljs-type">void</span> *)<span class="hljs-number">199</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_cond_wait</code>: 等待信号</p><ul><li><strong>作用</strong>: 等待线程进行同步</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">signal_recv_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s thread start!\r\n&quot;</span>, __FUNCTION__);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        pthread_mutex_lock(&amp;lock);<br>        <span class="hljs-comment">/*在这里进行数据的操作*/</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == pthread_cond_wait(&amp;cond, &amp;lock)) <span class="hljs-comment">//进入cond后互斥锁解锁然后条件锁加锁, 返回后条件锁解锁, 互斥锁加锁</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%s] wait signal success!\r\n&quot;</span>, __FUNCTION__);<br>            pthread_mutex_unlock(&amp;lock);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            pthread_mutex_unlock(&amp;lock);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%s] wait signal fail!\r\n&quot;</span>, __FUNCTION__);<br>            sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    pthread_exit((<span class="hljs-type">void</span> *)<span class="hljs-number">199</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_cond_timedwait</code>: 带超时的等待信号</p><ul><li><strong>作用</strong>: 带超时的信号等待, 等待的时间为一个绝对时间, 不是相对时间</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">signal_timeRecv_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s thread start!\r\n&quot;</span>, __FUNCTION__);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        sleep(<span class="hljs-number">2</span>);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span> <span class="hljs-title">now</span>;</span><br>        clock_gettime(CLOCK_REALTIME, &amp;now);<br>        now.tv_sec += <span class="hljs-number">2</span>;<br><br>        pthread_mutex_lock(&amp;lock);<br>        <span class="hljs-comment">/*在这里进行数据的操作*/</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == pthread_cond_timedwait(&amp;cond, &amp;lock, &amp;now))<span class="hljs-comment">//会自动去unlock 然后wait</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%s] timeout signal success!\r\n&quot;</span>, __FUNCTION__);<br>            pthread_mutex_unlock(&amp;lock);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            pthread_mutex_unlock(&amp;lock);<br>            sleep(<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%s] timeout signal fail!\r\n&quot;</span>, __FUNCTION__);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="条件变量属性"><a class="markdownIt-Anchor" href="#条件变量属性"></a> 条件变量属性</h5><table><thead><tr><th>函数</th><th>备注</th></tr></thead><tbody><tr><td><code>pthread_condattr_init</code></td><td>条件变量属性初始化</td></tr><tr><td><code>pthread_condattr_destroy</code></td><td>条件变量属性销毁</td></tr><tr><td><code>pthread_condattr_getpshared</code></td><td>获取共享属性</td></tr><tr><td><code>pthread_condattr_setpshared</code></td><td>设置共享属性</td></tr><tr><td><code>pthread_condattr_getclock</code></td><td>获取<code>cond</code>时钟</td></tr><tr><td><code>pthread_condattr_setclock</code></td><td>设置<code>cond</code>时钟</td></tr></tbody></table><ul><li><p><code>pthread_condattr_init</code>: 条件变量属性初始化</p><ul><li><strong>作用</strong>: 初始化一个条件变量属性为默认值, 可能涉及到<code>malloc</code>, 所以使用完需要通过<code>destroy</code>进行释放。</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_condattr_t</span> cond_attr;<br><br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_condattr_init(&amp;cond_attr));<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_condattr_destroy</code>: 条件变量属性销毁</p><ul><li><strong>作用</strong>: 销毁一个条件变量, 并将其内部值设置为无效值。</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_condattr_t</span> cond_attr;<br><br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_condattr_init(&amp;cond_attr));<br>pthread_condattr_destroy(&amp;cond_attr);<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_condattr_getpshared</code>: 获取进程共享属性</p><ul><li><strong>作用</strong>: 获取进程共享属性</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_condattr_t</span> cond_attr;<br><br><span class="hljs-type">int</span> share;<br>pthread_condattr_getpshared(&amp;cond_attr, &amp;share);<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_condattr_setpshared</code>: 设置条件变量的进程共享属性</p><ul><li><strong>作用</strong>: 获取进程共享属性</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_condattr_t</span> cond_attr;<br><br>pthread_condattr_setpshared(&amp;cond_attr, PTHREAD_PROCESS_PRIVATE);<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_condattr_getclock</code>: 获取条件变量的当前时钟</p><ul><li><strong>作用</strong>: 获取条件变量的当前时钟</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">show_clock_info</span><span class="hljs-params">(<span class="hljs-type">pthread_condattr_t</span> *attr)</span><br>&#123;<br>    <span class="hljs-type">clockid_t</span> id;<br>    EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_condattr_getclock(attr, &amp;id));<br><br>    <span class="hljs-keyword">switch</span> (id)<br>    &#123;<br>    <span class="hljs-keyword">case</span> CLOCK_REALTIME:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get clock CLOCK_REALTIME\r\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> CLOCK_PROCESS_CPUTIME_ID:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get clock CLOCK_PROCESS_CPUTIME_ID\r\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> CLOCK_THREAD_CPUTIME_ID:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get clock CLOCK_THREAD_CPUTIME_ID\r\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> CLOCK_MONOTONIC:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get clock CLOCK_MONOTONIC\r\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unknow Clock Source!\r\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_condattr_setclock</code>: 带超时的等待信号</p><ul><li><strong>作用</strong>: 获取进程共享属性</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_condattr_t</span> cond_attr;<br><br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_condattr_init(&amp;cond_attr));<br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_condattr_setclock(&amp;cond_attr, CLOCK_MONOTONIC));<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="自旋锁"><a class="markdownIt-Anchor" href="#自旋锁"></a> 自旋锁</h4><h5 id="自旋锁创建"><a class="markdownIt-Anchor" href="#自旋锁创建"></a> 自旋锁创建</h5><p>  对于传统的互斥锁而言, 当锁被其他线程占用, 此时线程将被挂起并发生上下文切换, <strong>对于一般的低速线程</strong>, 互斥锁可以提供整个系统的性能, 因为只有锁被释放, 当前线程才有可能被执行, 减少了无效的轮训检测, 但是 <strong>对于高速的线程而言</strong> , 由于这种高效性的要求是无法容忍上下文的开销, 因此自旋锁应运而生, 自旋锁在没有获取到锁之前保持自旋, 此时线程不会被挂起, 不发生上下文切换。提供特殊场景的效率, 但是如果在低俗线程中使用, 将带来极大的性能损耗。</p><table><thead><tr><th>函数</th><th>备注</th></tr></thead><tbody><tr><td><code>pthread_spin_init</code></td><td>自旋锁初始化</td></tr><tr><td><code>pthread_spin_destory</code></td><td>自旋锁销毁</td></tr><tr><td><code>pthread_spin_lock</code></td><td>自旋锁锁住</td></tr><tr><td><code>pthread_spin_unlock</code></td><td>自旋锁解锁</td></tr><tr><td><code>pthread_spin_trylock</code></td><td>自旋锁尝试枷锁</td></tr></tbody></table><ul><li><p><code>pthread_spin_init</code>: 自旋锁初始化</p><ul><li><strong>作用</strong>: 自旋锁初始化</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_spinlock_t</span> lock;<br>ret = pthread_spin_init(&amp;lock, <span class="hljs-number">0</span>); <span class="hljs-comment">//自旋锁初始化, 会Malloc空间</span><br>pthread_spin_destroy(&amp;lock);<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_spin_destory</code>: 自旋锁销毁</p><ul><li><strong>作用</strong>: 自旋锁销毁</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_spinlock_t</span> lock;<br>ret = pthread_spin_init(&amp;lock, <span class="hljs-number">0</span>); <span class="hljs-comment">//自旋锁初始化, 会Malloc空间</span><br>pthread_spin_destroy(&amp;lock);<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_spin_lock</code>: 自旋锁锁住</p><ul><li><strong>作用</strong>: 自旋锁锁住, 此时系统没有获取到锁将原地自旋, 不发生上下文切换。</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">old_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;old thread start!\r\n&quot;</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        pthread_spin_lock(&amp;lock);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is [old] thread!!!!!!!!!!\r\n&quot;</span>);<br>        <span class="hljs-comment">//usleep(1000*100);</span><br>        pthread_spin_unlock(&amp;lock);<br>        usleep(<span class="hljs-number">12</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_spin_unlock</code>: 自旋锁解锁</p><ul><li><strong>作用</strong>: 自旋锁被解锁</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">old_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;old thread start!\r\n&quot;</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        pthread_spin_lock(&amp;lock);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is [old] thread!!!!!!!!!!\r\n&quot;</span>);<br>        <span class="hljs-comment">//usleep(1000*100);</span><br>        pthread_spin_unlock(&amp;lock);<br>        usleep(<span class="hljs-number">12</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_spin_trylock</code>: 自旋锁尝试枷锁</p><ul><li><strong>作用</strong>: 自旋锁尝试枷锁</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">new_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;new thread start!\r\n&quot;</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">//pthread_spin_lock(&amp;lock);</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == pthread_spin_trylock(&amp;lock))<br>        &#123;<br>            flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is [new] thread!!!!!!!!!!\r\n&quot;</span>);<br>            sleep(<span class="hljs-number">1</span>);<br>            pthread_spin_unlock(&amp;lock);<br>            usleep(<span class="hljs-number">20</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (!flag)<br>            &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;try get lock faiL!\r\n&quot;</span>);<br>            &#125;<br>            usleep(<span class="hljs-number">10</span>);<br>        &#125;<br>    &#125;<br>    pthread_exit((<span class="hljs-type">void</span> *)<span class="hljs-number">199</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="自旋锁属性"><a class="markdownIt-Anchor" href="#自旋锁属性"></a> 自旋锁属性</h5><hr><h4 id="屏障"><a class="markdownIt-Anchor" href="#屏障"></a> 屏障</h4><h5 id="屏障创建"><a class="markdownIt-Anchor" href="#屏障创建"></a> 屏障创建</h5><p>  屏障和之前的其他同步不一样, 之前其他的同步大多数都是达到某一条件以后, 单个线程或者多个线程被唤醒, 也就是说信号同步的发生取决于最先发送信号的线程, 而屏障同步的发生取决于最后一个条件的到达。</p><table><thead><tr><th>函数</th><th>备注</th></tr></thead><tbody><tr><td><code>pthread_barrier_init</code></td><td>屏障初始化</td></tr><tr><td><code>pthread_barrier_destroy</code></td><td>屏障销毁</td></tr><tr><td><code>pthread_barrier_wait</code></td><td>屏障等待</td></tr></tbody></table><ul><li><p><code>pthread_barrier_init</code>： 屏障初始化</p><ul><li><strong>作用</strong>: 屏障初始化</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_THREAD_NUM 10 <span class="hljs-comment">//最多支持10个线程同步</span></span><br><br><span class="hljs-type">pthread_barrier_t</span> bat;<br><span class="hljs-keyword">if</span> (pthread_barrier_init(&amp;bat, <span class="hljs-literal">NULL</span>, MAX_THREAD_NUM) != <span class="hljs-number">0</span>)<br>&#123;<br>    perror(<span class="hljs-string">&quot;barrier err!&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_barrier_destroy</code>: 屏障销毁</p><ul><li><strong>作用</strong>: 屏障销毁</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_THREAD_NUM 10 <span class="hljs-comment">//最多支持10个线程同步</span></span><br><br><span class="hljs-type">pthread_barrier_t</span> bat;<br><span class="hljs-keyword">if</span> (pthread_barrier_init(&amp;bat, <span class="hljs-literal">NULL</span>, MAX_THREAD_NUM) != <span class="hljs-number">0</span>)<br>&#123;<br>    perror(<span class="hljs-string">&quot;barrier err!&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br>pthread_barrier_destroy(&amp;bat); <span class="hljs-comment">//屏障销毁</span><br></code></pre></td></tr></table></figure></li><li><p><code>pthread_barrier_wait</code>: 屏障等待</p><ul><li><strong>作用</strong>: 屏障等待</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">exec_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">int</span> value = (<span class="hljs-type">long</span> <span class="hljs-type">int</span>)(<span class="hljs-type">void</span>*)arg;<br>    usleep(value);<br><br>    system(<span class="hljs-string">&quot;date&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s [%ld] ready!!!\r\n&quot;</span>, __FUNCTION__, value/<span class="hljs-number">1000</span>);<br><br>    <span class="hljs-type">int</span> ret = pthread_barrier_wait(&amp;bat);<br>    <span class="hljs-keyword">if</span> (PTHREAD_BARRIER_SERIAL_THREAD == ret) <span class="hljs-comment">//最后一个到达线程兼第一个唤醒线程</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s [%ld] wakeup running\r\n&quot;</span>, __FUNCTION__, value/<span class="hljs-number">1000</span>);<br>        system(<span class="hljs-string">&quot;date&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == ret)  <span class="hljs-comment">//其他之前等待的线程</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s [%ld] running\r\n&quot;</span>, __FUNCTION__, value/<span class="hljs-number">1000</span>);<br>        system(<span class="hljs-string">&quot;date&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;wait pthread fail: [%ld]\r\n&quot;</span>, value);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    pthread_exit((<span class="hljs-type">void</span> *)<span class="hljs-number">199</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="屏障属性"><a class="markdownIt-Anchor" href="#屏障属性"></a> 屏障属性</h5><table><thead><tr><th>函数</th><th>备注</th></tr></thead><tbody><tr><td><code>pthread_barrierattr_init</code></td><td>屏障属性初始化</td></tr><tr><td><code>pthread_barrierattr_destroy</code></td><td>屏障属性销毁</td></tr><tr><td><code>pthread_barrierattr_getpshared</code></td><td>屏障共享状态获取</td></tr><tr><td><code>pthread_barrierattr_setpshared</code></td><td>屏障共享状态设置</td></tr></tbody></table><ul><li><p><code>pthread_barrierattr_init</code> 屏障初始化</p><ul><li><strong>作用</strong>: 屏障属性初始化</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_barrierattr_t</span> barrier_attr;<br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_barrierattr_init(&amp;barrier_attr));<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_barrierattr_destroy</code>: 屏障销毁</p><ul><li><strong>作用</strong>: 屏障属性销毁</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_barrierattr_t</span> barrier_attr;<br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_barrierattr_init(&amp;barrier_attr));<br><br>pthread_barrier_destroy(&amp;bat);<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_barrierattr_getpshared</code>: 屏障共享状态获取</p><ul><li><strong>作用</strong>: 屏障共享状态获取</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> share;<br><span class="hljs-type">pthread_barrierattr_t</span> barrier_attr;<br><br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_barrierattr_init(&amp;barrier_attr));<br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_barrierattr_getpshared(&amp;barrier_attr, &amp;share));<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_barrierattr_setpshared</code></p><ul><li><strong>作用</strong>: 屏障共享状态设置</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_barrierattr_t</span> barrier_attr;<br><br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_barrierattr_init(&amp;barrier_attr));<br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_barrierattr_setpshared(&amp;barrier_attr, PTHREAD_PROCESS_PRIVATE));<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="重入"><a class="markdownIt-Anchor" href="#重入"></a> 重入</h3><p>  如果一个函数在相同时间点可以被多个线程安全的调用, 就称为该函数是 <strong>线程安全</strong>, 但这并不说明对信号处理程序来说是可重入的, 如果函数对异步信号处理程序的重入是安全的, 那么就可以说函数是 <strong>异步安全</strong>。</p><table><thead><tr><th>函数</th><th>备注</th></tr></thead><tbody><tr><td><code>flockfile</code></td><td>获取文件锁</td></tr><tr><td><code>funlockfile</code></td><td>释放文件锁</td></tr><tr><td><code>putc_unlocked</code></td><td>向特定文件压入一个字符</td></tr><tr><td><code>ftrylockfile</code></td><td>尝试获取文件锁</td></tr><tr><td><code>putchar_unlocked</code></td><td>向终端写入一个字符</td></tr><tr><td><code>getchar_unlocked</code></td><td>从终端获取一个字符</td></tr><tr><td><code>getc_unlocked</code></td><td>从特定句柄获取一个字符</td></tr></tbody></table><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">new_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    FILE *lc_file = (FILE *)arg;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;new thread start!\r\n&quot;</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        flockfile(lc_file);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%s] get file lock!\r\n&quot;</span>, __FUNCTION__);<br>        sleep(<span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%s] release file lock!\r\n&quot;</span>, __FUNCTION__);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)<br>        &#123;<br>            putc_unlocked((<span class="hljs-type">char</span>)(i + <span class="hljs-string">&#x27;A&#x27;</span>), lc_file);<br>        &#125;<br>        funlockfile(lc_file);<br>        fflush(lc_file);<br>        usleep(<span class="hljs-number">1000</span> * <span class="hljs-number">157</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">old_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    FILE *lc_file = (FILE *)arg;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;old thread start!\r\n&quot;</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        flockfile(lc_file);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%s] get file lock!\r\n&quot;</span>, __FUNCTION__);<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%s] release file lock!\r\n&quot;</span>, __FUNCTION__);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)<br>        &#123;<br>            putc_unlocked((<span class="hljs-type">char</span>)(i + <span class="hljs-string">&#x27;a&#x27;</span>), lc_file);<br>        &#125;<br>        funlockfile(lc_file);<br>        fflush(lc_file);<br>        usleep(<span class="hljs-number">1000</span> * <span class="hljs-number">733</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>:</p><ol><li>除非被<code>flockfile</code>(或 <code>ftrylockfile</code>)和 <code>funlockfile</code>的调用包围, 否则尽量不要调用这些函数, 因为他们会导致不可预期的结果。(如由于多线程非同步访问数据引发的种种问题)</li><li>一旦对<code>FILE</code>对象加锁, 就可以在释放锁之前尽可能多的调用这些函数来分摊加解锁带来的性能开销。</li></ol><hr><h3 id="线程特定数据"><a class="markdownIt-Anchor" href="#线程特定数据"></a> 线程特定数据</h3><p>  有的时候线程需要一些特殊的数据, 这个数据属于线程私有的, 不被其他线程所共享(由于同一进程空间内所有线程共享进程空间, 所以其实其他线程也是可以修改和读取的), 对于这一类的数据, <code>pthread</code>线程库提供了特殊的接口进行创建。</p><table><thead><tr><th>函数</th><th>备注</th></tr></thead><tbody><tr><td><code>pthread_once</code></td><td>保证变量只被创建一次</td></tr><tr><td><code>pthread_key_create</code></td><td>创建一个键</td></tr><tr><td><code>pthread_key_delete</code></td><td>删除一个键</td></tr><tr><td><code>pthread_getspecific</code></td><td>获取键值关联空间地址</td></tr><tr><td><code>pthread_setspecific</code></td><td>设置键值关联空间地址</td></tr></tbody></table><ul><li><p><code>pthread_once</code>: 保证变量只被创建一次</p><ul><li><strong>作用</strong>: 保证变量只被创建一次, 该接口定义一个<code>pthread_once_t</code>变量用于保证其关联的回调只被调用一次。</li><li><strong>参数:</strong> 线程属性变量指针</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_once_t</span> once_v = PTHREAD_ONCE_INIT;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">key_v_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    ... <span class="hljs-comment">//做相关的初始化</span><br>&#125;<br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_once(&amp;once_v, key_v_init));<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_key_create</code> : 创建一个键</p><ul><li><strong>作用</strong>: 用于创建一个键值, 该键值会关联一个析构函数接口, 用于释放关联内存的释放, 避免进程内存泄漏。</li><li><strong>参数:</strong> <code>key</code>类型变量以及析构函数</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ley_v_free</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != arg)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;free mem: %p\r\n&quot;</span>, arg);<br>        <span class="hljs-built_in">free</span>(arg);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%llX free!\r\n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>)pthread_self());<br>&#125;<br><br><span class="hljs-type">pthread_key_t</span> key_v;<br>EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_key_create(&amp;key_v, ley_v_free));<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_key_delete</code> : 删除一个键</p><ul><li><strong>作用</strong>: 删除一个键值, 但是并不会析构相关申请的内存, 并不会析构相关内存。</li><li><strong>参数:</strong> <code>key</code>类型变量</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">key_v_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_key_create(&amp;key_v, ley_v_free));<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pthread_getspecific(key_v))<br>    &#123;<br>        <span class="hljs-type">void</span> *data = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-number">4096</span>));<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != data)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc: %p\r\n&quot;</span>, data);<br>            EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_setspecific(key_v, data));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">thread_new</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_once(&amp;once_v, key_v_init));<br>    EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_key_delete(key_v));   <span class="hljs-comment">//并不会调用析构函数去释放申请的内存, 需要手动去释放。</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_getspecific</code> : 获取键值关联空间地址</p><ul><li><strong>作用</strong>: 获取键值所关联的地址空间</li><li><strong>参数:</strong> <code>key</code>类型变量</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">key_v_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_key_create(&amp;key_v, ley_v_free));<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pthread_getspecific(key_v))<br>    &#123;<br>        <span class="hljs-type">void</span> *data = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-number">4096</span>));<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != data)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc: %p\r\n&quot;</span>, data);<br>            EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_setspecific(key_v, data));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">thread_new</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_once(&amp;once_v, key_v_init));<br>    EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_key_delete(key_v));<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_setspecific</code> : 设置键值关联空间地址</p><ul><li><strong>作用</strong>: 设置键值所关联的地址空间</li><li><strong>参数:</strong> <code>key</code>类型变量</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">key_v_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_key_create(&amp;key_v, ley_v_free));<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pthread_getspecific(key_v))<br>    &#123;<br>        <span class="hljs-type">void</span> *data = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-number">4096</span>));<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != data)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc: %p\r\n&quot;</span>, data);<br>            EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_setspecific(key_v, data));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">thread_new</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_once(&amp;once_v, key_v_init));<br>    EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_key_delete(key_v));<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>完整测试示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_key_t</span> key_v;<br><span class="hljs-type">pthread_once_t</span> once_v = PTHREAD_ONCE_INIT;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ley_v_free</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != arg)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;free mem: %p\r\n&quot;</span>, arg);<br>        <span class="hljs-built_in">free</span>(arg);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%llX free!\r\n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>)pthread_self());<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">key_v_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_key_create(&amp;key_v, ley_v_free));<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pthread_getspecific(key_v))<br>    &#123;<br>        <span class="hljs-type">void</span> *data = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-number">4096</span>));<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != data)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc: %p\r\n&quot;</span>, data);<br>            EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_setspecific(key_v, data));<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc mem err!\r\n&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%llX init!\r\n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>)pthread_self());<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">new_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_once(&amp;once_v, key_v_init));<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;new thread start!\r\n&quot;</span>);<br>    pthread_cleanup_push(show_clean_cb, <span class="hljs-string">&quot;new thread clean 1&quot;</span>); <span class="hljs-comment">//安装清理函数</span><br>    pthread_cleanup_push(show_clean_cb, <span class="hljs-string">&quot;new thread clean 2&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;new thread complete!\r\n&quot;</span>);<br><br>    EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_key_delete(key_v));<br><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">int</span> <span class="hljs-type">long</span>)arg)<br>    &#123;<br>        pthread_exit((<span class="hljs-type">void</span> *)<span class="hljs-number">1</span>);<br>    &#125;<br><br>    pthread_cleanup_pop(<span class="hljs-number">0</span>);<br>    pthread_cleanup_pop(<span class="hljs-number">0</span>);<br><br>    pthread_exit((<span class="hljs-type">void</span> *)<span class="hljs-number">199</span>);<br>    <span class="hljs-comment">// return (void *)199; //使用return 清理函数不会被调用</span><br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">old_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">pthread_t</span> *tid = (<span class="hljs-type">pthread_t</span> *)arg;<br>    <span class="hljs-comment">// pthread_once(&amp;once_v, key_v_init);</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;old thread start! tid:%lX\r\n&quot;</span>, *tid);<br>    pthread_cleanup_push(show_clean_cb, <span class="hljs-string">&quot;old thread clean 1&quot;</span>);<br>    pthread_cleanup_push(show_clean_cb, <span class="hljs-string">&quot;old thread clean 2&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;old thread complete!\r\n&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (pthread_equal(*tid, pthread_self()) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is thread self!\r\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this diff thread is %lX\r\n&quot;</span>, pthread_self());<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;wait sleep to cancel!\r\n&quot;</span>);<br>    &#125;<br><br>    pthread_cleanup_pop((<span class="hljs-type">int</span> <span class="hljs-type">long</span>)arg);<br>    pthread_cleanup_pop((<span class="hljs-type">int</span> <span class="hljs-type">long</span>)arg);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread to cancel finish!\r\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)<span class="hljs-number">455</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="取消选项"><a class="markdownIt-Anchor" href="#取消选项"></a> 取消选项</h3><p>  有两个线程属性并没有包含在<code>pthread_attr_t</code>结构中, 它们是 <strong>可取消状态</strong> 和 <strong>可取消类型</strong>, 这两个属性影响着线程在响应 <code>pthread_cancel</code> 函数调用时所呈现的行为。可取消状态属性可以是 <code>PTHREAD_CANCEL_ENABLE</code> / <code>PTHREAD_CANCEL_DISABLE</code>。对于取消类型而言, 可分为 <strong>异步取消</strong> 和 <strong>推迟取消</strong>, 其中 推迟取消将在下次取消点位置退出, 而异步取消无需取消点, 任意位置直接退出。</p><ul><li><code>PTHREAD_CANCEL_DEFERRED</code>: 推迟取消(需要检测取消点)</li><li><code>PTHREAD_CANCEL_ASYNCHRONOUS</code>: 异步取消(任意点取消)</li></ul><p><strong>注意</strong>:</p><ol><li>设定取消选项时, 必须由被取消线程调用接口设定, 即此类接口设定的都是自身线程的取消类型。</li><li>当一个线程取消类型为<code>PTHREAD_CANCEL_DISABLE</code>, 此时如果触发了取消信号, 信号被挂起(未决)而不是丢失, 当重新设置<code>PTHREAD_CANCEL_ENABLE</code>, 取消动作将在下一个取消点发生。</li></ol><table><thead><tr><th>函数</th><th>备注</th></tr></thead><tbody><tr><td><code>pthread_setcancelstate</code></td><td>设置取消状态属性</td></tr><tr><td><code>pthread_setcanceltype</code></td><td>设置取消状态类型属性, 线程并非一定需要在取消点才退出</td></tr><tr><td><code>pthread_testcancel</code></td><td>测试取消状态点</td></tr></tbody></table><ul><li><p><code>pthread_setcancelstate</code> ： 设置取消状态属性</p><ul><li><strong>作用</strong>: 设置取消状态属性, 设定和获取取消状态是原子操作</li><li><strong>参数:</strong> 设定和获取的状态</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">new_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;new thread start!\r\n&quot;</span>);<br>    EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, <span class="hljs-literal">NULL</span>));<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        count_index++;<br>        <span class="hljs-keyword">if</span> (count_index &gt; <span class="hljs-number">10000000000</span>)<br>        &#123;<br>            count_index += <span class="hljs-number">100</span>;<br>            <span class="hljs-keyword">if</span> (count_index &gt;= <span class="hljs-number">20000000000</span>)<br>            &#123;<br>                EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, <span class="hljs-literal">NULL</span>));<br>            &#125;<br>        &#125;<br>        pthread_testcancel();<br>    &#125;<br>&#125;<br><br>main()<br>&#123;<br>    <span class="hljs-type">pthread_t</span> tid;<br><br>    .... <span class="hljs-comment">//线程创建和分离</span><br><br>    pthread_cancel(tid);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_setcanceltype</code> ： 设置取消状态类型属性</p><ul><li><strong>作用</strong>: 设置取消状态属性, 设定和获取取消状态是原子操作</li><li><strong>参数:</strong> 设定和获取的状态</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> count_index = <span class="hljs-number">0</span>;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">new_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;new thread start!\r\n&quot;</span>);<br>    <span class="hljs-comment">// EXEC_RETURN_ZERO(0 == pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, NULL));     //取消点取消(需要检测取消点)</span><br>    EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, <span class="hljs-literal">NULL</span>)); <span class="hljs-comment">//任一点取消(异步取消)</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        count_index++;<br>        <span class="hljs-keyword">if</span> (count_index &gt; <span class="hljs-number">10000000000</span>)<br>        &#123;<br>            count_index += <span class="hljs-number">100</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br>main()<br>&#123;<br>    <span class="hljs-type">pthread_t</span> tid;<br><br>    .... <span class="hljs-comment">//线程创建和分离</span><br><br>    pthread_cancel(tid);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>pthread_testcancel</code> ： 测试取消状态点</p><ul><li><strong>作用</strong>: 测试取消状态点, 当线程长时间不会调用到<code>POSIX</code>定义的取消点时, 可以使用该接口, 如果取消类型是无效的, 那么该接口没有任何效果。</li><li><strong>参数:</strong> 无</li><li><strong>返回</strong>： 0 表示成功 其他失败</li><li><strong>示例</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">new_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;new thread start!\r\n&quot;</span>);<br>    EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, <span class="hljs-literal">NULL</span>));<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        count_index++;<br>        <span class="hljs-keyword">if</span> (count_index &gt; <span class="hljs-number">10000000000</span>)<br>        &#123;<br>            count_index += <span class="hljs-number">100</span>;<br>            <span class="hljs-keyword">if</span> (count_index &gt;= <span class="hljs-number">20000000000</span>)<br>            &#123;<br>                EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, <span class="hljs-literal">NULL</span>));<br>            &#125;<br>        &#125;<br>        pthread_testcancel();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="线程和信号"><a class="markdownIt-Anchor" href="#线程和信号"></a> 线程和信号</h3><p>  在进程环境下关于信号的处理是复杂的, 但是加入多线程的编程模型以后, 这种信号机制将更加复杂, 因为多线程是共享进程空间, 假如一个线程修改了进程的信号掩码或者信号处理程序, 那么将影响整个进程空间，这往往是难以接收的。<br>  于是在多线程环境中引入新的机制, 每一个线程都拥有自己的信号屏蔽字, 也就是说每一个线程可以单独的过滤掉自己不感兴趣的信号, 而仅仅关心感兴趣的信号，并且相互之间是不会干扰的。不过，对于信号处理程序，整个进程共用一套信号处理程序。但是多线程引入<code>sigwait</code>机制可以和进程处理程序(<code>sigaction</code>)机制并行, 系统的实现决定信号是投递给二者之一。<br>  对于<code>sigwait</code>而言, 相比于<code>sigaction</code>信号安装程序, 其将异步转换为同步操作, 这在多线程编程中将带来极大的方便, 是的我们无需关心哪些接口函数是异步安全, 因为所有的信号都和线程共享线程的上下文。</p><table><thead><tr><th>函数</th><th>备注</th></tr></thead><tbody><tr><td><code>pthread_sigmask</code></td><td>设置取消状态属性</td></tr><tr><td><code>sigwait</code></td><td>多线程信号等待</td></tr><tr><td><code>pthread_kill</code></td><td>设置取消状态类型属性</td></tr></tbody></table><ul><li><code>pthread_sigmask</code> : 设置取消状态属性</li><li><code>sigwait</code> ： 多线程信号等待</li><li><code>pthread_kill</code> : 设置取消状态类型属性</li></ul><p><strong>示例代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXEC_RETURN_ZERO(x)              \</span><br><span class="hljs-meta">    do                                   \</span><br><span class="hljs-meta">    &#123;                                    \</span><br><span class="hljs-meta">        <span class="hljs-keyword">if</span> (!(x))                        \</span><br><span class="hljs-meta">        &#123;                                \</span><br><span class="hljs-meta">            printf(<span class="hljs-string">&quot;%s [FAIL]\r\n&quot;</span>, #x); \</span><br><span class="hljs-meta">        &#125;                                \</span><br><span class="hljs-meta">    &#125; while (0)</span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">new_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span> = (<span class="hljs-type">sigset_t</span> *)arg;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;new thread start!\r\n&quot;</span>);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> signo;<br>        <span class="hljs-type">int</span> ret = sigwait(<span class="hljs-built_in">set</span>, &amp;signo);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == ret)<br>        &#123;<br>            <span class="hljs-keyword">switch</span> (signo)<br>            &#123;<br>            <span class="hljs-keyword">case</span> SIGINT:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGINT signo!\r\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> SIGQUIT:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGQUIT signo!\r\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unknow signo!\r\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)<span class="hljs-number">199</span>; <span class="hljs-comment">//使用return 清理函数不会被调用</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">pthread_attr_t</span> init_attr;<br><br>    EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_attr_init(&amp;init_attr));<br>    EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_attr_setdetachstate(&amp;init_attr, PTHREAD_CREATE_DETACHED));<br><br>    <span class="hljs-comment">//设置信号掩码</span><br>    <span class="hljs-type">sigset_t</span> setMask;<br>    <span class="hljs-type">sigset_t</span> oldMask;<br><br>    sigemptyset(&amp;setMask);<br>    sigaddset(&amp;setMask, SIGINT);<br>    sigaddset(&amp;setMask, SIGQUIT);<br>    pthread_sigmask(SIG_BLOCK, &amp;setMask, &amp;oldMask);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != pthread_create(&amp;tid, &amp;init_attr, new_thread, (<span class="hljs-type">void</span> *)&amp;setMask))<br>    &#123;<br>        perror(<span class="hljs-string">&quot;can&#x27;t creat threda!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    EXEC_RETURN_ZERO(<span class="hljs-number">0</span> == pthread_attr_destroy(&amp;init_attr));<br><br>    pthread_sigmask(SIG_SETMASK, &amp;oldMask, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">//恢复原先的信号掩码</span><br><br>    pthread_exit(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="线程和fork"><a class="markdownIt-Anchor" href="#线程和fork"></a> 线程和fork</h3><table><thead><tr><th>函数</th><th>备注</th></tr></thead><tbody><tr><td><code>pthread_atfork</code></td><td>设置取消状态属性</td></tr></tbody></table><ul><li><code>pthread_atfork</code> ： 设置取消状态属性</li></ul><hr><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><ul><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/dc19971118/article/details/118335065">关于互斥量属性中的健壮属性</a></li><li><a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E19253-01/819-7051/6n919hpaf/index.html#sync-103">互斥锁属性</a></li><li><a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E19253-01/819-7051/index.html">多线程编程指南</a></li><li><a target="_blank" rel="noopener" href="https://blog.popkx.com/linux-multithreaded-programming-in-io-read-write-security-functions-pread-pwrite-and-read-write-what-is-the-difference-and-relat/">linux多线程编程中IO读写的安全函</a></li><li><a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-27164517-id-3282242.html">再谈互斥锁与条件变量！（终于搞清楚了啊！！！！！）</a></li><li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/422670024">谈条件变量中为什么要有互斥锁</a></li><li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/01ad36b91d39">有了互斥锁，为什么还要条件变量？</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xywams/article/details/123719528">linux条件变量使用和与信号量的区别</a></li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Linux%E5%85%A5%E9%97%A8/" class="category-chain-item">Linux入门</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%8E%9F%E5%88%9B/">#原创</a> <a href="/tags/linux/">#linux</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">#多线程</a></div></div><div class="license-box my-3"><div class="license-title"><div>linux多线程</div><div>http://example.com/2022/10/30/linux/multthread005239/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>EtcFly</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年10月30日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2024年3月5日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/10/30/jlink/config005239/" title="Jlink驱动配置"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Jlink驱动配置</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/10/18/linux/initserviceandsystemctl/diff011029/" title="Linux init、service、systemctl 三者区别"><span class="hidden-mobile">Linux init、service、systemctl 三者区别</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="waline"></div><script type="text/javascript">Fluid.utils.loadComments("#waline",(function(){Fluid.utils.createCssLink("https://lib.baomitu.com/waline/2.14.1/waline.min.css"),Fluid.utils.createScript("https://lib.baomitu.com/waline/2.14.1/waline.min.js",(function(){var i=Object.assign({serverURL:"https://etcfly.top:14000/",path:"window.location.pathname",meta:["nick","mail","link"],requiredMeta:["nick"],lang:"zh-CN",emoji:["https://unpkg.com/@waline/emojis@1.1.0/qq"],dark:'html[data-user-color-scheme="dark"]',wordLimit:0,pageSize:10},{el:"#waline",path:window.location.pathname});Waline.init(i),Fluid.utils.waitElementVisible("#waline .vcontent",()=>{var i="#waline .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://github.com/EtcFly" target="_blank" rel="nofollow noopener"><span>Copyright</span></a> <i class="iconfont icon-copyright"></i> <a href="https://etcfly.top:14100/share/yqTLFDlP/%E4%BB%97%E5%89%91%E8%B5%B0%E5%A4%A9%E6%B6%AF" target="_blank" rel="nofollow noopener"><span>2018-2024 EtcFly</span></a><div style="font-size:.85rem"><span>总访问量 <span style="color:#000" id="PVstatic">0</span> 次&nbsp</span> <span>总访客数 <span style="color:#000" id="UVstatic">0</span> 人&nbsp</span> <span>当前在线 <span style="color:#000" id="ACTstatic">0</span> 人&nbsp</span><script src="https://etcfly.top:14200/statistics" defer></script></div><div style="font-size:.85rem"><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="js/duration.js"></script></div></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener"></a> </span><span><a href="http://beian.miit.gov.cn/2023000858" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" alt="police-icon"> <span>浙ICP备2023000858号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/jquery.min.js"></script><script src="/live2d-widget/autoload.js"></script><script src="/js/star.js"></script><script src="/js/ribbon.min.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>