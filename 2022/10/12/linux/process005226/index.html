<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="EtcFly"><meta name="keywords" content=""><meta name="description" content="版权归作者所有, 转载请保留该部分声明。本文作者：EtcFly原文地址：https:&#x2F;&#x2F;etcfly.top             进程    进程是类unix系统运行的最小单元, 通常在一个unix系统中, 首先启动pid 0的进程(系统进程), 该进程直接由内核维护, 执行内核的任务调度, 系统进程启动后在用户空间运行pid 1的init进程(启动进程), 该进程负"><meta property="og:type" content="article"><meta property="og:title" content="linux系统进程"><meta property="og:url" content="http://example.com/2022/10/12/linux/process005226/"><meta property="og:site_name" content="仗剑走天涯"><meta property="og:description" content="版权归作者所有, 转载请保留该部分声明。本文作者：EtcFly原文地址：https:&#x2F;&#x2F;etcfly.top             进程    进程是类unix系统运行的最小单元, 通常在一个unix系统中, 首先启动pid 0的进程(系统进程), 该进程直接由内核维护, 执行内核的任务调度, 系统进程启动后在用户空间运行pid 1的init进程(启动进程), 该进程负"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/linux.png"><meta property="article:published_time" content="2022-10-12T00:52:26.000Z"><meta property="article:modified_time" content="2024-03-05T03:41:03.000Z"><meta property="article:author" content="EtcFly"><meta property="article:tag" content="原创"><meta property="article:tag" content="linux"><meta property="article:tag" content="多进程"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/img/linux.png"><title>linux系统进程 仗剑走天涯</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/fluid-extention.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:4},web_analytics:{enable:!0,follow_dnt:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"3AEufnWAJdp8cFODp1DXvrQU-MdYXbMMI",app_key:"mGJiL6xVvYv21ygqfynJoCyO",server_url:null,path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Strive For Dream</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="linux系统进程"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-10-12 00:52" pubdate>2022年10月12日 凌晨</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 21k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 179 分钟 </span><span id="vvdpost_container_page_pvuv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="vvdpost_value_page_pv">0</span> 次&nbsp&nbsp <i class="iconfont icon-users" aria-hidden="true"></i> <span id="vvdpost_value_page_uv">0</span> 人</span><script>console.log(window.location.pathname);var httpRequest=new XMLHttpRequest;httpRequest.open("POST","https://etcfly.top:14200/poststats",!0),httpRequest.setRequestHeader("Content-type","application/json"),httpRequest.send(JSON.stringify(window.location.pathname)),httpRequest.onreadystatechange=function(){if(4==httpRequest.readyState&&200==httpRequest.status){var e=httpRequest.responseText,t=JSON.parse(e);console.log(t.pv);var o=document.querySelector("#vvdpost_container_page_pvuv");if(console.log(o),o){var n=document.querySelector("#vvdpost_value_page_pv");console.log(n);var s=document.querySelector("#vvdpost_value_page_uv");console.log(s),s&&s&&(n.innerText=t.pv,s.innerText=t.uv,o.style.display="inline")}}}</script></div></div></div></div></div></div><script async src="https://etcfly.top:14100/script.js" data-website-id="1a5c096d-21e5-4556-99b0-28c810c9c868"></script></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">linux系统进程</h1><p class="note note-info">本文最后更新于：2024年3月5日 凌晨</p><div class="markdown-body"><div class="note note-success"><p>版权归作者所有, 转载请保留该部分声明。<br>本文作者：EtcFly<br>原文地址：<a target="_blank" rel="noopener" href="https://etcfly.top">https://etcfly.top</a></p></div><h3 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h3><blockquote><p>  进程是类<code>unix</code>系统运行的最小单元, 通常在一个<code>unix</code>系统中, 首先启动<code>pid 0</code>的进程(系统进程), 该进程直接由内核维护, 执行内核的任务调度, 系统进程启动后在用户空间运行<code>pid 1</code>的<code>init</code>进程(启动进程), 该进程负责系统其他用户服务的启动和终止。</p></blockquote><h4 id="进程空间布局"><a class="markdownIt-Anchor" href="#进程空间布局"></a> 进程空间布局</h4><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">高地址<br>  |<span class="hljs-string">--------------------------------</span>|<br>  |<span class="hljs-string">        环境变量空间             </span>|<br>  |<span class="hljs-string">--------------------------------</span>|<br>  |<span class="hljs-string">         进程栈空间              </span>|<br>  |<span class="hljs-string">--------------------------------</span>|<br>  |<span class="hljs-string">         进程堆空间              </span>|<br>  |<span class="hljs-string">--------------------------------</span>|<br>  |<span class="hljs-string">         未初始化bss             </span>|<br>  |<span class="hljs-string">--------------------------------</span>|<br>  |<span class="hljs-string">         初始化数据              </span>|<br>  |<span class="hljs-string">--------------------------------</span>|<br>  |<span class="hljs-string">           程序正文              </span>|<br>  |<span class="hljs-string">--------------------------------</span>|<br>低地址<br></code></pre></td></tr></table></figure><h4 id="fork"><a class="markdownIt-Anchor" href="#fork"></a> fork</h4><p><code>unix</code> 进程创建使用<code>fork</code>函数进行创建。但是不同系统对于<code>fork</code>的支持和实现有所区别。</p><ul><li><code>fork</code>: 子进程完全拷贝父进程环境, 包括数据段/ 堆 /栈 / 环境变量, 但是共享进程启动程序。通常此操作导致<code>fork</code>一个子进程效率较低, 因此后面引入 <strong>写时拷贝</strong> 技术, 即修改数据后拷贝源数据的副本。(父进程修改也是源数据的副本)</li><li><code>vfork</code>: 由于<code>fork</code>的低效, <code>vfork</code>针对该部分进行了优化, <code>vfork</code>一个子进程, 在未执行<code>exec</code>/ <code>exit</code> 函数调用时, 其子进程还在父进程中运行, 与父进程共享进程空间, 此时子进程修改父进程变量会直接影响到父进程。同时<code>vfork</code>较<code>fork</code>保证<code>fork</code>后首先进入子进程执行, 父进程只有在<code>exec</code>/<code>exit</code>后运行, 保证父子进程的执行时序。</li></ul><h4 id="进程终止"><a class="markdownIt-Anchor" href="#进程终止"></a> 进程终止</h4><p>终止接口有:</p><ul><li><code>exit</code>: 内部调用<code>_exit</code>, 但与此同时会在进程关闭后关闭标准<code>IO</code>流, 刷新缓存,<br>对于<code>atexit</code>注册的终止处理程序也会执行。<code>atexit</code>采用栈压缩方式。</li><li><code>_exit/_Exit</code>: 不会执行<code>atexit</code>注册的终止处理程序, 对于是否刷新标准<code>IO</code>流需要依赖具体实现， 不同实现结果不一样。</li><li></li></ul><hr><h3 id="等待子进程结束"><a class="markdownIt-Anchor" href="#等待子进程结束"></a> 等待子进程结束</h3><p>等待子进程结束主要涉及到如下几个接口:</p><ul><li><code>wait</code></li></ul><blockquote><p>  等待任意结束的子进程, 并返回子进程状态。如果没有子进程终止, 则调用<code>wait</code>函数的进程将被阻塞直到子进程发送终止信号。</p></blockquote><ul><li><code>waitpid</code></li></ul><blockquote><p>  该函数功能较<code>wait</code>接口更全。</p><ul><li><code>pid == -1</code>: 等待任意子进程</li><li><code>pid == 0</code>: 等待组<code>ID</code>等于调用进程组<code>ID</code>的任一子进程</li><li><code>pid &gt; 0</code>: 等待特定<code>ID</code>的子进程</li><li><code>pid &lt; -1</code>: 等待组<code>ID</code>等于<code>pid</code>绝对值的子进程<br>与此同时, 可以基于<code>waitpid</code>实现 <code>wait</code>, 接口功能, 需要指明其<code>option</code>常量。</li></ul></blockquote><table><thead><tr><th>常量</th><th>说明</th></tr></thead><tbody><tr><td><code>WCONTINUED</code></td><td>-</td></tr><tr><td><code>WNOHANG</code></td><td>指示如果等待的<code>pid</code>不是立即终止需要等待, 那么<code>waitpid</code>立即返回0</td></tr><tr><td><code>WUNTRACED</code></td><td></td></tr></tbody></table><ul><li><code>waitid</code></li></ul><blockquote><p>  waitid和<code>waitpid</code>类似, 提供如下常量</p></blockquote><table><thead><tr><th>常量</th><th>说明</th></tr></thead><tbody><tr><td><code>P_PID</code></td><td>等待一特定进程, <code>id</code> 包含等待子进程的进程<code>ID</code></td></tr><tr><td><code>P_PGID</code></td><td>等待特定进程组的任意子进程, <code>id</code> 包含进程组<code>id</code></td></tr><tr><td><code>P_ALL</code></td><td>等待任意子进程, 忽略<code>id</code></td></tr></tbody></table><p>以上为<code>idtype</code>类型说明, 如下为其<code>option</code>常量定义</p><table><thead><tr><th>常量</th><th>说明</th></tr></thead><tbody><tr><td><code>WCONTINUED</code></td><td>-</td></tr><tr><td><code>WEXITED</code></td><td>等待已退出进程</td></tr><tr><td><code>WNOHANG</code></td><td>如无可用子进程状态立即退出</td></tr><tr><td><code>WNOWAIT</code></td><td>不破坏子进程状态, 退出状态码可由<code>wait</code>/<code>waitpid</code>获取</td></tr><tr><td><code>WSTOPPED</code></td><td>等待一进程, 子进程已经停止但是状态未报告</td></tr></tbody></table><ul><li><code>wait3</code></li><li><code>wait4</code></li></ul><hr><h3 id="exec-进程执行"><a class="markdownIt-Anchor" href="#exec-进程执行"></a> exec 进程执行</h3><blockquote><p>  exec只是用在磁盘上的一个新程序来替代当前进程的 <strong>正文段</strong>、<strong>数据段</strong>、<strong>堆段</strong> 以及 <strong>栈段</strong>。</p></blockquote><ul><li><code>execv</code>: 传递<code>argv</code>给新进程, <code>env</code>是当前环境的<code>env</code></li><li><code>execve</code>: 传递<code>argv</code>给新进程, 特定<code>env</code>为新进程环境变量</li><li><code>execvp</code>: 传递<code>argv</code>给新进程, <code>p</code>表示<code>path</code></li><li><code>execl</code>: 传递字符串参数列表给新进程,</li><li><code>execle</code>: 传递字符串参数列表给新进程,特定<code>env</code>为新进程环境变量</li><li><code>execlp</code>: 传递字符串参数列表给新进程, <code>p</code>表示<code>path</code></li><li><code>fexecve</code>: 传递<code>fd</code>以加载新进程, 带<code>argv</code>, <code>env</code>参数</li></ul><hr><h3 id="有效用户id实际用户id设置用户id"><a class="markdownIt-Anchor" href="#有效用户id实际用户id设置用户id"></a> 有效用户ID|实际用户ID|设置用户ID</h3><p><code>linux</code> 系统用户 <code>ID</code> 有三个:</p><ul><li>实际用户 <code>ID(RUID</code>, <strong>进程特有的概念</strong>): 在开机时，你输入的账号的对应 <code>id</code> 就是实际用户 <code>uid</code>，说白了就是登录号。</li><li>有效用户<code>ID(EUID</code>, <strong>进程特有的概念</strong>): 一般和 <code>RUID</code> 相同，站在操作系统的角度上看，用于给操作系统判断某个进程是否拥有操作某个文件的权限。</li><li>保存设置用户 <code>ID(SSUID</code>, <strong>进程特有的概念</strong>): <code>EUID</code>（有效用户<code>id</code>）的备份，既然是备份，则应该是恢复的作用。<code>SSUID</code> 由 进程 <code>exec()</code> 函数保存，可以把 <code>SSUID</code> 理解为 <code>exec()</code> 函数里面的一个局部变量。<code>exec()</code> 的执行逻辑大概如下(自己猜测的，为了好理解 <code>SSUID</code> 的作用)：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 这里假设 &quot;可执行文件&quot;为/etc/passwd, 该文件的权限位-rwsr-xr-x，文件的拥有者是root</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">exec</span><span class="hljs-params">(<span class="hljs-string">&quot;可执行文件&quot;</span>)</span> &#123;<br>	SSUID = EID；<br>	进程的EID = 可执行文件用户（即root用户）;<br><br>	执行<span class="hljs-string">&quot;可执行文件&quot;</span>;<br>	<span class="hljs-comment">//此时调用本函数的进程已经拥有root权限了</span><br><br>	EID = SSUID;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>备注说明</strong>:</p><blockquote><p>  当某一个程序设置了<code>s</code>权限位, 也就是设置用户<code>ID</code>位(<code>SUID</code>), 如果这个程序拥有者为<code>root</code>, 那么进程启动后, 内核设置该进程</p><ul><li><code>RUID</code>: 设为执行该命令的用户登陆<code>ID</code></li><li><code>EUID</code>: 正常应该是复制<code>RUID</code>, 但是这里设置了<code>s</code>权限位, 内核将<code>EUID</code>设置为该程序拥有者的<code>EUID</code>。</li><li><code>SSUID</code>: 拷贝当前的<code>EUID</code>, 正常情况下此时<code>EUID</code>,<code>SSUID</code> 应该和<code>RUID</code>的值是相同的, 这里由于<code>s</code>权限位, <code>SSUID</code>和<code>EUID</code>为程序拥有者的<code>EUID</code>。<br>由于类<code>UNIX</code>系统权限检测系统都是基于<code>EUID</code>来完成的, 所有此时程序拥有该<code>EUID</code>的权限, 并可以切换到其他用户<code>ID</code>, 但是需要保证切换到的目的用户<code>ID</code>权限要小于保存设置用户<code>ID</code>的权限(<code>SSUID</code>)</li></ul></blockquote><p>文件特权类型ID有一个：</p><ul><li><code>FUID:</code> 文件的拥有者</li><li><code>FGID:</code> 文件的拥有者所在组的组<code>id</code></li><li>设置用户 <code>ID(SUID</code>, <strong>文件特有的概念</strong>): 站在文件的角度上看，文件权限有<code>r-w-x-s-t</code> 类型，其中的 <code>s</code> 表示 <code>SUID</code> 是打开状态（即可用状态）。如果一个文件的权限位里面没有 <code>s</code>，则表示 <code>SUID</code> 是关闭状态（即不可用状态）。注意：<code>SUID</code> 只能用于可执行文件，其作用是执行时修改<code>EUID</code>（有效用户<code>id</code>）</li></ul><p><strong>相关设置接口</strong></p><ul><li><code>int setuid(uid_t uid);</code> //设置实际用户<code>ID</code></li><li><code>int setgid(gid_t gid);</code> //设置实际组<code>ID</code></li><li><code>int setreuid(uid_t ruid, uid_t euid);</code> //设置实际用户<code>id</code>和有效用户<code>id</code></li><li><code>int setregid(gid_t rgid, gid_t egid);</code></li><li><code>int seteuid(uid_t uid);</code> //设置有效用户<code>ID</code></li><li><code>int setegid(gid_t gid);</code> //设置有效组<code>ID</code></li></ul><p><em><strong>总结</strong></em>：</p><ul><li><code>RUID</code>、<code>EUID</code>、<code>SSUID</code> 都是针对进程的，即站在进程的角度，即进程特有的概念。</li><li><code>SUID</code>则是针对文件的，即站在文件的角度，或者说是<code>SUID</code>是可执行文件特有的概念！为什么要修改进程的<code>EUID</code>？目的是想让进程在某一时刻能够拥有特殊的权限。</li></ul><p><img src="https://etcfly.top/Images/picture/old_image/markdown/linux/%E6%9B%B4%E6%94%B9%E6%9D%83%E9%99%90/ruid%E6%8F%8F%E8%BF%B0.png" srcset="/img/loading.gif" lazyload alt="ruid描述.png"></p><p><img src="https://etcfly.top/Images/picture/old_image/markdown/linux/%E6%9B%B4%E6%94%B9%E6%9D%83%E9%99%90/%E6%9B%B4%E6%94%B9%E7%94%A8%E6%88%B7ID%E6%96%B9%E6%B3%95.png" srcset="/img/loading.gif" lazyload alt="更改用户ID方法.png"></p><p>  对于一个普通文件，有三个<code>ID</code>，这三个<code>ID</code>对应三组权限，这三组权限控制着进程对该文件的访问权限。</p><p><img src="https://etcfly.top/Images/picture/old_image/markdown/linux/%E6%9B%B4%E6%94%B9%E6%9D%83%E9%99%90/fuid%E6%9D%83%E9%99%90%E5%AF%B9%E7%85%A7%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt></p><blockquote><p>  对于<code>linux</code>系统，某个用户登录后，创建一个文件，那个这个文件的用户<code>ID</code>就是这个用户的<code>ID</code>。该用户创建的所有的进程都可以访问这个文件，因为该用户创建的进程的实际用户ID和有效用户<code>ID</code>都是这个用户的<code>ID</code>。但是当一个用户创建的进程要去访问其他用户创建的文件的时候，就需要用到有效用户<code>ID</code>的改变，来能够有权限访问这个文件。</p></blockquote><hr><h3 id="解释文件"><a class="markdownIt-Anchor" href="#解释文件"></a> 解释文件</h3><blockquote><p>  解释文件又成为脚本文件, 是一个纯文本的文件。进程执行脚本需要通过解释器进行解释。通常如<code>/bin/bash</code>、<code>/bin/zsh</code>之类都是一个<code>shell</code>程序, 其运行<code>shell</code>解释器。</p></blockquote><h4 id="格式"><a class="markdownIt-Anchor" href="#格式"></a> 格式</h4><p><code>#! pathname [optional-argument]</code></p><p><code>#!</code>后面接着的<code>pathname</code>就是该脚本指定的解释器, <code>optional-argument</code> 是向该解释器传递的参数。除了开头以<code>#!</code>开头的第一行, 其余部分该该解释器文件正文内容。及脚本部分。</p><p><strong>注意</strong></p><ul><li><code>#!</code>和<code>pathname</code>之间的空格可有可无</li></ul><h4 id="执行流程"><a class="markdownIt-Anchor" href="#执行流程"></a> 执行流程</h4><blockquote><p>  以<code>/bin/bash</code>解释器为例, 当<code>bash</code>执行一个<code>shell</code>脚本流程如下:</p></blockquote><ul><li>首先系统默认启动一个<code>/bin/bash</code>的<code>shell</code>终端程序与用户进行交互。</li><li>用户执行脚本命令，如下:</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">╭─etcfly@etcfly-pc ~<span class="hljs-regexp">/Desktop/</span>linuxStudy<span class="hljs-regexp">/posix/</span>script ‹master●›<br>╰─$ ./show.shell<br></code></pre></td></tr></table></figure><p>其中<code>show.shell</code>脚本内容如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /usr/local/bin/show abc</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;this is a script exec&quot;</span><br></code></pre></td></tr></table></figure><ul><li><code>shell</code>解释器执行第一行脚本, 发现其指定以<code>/usr/local/bin/show</code>解释器运行, 于是启动一个新的进程运行<code>/usr/local/bin/show</code>解释器, 并附带其后面的<code>abc</code>作为参数去解析余下的脚本文件。</li></ul><h4 id="解释器传参"><a class="markdownIt-Anchor" href="#解释器传参"></a> 解释器传参</h4><p>当系统以进程运行一个解释器, 默认传参如下顺序:</p><ol><li>解释器程序名(包含绝对路径)</li><li>解释器的附带参数</li><li>进程在<code>exec</code>执行解释器的程序名</li><li>进程在<code>exec</code>执行解释器程序时参数列表的第二个参数</li><li>进程在<code>exec</code>执行解释器程序时参数列表的第三个参数<br>…<br>以此类推</li></ol><h4 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h4><p><strong>主程序script</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br><br>    <span class="hljs-keyword">if</span> ((pid = fork()) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;fork err!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> ARG_LIST <span class="hljs-string">&quot;show&quot;</span>, <span class="hljs-string">&quot;no&quot;</span>, <span class="hljs-string">&quot;yes-baby&quot;</span>, <span class="hljs-string">&quot;this is a test&quot;</span>, NULL</span><br><br>        <span class="hljs-type">char</span> *argv[] = &#123;ARG_LIST&#125;;<br>        <span class="hljs-type">char</span> *env[] = &#123;<br>            <span class="hljs-string">&quot;USER=unknow&quot;</span>,<br>            <span class="hljs-string">&quot;PATH=/tmp&quot;</span>,<br>            <span class="hljs-literal">NULL</span>,<br>        &#125;;<br><br>        execve(<span class="hljs-string">&quot;./show.shell&quot;</span>, argv, env);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exec err:%d, %s\r\n&quot;</span>, errno, strerror(errno));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">int</span> status;<br>        wait(&amp;status);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pid:%d child_pid:%d status:%d\r\n&quot;</span>, getpid(), pid, status);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Done\r\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释器程序show</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == argc)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;argc == 0\r\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;argc:%d\r\n&quot;</span>, argc);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; argv[i] != <span class="hljs-literal">NULL</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;argv[%d]:%s\r\n&quot;</span>, i, argv[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>脚本文件show.shell</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /usr/local/bin/show abc</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;this is a script exec&quot;</span><br></code></pre></td></tr></table></figure><p>执行命令:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">./<span class="hljs-keyword">script</span><br></code></pre></td></tr></table></figure><p>输出结果如下:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">argc:</span><span class="hljs-number">6</span><br>argv[<span class="hljs-number">0</span>]<span class="hljs-symbol">:/usr/local/bin/show</span><br>argv[<span class="hljs-number">1</span>]<span class="hljs-symbol">:abc</span><br>argv[<span class="hljs-number">2</span>]<span class="hljs-symbol">:</span>./show.shell<br>argv[<span class="hljs-number">3</span>]<span class="hljs-symbol">:no</span><br>argv[<span class="hljs-number">4</span>]<span class="hljs-symbol">:yes-baby</span><br>argv[<span class="hljs-number">5</span>]<span class="hljs-symbol">:this</span> is a test<br><span class="hljs-title class_">Done</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>这里由于<code>echo &quot;this is a script exec&quot;</code>这个脚本<code>show</code>解释器没法解释, 所以可以看到终端没有输出相关提示。</li></ul><hr><h3 id="进程信号"><a class="markdownIt-Anchor" href="#进程信号"></a> 进程信号</h3><h4 id="相关概念"><a class="markdownIt-Anchor" href="#相关概念"></a> 相关概念</h4><blockquote><p>  Linux下的进程本身都是以 <code>init</code> 为祖先进程的一个树状进程族谱，<code>Init</code> 进程就是这个树的根。但是为方便管理有其他层级关系进程们，又在简单的父子关系之外增加了进程组和会话的关系，从而方便进程的管理。当一个用户登录到系统时登录程序就会将登录的 <code>shell</code> 设置成一个会话首领和组长进程。简单来说是这样的一种关系 会话 &gt; 包括进程组 &gt; 包括进程 。而增加这样的额外关系仅仅是为了方便管理控制所有由关系的进程（作业）。在 <code>Linux</code> 中一个进程除了是属于他父进程的子进程外他还是一个进程组的成员，而同一进程组有这样一个特点-----信号会被传递到同一进程组的所有进程。<br>  一般情况下一个进程创建的一个子进程这个子进程就和父进程同属一个进程组，那么如果都是这样的情况那 <code>Linux</code> 中应该就只有一个进程组。所以这种情况其实是一种特殊情况。这种情况会导致不同用户的进程之间可以发送信号。所以 <code>Linux</code> 允许进程修改自己或子进程（执行 <code>exec</code> 前）的进程组和会话组，从而将进程进行又一层的分组管理。进程可以通过调用 <code>setpgid</code> 来修改自己的进程组</p></blockquote><p><strong>进程组</strong>:</p><blockquote><p>作用：对同类型的进程进行管理</p></blockquote><p><strong>进程组的诞生</strong>:</p><blockquote><ol><li>在<code>shell</code>里面执行一个<code>app</code>，在创建一个进程的同时创建一个进程组。该进程就是这个进程组的首进程。进程组只有一个进程。</li><li>如果进程调用了<code>fork</code> 函数，那么父子进程同属于一个进程组，父进程是首进程, 又称为 <strong>组长进程</strong>, 组进程<code>ID</code>等于组长进程<code>ID</code>。</li><li>在 <code>shell</code> 中通过管道执行连接起来的应用程序，两个进程同属一个进程组，第一个程序为进程组的首进程。</li></ol></blockquote><p><strong>进程组ID</strong>:</p><blockquote><p><code>pgid</code>:由首进程的<code>pid</code>决定。<br><code>ps axjf</code>查看每一个进程的<code>pgid</code>。还能看到<code>sid</code>，表示会话。</p></blockquote><p><strong>会话</strong>:</p><blockquote><p>作用：用来对进程组进行管理。进程组管理了一堆进程，而会话则管理了一堆进程组。</p></blockquote><p><strong>会话的诞生</strong>:</p><blockquote><ol><li>调用 <code>setsid</code> 函数，会创建一个新的会话，且该应用程序作为会话的首进程。</li><li>用户在终端登录之后，启动 <code>shell</code> 时，<code>linux</code> 系统会创建一个新的会话，<code>shell</code> 进程会作为会话的首进程。</li></ol></blockquote><p><strong>会话的id</strong>:</p><blockquote><p><code>sid</code>，就是会话首进程的<code>id</code>。</p></blockquote><p><strong>前台进程组</strong>:</p><blockquote><p><code>shell</code> 启动时，默认是前台进程组的首进程。<br>前台进程组的首进程会一直占用会话所关联的终端来运行，<code>shell</code> 启动了其它的应用程序时，其它应用程序会成为首进程。其应用程序执行完推出后，<code>shell</code> 才能重新使用会话所关联的终端。例如在 <code>shell</code> 中调用 <code>sleep 10</code> 指令（休眠 <code>10s</code> 的进程），一直占用终端 <code>10s</code>，<code>10s</code> 后 <code>shell</code> 进程才能重新使用终端。</p></blockquote><p><strong>后台进程组</strong>:</p><blockquote><p>后台进程组的进程在运行时不会占用终端。在 <code>shell</code> 指令后面接一个 <code>&quot;&amp;&quot;</code>，表示让他在后台运行。<code>ctrl + z</code> 可以让前台进程组的进程进入后台进程组，并停止执行。<code>jobs</code> 命令可以查看后台进程组有哪些，获取到<code>job id</code>后，利用 <code>fg + job_id</code> 将后台进程组切换到前台进程组来运行。</p></blockquote><p><strong>作业</strong>:</p><blockquote><p>作业是用户需要计算机完成的某项任务，是要求计算机所做工作的集合。一个作业通常包括几个进程，几个进程共同完成一个任务，即作业。用户提交作业以后，当作业被调度，系统会为作业创建进程，一个进程无法完成时，系统会为这个进程创建子进程。</p></blockquote><p><strong>作业控制的3种形式</strong></p><ul><li>支持作业控制的<code>shell</code></li><li>内核中的终端驱动程序必须支持作业控制</li><li>必须提供对某些作业控制信号的支持</li></ul><p><strong>信号处理</strong>：<br>可以键入下面的信号发送给作业</p><ul><li>中断字符（一般采用 <code>DELETE</code> 或 <code>Ctrl-C</code> ）产生 <code>SIGINT</code> 信号</li><li>退出字符（一般采用 <code>Ctrl-\</code> ）产生 <code>SIGQUIT</code> 信号</li><li>挂起字符（一般采用 <code>Ctrl-Z</code>）产生 <code>SIGTSTP</code> 信号</li></ul><hr><p><strong>信号的相关概念</strong>:</p><ul><li><em><strong>递送</strong></em> : 实际执行信号的处理动作称为信号的递达</li><li><em><strong>未决</strong></em> : 信号从产生到递达之间的过程叫做信号的未决</li><li><em><strong>阻塞</strong></em> : 进程可以选择阻塞某个信号, 被阻塞的信号产生时将保持在未决状态, 直到进程解除该信号的屏蔽, 才执行递达动作.</li><li><em><strong>阻塞和忽略的不同</strong></em> : 信号被阻塞就不会被递达, 而信号被忽略是该信号递达的一种方式</li><li><em><strong>信号递达的几种方式</strong></em> : 忽略, 默认处理, 自定义</li></ul><hr><p>进程信号符发送规则:</p><ul><li>对于超级用户: 可以将信号发送给任意一个进程</li><li>对于非超级用户: 发送进程的实际用户<code>ID</code>或者有效用户<code>ID</code>必须等于接收者的实际用户<code>ID</code>或有效用户<code>ID</code>。<ul><li>如果支持<code>_POSIX_SAVED_IDS</code>, 则检查接受者的保存设置用户<code>ID</code>(不是有效用户<code>ID</code>)。</li><li>权限检查时, 如果发送信号时<code>SIGCONT</code>, 则进程可将它发送给属于同一会话的任意其他进程。</li></ul></li></ul><hr><h3 id="进程信号api"><a class="markdownIt-Anchor" href="#进程信号api"></a> 进程信号API</h3><table><thead><tr><th style="text-align:left"><code>API</code></th><th style="text-align:left">作用</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:left"><code>abort</code></td><td style="text-align:left">使程序异常终止</td><td>-</td></tr><tr><td style="text-align:left"><code>kill</code></td><td style="text-align:left">向特定进程发送信号</td><td>-</td></tr><tr><td style="text-align:left"><code>signal</code></td><td style="text-align:left">信号安装函数</td><td>-</td></tr><tr><td style="text-align:left"><code>raise</code></td><td style="text-align:left">发送一个信号</td><td>-</td></tr><tr><td style="text-align:left"><code>alarm</code></td><td style="text-align:left">闹钟安装函数</td><td>-</td></tr><tr><td style="text-align:left"><code>pause</code></td><td style="text-align:left">等待信号</td><td>-</td></tr><tr><td style="text-align:left"><code>sigemptyset</code></td><td style="text-align:left">清空信号集</td><td>-</td></tr><tr><td style="text-align:left"><code>sigfillset</code></td><td style="text-align:left">填充信号集</td><td>-</td></tr><tr><td style="text-align:left"><code>sigaddset</code></td><td style="text-align:left">填充某一位信号</td><td>-</td></tr><tr><td style="text-align:left"><code>sigdelset</code></td><td style="text-align:left">清空某一位信号</td><td>-</td></tr><tr><td style="text-align:left"><code>sigismember</code></td><td style="text-align:left">判断信号某一位是否置起</td><td>-</td></tr><tr><td style="text-align:left"><code>sigprocmask</code></td><td style="text-align:left">设置信号屏蔽字</td><td>-</td></tr><tr><td style="text-align:left"><code>sigpending</code></td><td style="text-align:left">获取当前未决信号</td><td>-</td></tr><tr><td style="text-align:left"><code>sigaction</code></td><td style="text-align:left">检查修改指定信号关联处理函数动作</td><td>-</td></tr><tr><td style="text-align:left"><code>sigsetjmp</code></td><td style="text-align:left">记录跳转进程环境</td><td>-</td></tr><tr><td style="text-align:left"><code>siglongjmp</code></td><td style="text-align:left">跳转到记录环境</td><td>-</td></tr><tr><td style="text-align:left"><code>sigsuspend</code></td><td style="text-align:left">屏蔽特定信号并挂起进程等待</td><td>-</td></tr><tr><td style="text-align:left"><code>system</code></td><td style="text-align:left">提供基于<code>shell</code>命令行的程序调用</td><td>-</td></tr><tr><td style="text-align:left"><code>sleep</code></td><td style="text-align:left">系统睡眠延迟函数</td><td>-</td></tr><tr><td style="text-align:left"><code>nanosleep</code></td><td style="text-align:left">系统延迟函数(<code>ns</code>)</td><td>-</td></tr><tr><td style="text-align:left"><code>clock_nanosleep</code></td><td style="text-align:left">系统延迟函数(<code>ns</code>)</td><td>-</td></tr><tr><td style="text-align:left"><code>sigqueue</code></td><td style="text-align:left">信号队列(信号发送功能)</td><td>-</td></tr><tr><td style="text-align:left"><code>psignal</code></td><td style="text-align:left">标准信号名称转换</td><td>-</td></tr><tr><td style="text-align:left"><code>psiginfo</code></td><td style="text-align:left">标准信号名称转换</td><td>-</td></tr><tr><td style="text-align:left"><code>strsignal</code></td><td style="text-align:left">标准信号名称转换</td><td>-</td></tr></tbody></table><h4 id="psignal-psiginfo"><a class="markdownIt-Anchor" href="#psignal-psiginfo"></a> psignal / psiginfo</h4><p><strong>作用</strong>: 标准信号名称转换<br><strong>特点</strong>:<br><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    psignal(SIGINT, <span class="hljs-string">&quot;signal init&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str:%s\r\n&quot;</span>, strsignal(SIGSTOP));<br><br>    <span class="hljs-type">char</span> str[<span class="hljs-number">20</span>];<br>    sig2str(SIGINT, &amp;str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sig2str:%s\r\n&quot;</span>, str);<br>    <span class="hljs-type">int</span> v = <span class="hljs-number">0</span>;<br>    str2sig(<span class="hljs-string">&quot;Interrupt&quot;</span>, &amp;v);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;v:%d\r\n&quot;</span>, v);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Down!\r\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="sigqueue"><a class="markdownIt-Anchor" href="#sigqueue"></a> sigqueue</h4><p><strong>作用</strong>: 信号队列(信号发送功能)， 其和<code>kill</code>函数功能类似, 但是可以带参数<br><strong>特点</strong>:</p><ul><li>信号发送后, 未退出信号处理函数, 其他信号会通过队列进行缓存</li></ul><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">act</span>;</span><br><br>    sigemptyset(&amp;act.sa_mask);<br>    act.sa_flags = SA_SIGINFO;<br>    act.sa_sigaction = signal_cb_ext;<br>    sigaction(SIGINT, &amp;act, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">sigval</span> <span class="hljs-title">valsig</span>;</span><br><br>        valsig.sival_ptr = <span class="hljs-literal">NULL</span>;<br>        valsig.sival_int = i;<br>        sigqueue(getpid(), SIGINT, valsig); <span class="hljs-comment">//发送信号, 相当于kill一样</span><br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Down!\r\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="sleep-nanosleep-clock_nanosleep"><a class="markdownIt-Anchor" href="#sleep-nanosleep-clock_nanosleep"></a> sleep / nanosleep / clock_nanosleep</h4><p><strong>作用</strong>: 设置系统延时时间<br><strong>特点</strong>:</p><ul><li>三种延时都是基于墙上时间, 但是提供不同的延时精度。<ul><li><code>sleep</code>: 提供秒级延时</li><li><code>nanosleep</code>/<code>clock_nanosleep</code>:提供<code>ns</code>级别的延迟</li></ul></li><li><code>clock_nanosleep</code>:可以选择相对定时或者绝对定时。</li><li>延时函数被唤醒存在两种情况:<ul><li>系统运行墙上时间到达。</li><li>被信号唤醒</li></ul></li></ul><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">signal_cb</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv signal %d\r\n&quot;</span>, signo);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">time_t</span> now_time, prev_time;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">val</span>, <span class="hljs-title">nowval</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timezone</span> <span class="hljs-title">zone</span>;</span><br><br>    signal(SIGQUIT, signal_cb);<br>    gettimeofday(&amp;val, <span class="hljs-literal">NULL</span>);<br>    prev_time = time(<span class="hljs-literal">NULL</span>);<br>    sleep(<span class="hljs-number">5</span>); \\睡眠期间可以尝试ctrl+\唤醒sleep<br>    now_time = time(<span class="hljs-literal">NULL</span>);<br>    gettimeofday(&amp;nowval, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Down %ld:%ld\r\n&quot;</span>, nowval.tv_sec - val.tv_sec,<br>           nowval.tv_usec - nowval.tv_usec);<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span> <span class="hljs-title">spec</span>, <span class="hljs-title">remain</span>;</span><br><br>    spec.tv_sec = <span class="hljs-number">1</span>;<br>    spec.tv_nsec = <span class="hljs-number">0</span>;<br>    nanosleep(&amp;spec, &amp;remain); <span class="hljs-comment">// remain表示被信号终止还剩多长时间延时   spec表示要求的延时</span><br><br>    system(<span class="hljs-string">&quot;date&quot;</span>);<br>    clock_nanosleep(CLOCK_REALTIME, <span class="hljs-number">0</span>, &amp;spec, <span class="hljs-literal">NULL</span>);<br>    system(<span class="hljs-string">&quot;date&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="system"><a class="markdownIt-Anchor" href="#system"></a> system</h4><p><strong>作用</strong>: 系统调用执行<br><strong>特点</strong>:</p><ul><li>函数会<code>fork</code>子进程执行, 并且会自动处理<code>SIGINT</code>、<code>SIGQUIT</code>、<code>SIGCHLD</code>信号。前两个信号会被忽略, 后一个信号会被阻塞。</li></ul><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> v = system(<span class="hljs-string">&quot;./test&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Down:%d\r\n&quot;</span>, v);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="sigsuspend"><a class="markdownIt-Anchor" href="#sigsuspend"></a> sigsuspend</h4><p><strong>作用</strong>: 设置信号掩码并阻塞等待<br><strong>特点</strong>:</p><ul><li>函数调用后, 接口阻塞直到有信号返回。</li><li>函数返回后会自动恢复调用前进程的掩码值。</li></ul><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">show_mask</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">sigset_t</span> now_setmask;<br>    <span class="hljs-keyword">if</span> (sigprocmask(<span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, &amp;now_setmask) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;signal promask err!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;INT SIGNAL: &quot;</span>);<br>    <span class="hljs-keyword">if</span> (sigismember(&amp;now_setmask, SIGINT))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGINT &quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sigismember(&amp;now_setmask, SIGUSR1))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGUSR1 &quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sigismember(&amp;now_setmask, SIGUSR2))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGUSR2 &quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">sig_cb</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv signal:%d\r\n&quot;</span>, signo);<br>    show_mask();<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    signal(SIGINT, sig_cb);<br><br>    <span class="hljs-type">sigset_t</span> now, old, wait;<br>    sigemptyset(&amp;wait);<br>    sigaddset(&amp;wait, SIGUSR1);<br><br>    sigemptyset(&amp;now);<br>    sigaddset(&amp;now, SIGINT);<br>    sigprocmask(SIG_BLOCK, &amp;now, &amp;old);<br><br>    <span class="hljs-keyword">for</span> (;;)<br>    &#123;<br>        show_mask();<br>        sigsuspend(&amp;wait); <span class="hljs-comment">//设置新的掩码值并等待</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get finish!\r\n&quot;</span>); <span class="hljs-comment">//旧的掩码值恢复</span><br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Down\r\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="sigsetjmp-siglongjmp"><a class="markdownIt-Anchor" href="#sigsetjmp-siglongjmp"></a> sigsetjmp / siglongjmp</h4><p><strong>作用</strong>: 设置信号跳转<br><strong>特点</strong>:</p><ul><li><code>sigsetjmp</code> 保存进程掩码值和当前进程环境。</li><li><code>setjmp</code> 仅仅保存进程环境, 掩码值不做保存。</li></ul><p><strong>原型</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">setjmp</span><span class="hljs-params">(jmp_buf env)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigsetjmp</span><span class="hljs-params">(sigjmp_buf env, <span class="hljs-type">int</span> savesigs)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">longjmp</span><span class="hljs-params">(jmp_buf env, <span class="hljs-type">int</span> val)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">siglongjmp</span><span class="hljs-params">(sigjmp_buf env, <span class="hljs-type">int</span> val)</span>;<br></code></pre></td></tr></table></figure><p><code>sigjmp_buf</code>通过<code>typedef</code>定义如下：<br><code>typedef struct __jmp_buf_tag sigjmp_buf[1];</code><br>其表示定义一个 <code>sigjmp_buf</code> 的指针, 该指针类型是<code>struct __jmp_buf_tag [1]</code>,一个指向数组长度为1的指针, 相当于数组的基地址。</p><ul><li><code>setjmp</code> 和 <code>sigsetjmp</code> 相比少了一个参数, 该参数指示是否保存当前进程掩码值。</li></ul><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> sigjmp_buf jmpbuf;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">show_mask</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">sigset_t</span> now_setmask;<br>    <span class="hljs-keyword">if</span> (sigprocmask(<span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, &amp;now_setmask) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;signal promask err!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sigismember(&amp;now_setmask, SIGINT))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;INT SIGNAL SETMASK!\r\n&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">sig_cb</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv signal:%d\r\n&quot;</span>, signo);<br>    <span class="hljs-type">sigset_t</span> now_setmask;<br><br>    <span class="hljs-keyword">if</span> (sigprocmask(<span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, &amp;now_setmask) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;signal promask err!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sigismember(&amp;now_setmask, SIGINT))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;INT SIGNAL SETMASK!\r\n&quot;</span>);<br>        siglongjmp(jmpbuf, <span class="hljs-number">1</span>); <span class="hljs-comment">//指定sigsetjmp返回值</span><br>        <span class="hljs-comment">// longjmp(jmpbuf, 1);</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-comment">// if (setjmp(jmpbuf) != 0)//可替代为setjmp函数, 不保存进程掩码值</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     show_mask();</span><br>    <span class="hljs-comment">//     perror(&quot;setjump signal err!&quot;);</span><br>    <span class="hljs-comment">//     exit(0);</span><br>    <span class="hljs-comment">// &#125;</span><br><br>    <span class="hljs-keyword">if</span> (sigsetjmp(jmpbuf, <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>)<span class="hljs-comment">//第一次返回0表示成功, siglongjmp返回值由该函数指定</span><br>    &#123;<br>        show_mask();<br>        perror(<span class="hljs-string">&quot;setjump signal err!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    signal(SIGINT, sig_cb);<br><br>    <span class="hljs-keyword">for</span> (;;)<br>    &#123;<br>        pause();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get finish!\r\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Down\r\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="sigaction"><a class="markdownIt-Anchor" href="#sigaction"></a> sigaction</h4><p><strong>作用</strong>: 修改指定信号的关联动作<br><strong>函数原型</strong>:</p><p><code>int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</code></p><ul><li><code>signum</code>: 信号编号</li><li><code>act</code>: 设定的信号动作和掩码</li><li><code>oact</code>:设定前该信号的上一个动作信息</li><li>当设置了<code>SA_SIGINFO</code>, 则优先使用<code>sa_sigaction</code>信号函数。</li></ul><p><code>struct sigaction</code> 信号结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined __USE_POSIX199309 || defined __USE_XOPEN_EXTENDED</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">      &#123;</span><br>	        <span class="hljs-type">__sighandler_t</span> sa_handler;<br>	        <span class="hljs-type">void</span> (*sa_sigaction) (<span class="hljs-type">int</span>, <span class="hljs-type">siginfo_t</span> *, <span class="hljs-type">void</span> *);<br>      &#125; __sigaction_handler;<br><br>    <span class="hljs-meta"># <span class="hljs-keyword">define</span> sa_handler	__sigaction_handler.sa_handler</span><br>    <span class="hljs-meta"># <span class="hljs-keyword">define</span> sa_sigaction	__sigaction_handler.sa_sigaction</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-type">__sighandler_t</span> sa_handler;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-type">__sigset_t</span> sa_mask;<br>    <span class="hljs-type">int</span> sa_flags;<br>    <span class="hljs-type">void</span> (*sa_restorer) (<span class="hljs-type">void</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>sa_flags</code>位定义如下:</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>SA_INTERRUPT</code></td><td>由此信号中断的系统调用不自动重启</td></tr><tr><td><code>SA_NOCLDSTOP</code></td><td>当信号是<code>SIGCHLD</code>，作业控制子进程暂停时不产生此信号, 终止时仍旧产生</td></tr><tr><td><code>SA_NOCLDWAIT</code></td><td>当信号是<code>SIGCHLD</code>, 则调用子进程终止时不产生僵尸进程, 若调用进程随后调用<code>wait</code>,则阻塞直到所有子进程终止</td></tr><tr><td><code>SA_NODEFER</code></td><td>当捕获到该信号后, 在执行信号处理程序时，系统不自动阻塞此信号</td></tr><tr><td><code>SA_ONSTACK</code></td><td></td></tr><tr><td><code>SA_RESETHAND</code></td><td>在此信号捕获函数入口，将此信号处理方式重置为<code>SIG_DFL</code>, 并清除<code>SA_SIGINFO</code>标志</td></tr><tr><td><code>SA_RESTART</code></td><td>由此信号中断的系统调用自动重启</td></tr><tr><td><code>SA_SIGINFO</code></td><td>此选项对信号处理函数提供了附加信号</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">siginfo_t</span> &#123;<br>    <span class="hljs-type">int</span>      si_signo;     <span class="hljs-comment">/* Signal number */</span><br>    <span class="hljs-type">int</span>      si_errno;     <span class="hljs-comment">/* An errno value */</span><br>    <span class="hljs-type">int</span>      si_code;      <span class="hljs-comment">/* Signal code */</span><br>    <span class="hljs-type">int</span>      si_trapno;    <span class="hljs-comment">/* Trap number that caused</span><br><span class="hljs-comment">                             hardware-generated signal</span><br><span class="hljs-comment">                             (unused on most architectures) */</span><br>    <span class="hljs-type">pid_t</span>    si_pid;       <span class="hljs-comment">/* Sending process ID */</span><br>    <span class="hljs-type">uid_t</span>    si_uid;       <span class="hljs-comment">/* Real user ID of sending process */</span><br>    <span class="hljs-type">int</span>      si_status;    <span class="hljs-comment">/* Exit value or signal */</span><br>    <span class="hljs-type">clock_t</span>  si_utime;     <span class="hljs-comment">/* User time consumed */</span><br>    <span class="hljs-type">clock_t</span>  si_stime;     <span class="hljs-comment">/* System time consumed */</span><br>    <span class="hljs-type">sigval_t</span> si_value;     <span class="hljs-comment">/* Signal value */</span><br>    <span class="hljs-type">int</span>      si_int;       <span class="hljs-comment">/* POSIX.1b signal */</span><br>    <span class="hljs-type">void</span>    *si_ptr;       <span class="hljs-comment">/* POSIX.1b signal */</span><br>    <span class="hljs-type">int</span>      si_overrun;   <span class="hljs-comment">/* Timer overrun count;</span><br><span class="hljs-comment">                             POSIX.1b timers */</span><br>    <span class="hljs-type">int</span>      si_timerid;   <span class="hljs-comment">/* Timer ID; POSIX.1b timers */</span><br>    <span class="hljs-type">void</span>    *si_addr;      <span class="hljs-comment">/* Memory location which caused fault */</span><br>    <span class="hljs-type">long</span>     si_band;      <span class="hljs-comment">/* Band event (was int in</span><br><span class="hljs-comment">                             glibc 2.3.2 and earlier) */</span><br>    <span class="hljs-type">int</span>      si_fd;        <span class="hljs-comment">/* File descriptor */</span><br>    <span class="hljs-type">short</span>    si_addr_lsb;  <span class="hljs-comment">/* Least significant bit of address</span><br><span class="hljs-comment">                             (since Linux 2.6.32) */</span><br>    <span class="hljs-type">void</span>    *si_lower;     <span class="hljs-comment">/* Lower bound when address violation</span><br><span class="hljs-comment">                             occurred (since Linux 3.19) */</span><br>    <span class="hljs-type">void</span>    *si_upper;     <span class="hljs-comment">/* Upper bound when address violation</span><br><span class="hljs-comment">                             occurred (since Linux 3.19) */</span><br>    <span class="hljs-type">int</span>      si_pkey;      <span class="hljs-comment">/* Protection key on PTE that caused</span><br><span class="hljs-comment">                             fault (since Linux 4.6) */</span><br>    <span class="hljs-type">void</span>    *si_call_addr; <span class="hljs-comment">/* Address of system call instruction</span><br><span class="hljs-comment">                             (since Linux 3.5) */</span><br>    <span class="hljs-type">int</span>      si_syscall;   <span class="hljs-comment">/* Number of attempted system call</span><br><span class="hljs-comment">                             (since Linux 3.5) */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> si_arch;  <span class="hljs-comment">/* Architecture of attempted system call</span><br><span class="hljs-comment">                             (since Linux 3.5) */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点</strong>:</p><ul><li>单独获取设定前结果, 如下：<br><code>sigaction(SIGINT, NULL, &amp;oact)</code>, 只能获取<code>SIGINT</code>信号的设定值, 并非进程值。</li><li>信号设定后, 只有进入信号服务函数前才设定相应的掩码位</li><li>信号进入信号处理函数后在退出服务函数前, 内核自动将该信号加到该进程的信号屏蔽位。</li></ul><p><strong>示例</strong></p><ul><li><code>sigaction</code> 函数操作只针对单一信号起作用。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">show_signal_set</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span><br>&#123;<br>    <span class="hljs-type">bool</span> show_flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; _NSIG; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> status;<br>        status = sigismember(<span class="hljs-built_in">set</span>, i);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == status)<br>        &#123;<br>            show_flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;index[%d] -- &gt; status[%d]\r\n&quot;</span>, i, status);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (show_flag)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;---------  signal show end  ----------\r\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;---------- nothing to show -----------\r\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">signal_cb</span><span class="hljs-params">(<span class="hljs-type">int</span> igno)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----  end recv signal :%d ----- \r\n&quot;</span>, igno);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sig_cb_old</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span><br>&#123;<br>&#125;<br><span class="hljs-comment">// sigprocmask</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">act</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">oact</span>;</span><br><br>    <span class="hljs-type">sigset_t</span> mask, old_mask;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sig_old:%p sig_new:%p\r\n&quot;</span>, sig_cb_old, signal_cb);<br><br>    signal(SIGINT, sig_cb_old);<br>    sigemptyset(&amp;mask);<br>    sigaddset(&amp;mask, SIGINT);<br>    sigaddset(&amp;mask, SIGSEGV);<br>    sigprocmask(SIG_BLOCK, &amp;mask, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">//故意设定两个阻塞信号</span><br><br>    sigemptyset(&amp;act.sa_mask);<br>    sigaddset(&amp;act.sa_mask, SIGTSTP); <span class="hljs-comment">//SIGSTP信号只在进入信号处理程序前才被设置</span><br>    act.sa_handler = signal_cb;<br>    act.sa_flags = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (sigaction(SIGINT, &amp;act, &amp;oact) != <span class="hljs-number">0</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;set sigaction err!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    show_signal_set(&amp;oact.sa_mask);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;old_cb:%p\r\n&quot;</span>, oact.sa_handler); <span class="hljs-comment">//oact返回的信息和设定前完全一致</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Done\r\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sig_old:<span class="hljs-number">0x562cfc2789fb</span> sig_new:<span class="hljs-number">0x562cfc2789d7</span><br><span class="hljs-keyword">index</span>[<span class="hljs-number">2</span>] <span class="hljs-comment">-- &gt; status[1]</span><br><span class="hljs-comment">---------  signal show end  ----------</span><br>old_cb:<span class="hljs-number">0x562cfc2789fb</span><br>Done<br></code></pre></td></tr></table></figure><p>可以看出设定<code>SIGINT</code> 信号后, 其返回的得到信息是设定前的结果, 其次, 返回的掩码位也和设定前阻塞的掩码位一致。</p><hr><h4 id="sigpending"><a class="markdownIt-Anchor" href="#sigpending"></a> sigpending</h4><p><strong>作用</strong>: 查看所有未决信号<br><strong>特点</strong>:</p><ul><li>查看所有未决信号</li></ul><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">show_signal_set</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; _NSIG; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> status;<br>        status = sigismember(<span class="hljs-built_in">set</span>, i);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;index[%d] -- &gt; status[%d]\r\n&quot;</span>, i, status);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----------------------------------------------\r\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">signal_cb</span><span class="hljs-params">(<span class="hljs-type">int</span> igno)</span><br>&#123;<br>    <span class="hljs-type">sigset_t</span> <span class="hljs-built_in">set</span>;<br>    <span class="hljs-keyword">if</span> (sigpending(&amp;<span class="hljs-built_in">set</span>) == <span class="hljs-number">0</span>)<br>    &#123;<br>        show_signal_set(&amp;<span class="hljs-built_in">set</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get sigpending err!\r\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv signal :%d\r\n&quot;</span>, igno);<br>&#125;<br><span class="hljs-comment">// sigprocmask</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (signal(SIGINT, signal_cb) == SIG_ERR)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;signal stop set err!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (signal(SIGQUIT, signal_cb) == SIG_ERR)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;signal stop set err!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-type">sigset_t</span> mask, old_mask;<br><br>    sigemptyset(&amp;mask);<br>    sigaddset(&amp;mask, SIGINT);<br>    <span class="hljs-keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;mask, &amp;old_mask) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;set mask err!\r\n&quot;</span>);<br>    &#125;<br><br>    pause();<br>    <span class="hljs-comment">//首先执行ctrl+c, SIGINT信号被阻塞挂起, 在执行ctrl+\, 查看所有未决信号</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Done\r\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="sigprocmask"><a class="markdownIt-Anchor" href="#sigprocmask"></a> sigprocmask</h4><p><strong>作用</strong>: 设置特定信号的掩码<br><strong>特点</strong>:</p><ul><li>相应信号掩码被设置后, 该信号会被阻塞, 阻塞期间发生信号, 在阻塞结束会被触发一次或者多次, 具体取决于系统是否实现阻塞期间的信号队列。</li></ul><p><strong>函数原型:</strong><br><code>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</code></p><ul><li><code>set</code>: 将要设置的信号掩码位</li><li><code>old</code>: 设置前的信号掩码位</li><li><code>how</code>: 功能参数</li></ul><table><thead><tr><th style="text-align:left"><code>how</code> 类型</th><th>注释</th></tr></thead><tbody><tr><td style="text-align:left"><code>SIG_SETMASK</code></td><td>进程掩码位完全等于 <code>set</code> 掩码位</td></tr><tr><td style="text-align:left"><code>SIG_BLOCK</code></td><td>进程掩码位 <code>|</code> <code>set</code>掩码位为进程最终掩码位</td></tr><tr><td style="text-align:left"><code>SIG_UNBLOCK</code></td><td>进程掩码位 <code>&amp;</code> <code>set</code>掩码位为进程最终掩码位</td></tr></tbody></table><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">signal_cb</span><span class="hljs-params">(<span class="hljs-type">int</span> igno)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv signal :%d\r\n&quot;</span>, igno);<br>&#125;<br><span class="hljs-comment">// sigprocmask</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (signal(SIGINT, signal_cb) == SIG_ERR)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;signal stop set err!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (signal(SIGQUIT, signal_cb) == SIG_ERR)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;signal stop set err!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-type">sigset_t</span> mask, old_mask;<br><br>    sigemptyset(&amp;mask);<br>    sigaddset(&amp;mask, SIGINT);<br>    <span class="hljs-keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;mask, &amp;old_mask) != <span class="hljs-number">0</span>) <span class="hljs-comment">//设置SIGINT信号掩码</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;set mask err!\r\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//这里存在临界区, 这个位置如果发生信号, pause后面可能会锁死</span><br>    pause();<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Done\r\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="sigemptysetsigfillsetsigaddsetsigdelset"><a class="markdownIt-Anchor" href="#sigemptysetsigfillsetsigaddsetsigdelset"></a> sigemptyset/sigfillset/sigaddset/sigdelset</h4><p><strong>作用</strong>: 基本信号集的设置<br><strong>特点</strong>:</p><ul><li>设置单一的<code>sigset_t</code>信号集。</li></ul><p><code>sigset_t</code>信号集原理其实就是一个基本类型数组,如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _SIGSET_NWORDS (1024 / (8 * sizeof (unsigned long int)))</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> __val[_SIGSET_NWORDS];<br>&#125; <span class="hljs-type">__sigset_t</span>;<br></code></pre></td></tr></table></figure><p>实际<code>sigaddset</code>, <code>sigdelset</code>, <code>sigemptyset</code>, <code>sigfillset</code>都是对该数组进行填充。</p><ul><li><p><code>sigemptyset</code><br>其内部原理基本如下:<br><code>memset(mask, 0, sizeof(sigset_t))</code></p></li><li><p><code>sigfillset</code><br>其内部原理基本如下:<br><code>memset(mask, 0xff, sizeof(sigset_t))</code></p></li><li><p><code>sigaddset</code><br>其内部原理基本如下:<br><code>mask.__val[igno/sizeof(unsigned int)] |= (1&lt;&lt;(ingo % sizeof(unsigned int)))</code></p></li><li><p><code>sigdelset</code><br>其内部原理基本如下:<br><code>mask.__val[igno/sizeof(unsigned int)] &amp;= ~(1&lt;&lt;(ingo % sizeof(unsigned int)))</code></p></li><li><p><code>sigismember</code><br>其内部原理基本如下:<br><code>return (mask.__val[igno/sizeof(unsigned int)] &amp; (1&lt;&lt;(ingo % sizeof(unsigned int))))</code></p></li></ul><hr><h4 id="raise"><a class="markdownIt-Anchor" href="#raise"></a> raise</h4><p><strong>作用</strong>: 向自身调用进程发送一个信号<br><strong>特点</strong>:</p><ul><li><code>raise</code>调用返回只有信号处理程序返回才会返回</li><li><code>return</code>结果0表示正常, 否则不正确</li></ul><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">signal_cb</span><span class="hljs-params">(<span class="hljs-type">int</span> igno)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv signal :%d\r\n&quot;</span>, igno);<br>&#125;<br><span class="hljs-comment">// kill</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (signal(SIGINT, signal_cb) == SIG_ERR)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;signal stop set err!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (signal(SIGQUIT, signal_cb) == SIG_ERR)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;signal stop set err!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    raise(SIGQUIT);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Done\r\n&quot;</span>); <span class="hljs-comment">//无法执行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="kill"><a class="markdownIt-Anchor" href="#kill"></a> kill</h4><p><strong>作用</strong>: 向特定进程发送一个信号<br><strong>特点</strong>:</p><ul><li>常用的有用信号如:<br><code>HUP INT QUIT ILL TRAP ABRT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERM 16 CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH POLL 30 SYS</code></li><li><code>kill</code>如果有信号处理函数, 只有等信号处理函数返回才会返回</li><li>除了指定<code>pid</code>外, 其他和<code>raise</code>相同</li></ul><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">signal_cb</span><span class="hljs-params">(<span class="hljs-type">int</span> igno)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv signal :%d\r\n&quot;</span>, igno);<br>&#125;<br><span class="hljs-comment">// kill</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (signal(SIGINT, signal_cb) == SIG_ERR)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;signal stop set err!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (signal(SIGQUIT, signal_cb) == SIG_ERR)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;signal stop set err!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    kill(getpid(), SIGQUIT);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Done\r\n&quot;</span>); <span class="hljs-comment">//无法执行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="abort"><a class="markdownIt-Anchor" href="#abort"></a> abort</h4><p><strong>作用</strong>: 该<code>API</code>会向进程发送<code>SIGABRT</code>信号, 并使程序异常终止<br><strong>特点</strong></p><ul><li>无法设置忽略 或者阻塞 <code>SIGABRT</code> 信号, 即使调用 <code>signal</code> 信号设置函数设置成功。</li><li>该信号从信号捕获处理函数(如果有)返回后不会返回原进程继续执行。<code>abort</code>内部执行了<code>exit</code>操作</li><li>无法忽略和阻塞<code>SIGABRT</code>信号仅仅针对特定接口, 对于<code>kill</code> 发送的 <code>SIGABRT</code> 信号, 是可以被阻塞的。</li><li>由于内部原理是调用<code>exit</code>退出的, 其会在进程关闭前关闭所有涉及的文件, 但是并不保证刷新文件流, 所有程序需要在进程终止前自己刷新流。</li></ul><p><strong>示例</strong></p><ol><li>设置信号忽略后无法忽略</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// abort</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (signal(SIGABRT, SIG_IGN) == SIG_ERR)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;signal set err!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;abort signal set ok\r\n&quot;</span>);<br>    <span class="hljs-built_in">abort</span>();            <span class="hljs-comment">//这里会直接退出进程</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Done\r\n&quot;</span>); <span class="hljs-comment">//无法执行</span><br>    fflush(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、阻塞信号依旧执行捕获处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// abort</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">signal_cb</span><span class="hljs-params">(<span class="hljs-type">int</span> igno)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv signal:%d\r\n&quot;</span>, igno); <span class="hljs-comment">//依旧执行</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">sigset_t</span> igno;<br><br>    sigemptyset(&amp;igno);<br>    sigaddset(&amp;igno, SIGABRT);<br>    sigprocmask(SIG_SETMASK, &amp;igno, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">if</span> (signal(SIGABRT, signal_cb) == SIG_ERR)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;err set!\rr\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;abort signal set ok\r\n&quot;</span>);<br>    <span class="hljs-built_in">abort</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Done\r\n&quot;</span>); <span class="hljs-comment">//无法执行</span><br>    fflush(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2><a class="markdownIt-Anchor" href="#"></a>   </h2><h3 id="孤儿进程和僵尸进程"><a class="markdownIt-Anchor" href="#孤儿进程和僵尸进程"></a> 孤儿进程和僵尸进程</h3><ul><li><strong>孤儿进程:</strong></li></ul><blockquote><p>  一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被<code>init</code>进程(进程号为<code>1</code>)所收养，并由<code>init</code>进程对它们完成状态收集工作。孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了<code>init</code>进程身上，<code>init</code>进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为<code>init</code>，而<code>init</code>进程会循环地<code>wait()</code>它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，<code>init</code>进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害</p></blockquote><ul><li><strong>僵尸进程:</strong></li></ul><blockquote><p>  一个子进程在其父进程还没有调用<code>wait()</code>或<code>waitpid()</code>的情况下退出。这个子进程就是僵尸进程。任何一个子进程(<code>init</code>除外)在<code>exit()</code>之后，并非马上就消失掉，而是留下一个称为僵尸进程(<code>Zombie</code>)的数据结构，等待父进程处理。这是每个 子进程在结束时都要经过的阶段。如果子进程在<code>exit()</code>之后，父进程没有来得及处理，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</p></blockquote><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><ul><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/engineer0/article/details/109377195">Linux 之 进程组、会话、终端</a></li><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/w-smile/p/12829760.html">进程 进程组 会话的关系及作用</a></li><li><a target="_blank" rel="noopener" href="https://www.freesion.com/article/7765643734/">终端/进程组/会话/守护进程</a></li><li><a target="_blank" rel="noopener" href="https://www.likecs.com/show-205103490.html#sc=300">作业控制</a></li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Linux%E5%85%A5%E9%97%A8/" class="category-chain-item">Linux入门</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%8E%9F%E5%88%9B/">#原创</a> <a href="/tags/linux/">#linux</a> <a href="/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/">#多进程</a></div></div><div class="license-box my-3"><div class="license-title"><div>linux系统进程</div><div>http://example.com/2022/10/12/linux/process005226/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>EtcFly</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年10月12日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2024年3月5日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/10/18/linux/initserviceandsystemctl/diff011029/" title="Linux init、service、systemctl 三者区别"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Linux init、service、systemctl 三者区别</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/09/30/root/directory190824/" title="Linux根目录结构"><span class="hidden-mobile">Linux根目录结构</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="waline"></div><script type="text/javascript">Fluid.utils.loadComments("#waline",(function(){Fluid.utils.createCssLink("https://lib.baomitu.com/waline/2.14.1/waline.min.css"),Fluid.utils.createScript("https://lib.baomitu.com/waline/2.14.1/waline.min.js",(function(){var i=Object.assign({serverURL:"https://etcfly.top:14000/",path:"window.location.pathname",meta:["nick","mail","link"],requiredMeta:["nick"],lang:"zh-CN",emoji:["https://unpkg.com/@waline/emojis@1.1.0/qq"],dark:'html[data-user-color-scheme="dark"]',wordLimit:0,pageSize:10},{el:"#waline",path:window.location.pathname});Waline.init(i),Fluid.utils.waitElementVisible("#waline .vcontent",()=>{var i="#waline .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://github.com/EtcFly" target="_blank" rel="nofollow noopener"><span>Copyright</span></a> <i class="iconfont icon-copyright"></i> <a href="https://etcfly.top:14100/share/yqTLFDlP/%E4%BB%97%E5%89%91%E8%B5%B0%E5%A4%A9%E6%B6%AF" target="_blank" rel="nofollow noopener"><span>2018-2024 EtcFly</span></a><div style="font-size:.85rem"><span>总访问量 <span style="color:#000" id="PVstatic">0</span> 次&nbsp</span> <span>总访客数 <span style="color:#000" id="UVstatic">0</span> 人&nbsp</span> <span>当前在线 <span style="color:#000" id="ACTstatic">0</span> 人&nbsp</span><script src="https://etcfly.top:14200/statistics" defer></script></div><div style="font-size:.85rem"><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="js/duration.js"></script></div></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener"></a> </span><span><a href="http://beian.miit.gov.cn/2023000858" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" alt="police-icon"> <span>浙ICP备2023000858号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/jquery.min.js"></script><script src="/live2d-widget/autoload.js"></script><script src="/js/star.js"></script><script src="/js/ribbon.min.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>