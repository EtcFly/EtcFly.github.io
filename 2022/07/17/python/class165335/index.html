<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="EtcFly"><meta name="keywords" content=""><meta name="description" content="版权归作者所有, 转载请保留该部分声明。本文作者：EtcFly原文地址：https:&#x2F;&#x2F;etcfly.top             类和对象   把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specializatio"><meta property="og:type" content="article"><meta property="og:title" content="python之面向对象编程"><meta property="og:url" content="http://example.com/2022/07/17/python/class165335/"><meta property="og:site_name" content="仗剑走天涯"><meta property="og:description" content="版权归作者所有, 转载请保留该部分声明。本文作者：EtcFly原文地址：https:&#x2F;&#x2F;etcfly.top             类和对象   把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specializatio"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/python.png"><meta property="article:published_time" content="2022-07-17T16:53:35.000Z"><meta property="article:modified_time" content="2024-03-05T03:41:03.000Z"><meta property="article:author" content="EtcFly"><meta property="article:tag" content="原创"><meta property="article:tag" content="python"><meta property="article:tag" content="语言"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/img/python.png"><title>python之面向对象编程 仗剑走天涯</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/fluid-extention.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:4},web_analytics:{enable:!0,follow_dnt:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"3AEufnWAJdp8cFODp1DXvrQU-MdYXbMMI",app_key:"mGJiL6xVvYv21ygqfynJoCyO",server_url:null,path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Strive For Dream</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="python之面向对象编程"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-07-17 16:53" pubdate>2022年7月17日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 11k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 95 分钟 </span><span id="vvdpost_container_page_pvuv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="vvdpost_value_page_pv">0</span> 次&nbsp&nbsp <i class="iconfont icon-users" aria-hidden="true"></i> <span id="vvdpost_value_page_uv">0</span> 人</span><script>console.log(window.location.pathname);var httpRequest=new XMLHttpRequest;httpRequest.open("POST","https://etcfly.top:14200/poststats",!0),httpRequest.setRequestHeader("Content-type","application/json"),httpRequest.send(JSON.stringify(window.location.pathname)),httpRequest.onreadystatechange=function(){if(4==httpRequest.readyState&&200==httpRequest.status){var e=httpRequest.responseText,t=JSON.parse(e);console.log(t.pv);var o=document.querySelector("#vvdpost_container_page_pvuv");if(console.log(o),o){var n=document.querySelector("#vvdpost_value_page_pv");console.log(n);var s=document.querySelector("#vvdpost_value_page_uv");console.log(s),s&&s&&(n.innerText=t.pv,s.innerText=t.uv,o.style.display="inline")}}}</script></div></div></div></div></div></div><script async src="https://etcfly.top:14100/script.js" data-website-id="1a5c096d-21e5-4556-99b0-28c810c9c868"></script></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">python之面向对象编程</h1><p class="note note-info">本文最后更新于：2024年3月5日 凌晨</p><div class="markdown-body"><div class="note note-success"><p>版权归作者所有, 转载请保留该部分声明。<br>本文作者：EtcFly<br>原文地址：<a target="_blank" rel="noopener" href="https://etcfly.top">https://etcfly.top</a></p></div><h3 id="类和对象"><a class="markdownIt-Anchor" href="#类和对象"></a> 类和对象</h3><p>  把一组数据结构和处理它们的方法组成对象（<code>object</code>），把相同行为的对象归纳为类（<code>class</code>），通过类的封装（<code>encapsulation</code>）隐藏内部细节，通过继承（<code>inheritance</code>）实现类的特化（<code>specialization</code>）和泛化（<code>generalization</code>），通过多态（<code>polymorphism</code>）实现基于对象类型的动态分派。</p><h3 id="定义类"><a class="markdownIt-Anchor" href="#定义类"></a> 定义类</h3><p><code>python</code>中使用<code>class</code>来定义一个类,格式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>(<span class="hljs-title class_ inherited__">partentClass</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        xxx<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func1</span>(<span class="hljs-params">self</span>):<br>        xxxx<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func2</span>(<span class="hljs-params">self</span>):<br>        xxxx<br></code></pre></td></tr></table></figure><ul><li><strong>ClassName</strong>:类名</li><li><strong>partentClass</strong>: 继承的父类对象, 如果为空表示不继承任何类</li><li><strong><strong>init</strong></strong>: 类的构造方法, 构造类自动调用构造函数, 如果没有提供, 会调用系统构造函数和析构函数</li><li><strong>func1</strong>：自己定义的类方法, 类方法必须包含参数<code>self</code>, 表示类的实例, 名字可以不是<code>self</code></li></ul><blockquote><p>说明:写在类中的函数，我们通常称之为（对象的）方法，这些方法就是对象可以接收的消息。</p></blockquote><hr><h3 id="类方法属性"><a class="markdownIt-Anchor" href="#类方法属性"></a> 类方法属性:</h3><ul><li>公共属性: 类的外部和内部都可以访问的属性</li><li>私有属性: 类的外部和子类不可以访问, 只有类自身可访问, 通常变量名前加__标识, 外部强制访问需要加__类名+方法名,调用方法为:<br><code>对象名._类名__私有属性名</code></li><li>保护属性: <code>python</code>没有保护方法, 但是约定类内部的变量或者方法, 以_开头的, 该属性或者方法只能在类本身以及其子类中访问。</li></ul><p><strong>下划线说明:</strong></p><ul><li>__foo__: 定义的是特殊方法，一般是系统定义名字 ，类似 __init__() 之类的。</li><li>_foo: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 from module import *</li><li>__foo: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了</li></ul><hr><h3 id="类内全局变量"><a class="markdownIt-Anchor" href="#类内全局变量"></a> 类内全局变量:</h3><p>  全体类的 <strong>实例化对象</strong> 公用的数据, 是 <u>公用一个地址</u> 的。一个对象修改会导致其他实例化对象同步修改。一般这种影响存在与 <u>列表</u> 以及 <u>字典</u> 这类数据类型。其他 <u>只读</u> 的数据类型，实例化的对象在进行数据赋值的时候，会将变量的引用地址修改为 <u>新的地址</u>。</p><p><strong>类操作内置函数</strong></p><ul><li><code>getattr</code>: 获取属性值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:<br>    a = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">pass</span><br><br>A_obj = A()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">getattr</span>(A_obj, <span class="hljs-string">&#x27;a&#x27;</span>))<br></code></pre></td></tr></table></figure><ul><li><code>setattr</code>: 设置属性值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:<br>    a = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">pass</span><br><br>A_obj = A()<br><span class="hljs-built_in">setattr</span>(A_obj, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><ul><li><code>delattr</code>: 删除属性值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:<br>    a = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">pass</span><br><br>A_obj = A()<br><span class="hljs-built_in">delattr</span>(A_obj, <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-comment"># 相当于del A.a</span><br></code></pre></td></tr></table></figure><ul><li><code>hasattr</code>: 是否拥有属性值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:<br>    a = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">pass</span><br><br>A_obj = A()<br><span class="hljs-built_in">hasattr</span>(A_obj, <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-comment"># 返回True</span><br></code></pre></td></tr></table></figure><hr><h3 id="python内置类属性"><a class="markdownIt-Anchor" href="#python内置类属性"></a> python内置类属性</h3><ul><li>__dict__ : 类的属性（包含一个字典，由类的数据属性组成）</li><li>__doc__ :类的文档字符串</li><li>__name__: 类名</li><li>__module__: 类定义所在的模块（类的全名是<code>'__main__.className'</code>，如果类位于一个导入模块<code>mymod</code>中，那么<code>className.__module__</code> 等于 <code>mymod</code>）</li><li>__bases__ : 类的所有父类构成元素（包含了一个由所有父类组成的元组）</li></ul><hr><h3 id="python继承"><a class="markdownIt-Anchor" href="#python继承"></a> python继承</h3><ul><li>子类继承父类的属性, 但是对父类的私有属性无法访问</li><li>子类调用特定方法, 方法首先从子类查找, 没有在查找父类的方法并访问。如果想覆盖父类的方法, 只需要子类对该方法进行重写。</li><li>想在子类方法中调用父类方法, 只需要通过父类类名加方法即可访问。</li></ul><hr><h3 id="课后示例"><a class="markdownIt-Anchor" href="#课后示例"></a> 课后示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><br><span class="hljs-comment"># 例题1</span><br><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">clock_time</span>:<br>    _hour = <span class="hljs-number">0</span><br>    _<span class="hljs-built_in">min</span> = <span class="hljs-number">0</span><br>    _sec = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, hour=<span class="hljs-number">0</span>, <span class="hljs-built_in">min</span>=<span class="hljs-number">0</span>, sec=<span class="hljs-number">0</span></span>):<br>        self._hour = hour<br>        self._<span class="hljs-built_in">min</span> = <span class="hljs-built_in">min</span><br>        self._sec = sec<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_clock_time</span>(<span class="hljs-params">self, hour, <span class="hljs-built_in">min</span>, sec</span>):<br>        self._hour = hour<br>        self._<span class="hljs-built_in">min</span> = <span class="hljs-built_in">min</span><br>        self._sec = sec<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">show_clock_time</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hour:%02d min:%02d sec:%02d&quot;</span> %(self._hour, self._<span class="hljs-built_in">min</span>, self._sec))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        time.sleep(<span class="hljs-number">1</span>)<br>        self._sec += <span class="hljs-number">1</span><br>        self._<span class="hljs-built_in">min</span>  += (self._sec // <span class="hljs-number">60</span>)<br>        self._hour += (self._<span class="hljs-built_in">min</span> // <span class="hljs-number">60</span>)<br>        self._sec =  self._sec % <span class="hljs-number">60</span><br>        self._<span class="hljs-built_in">min</span> %= <span class="hljs-number">60</span><br>        self._hour %= <span class="hljs-number">24</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    now_time = clock_time(<span class="hljs-number">23</span>, <span class="hljs-number">59</span>, <span class="hljs-number">50</span>)<br>    now_time.show_clock_time()<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        now_time.run()<br>        now_time.show_clock_time()<br><br><span class="hljs-comment"># 例题2</span><br><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">import</span> dis<br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>:<br>    _x = <span class="hljs-number">0.0</span><br>    _y = <span class="hljs-number">0.0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x = <span class="hljs-number">0.0</span>, y = <span class="hljs-number">0.0</span></span>):<br>        self._x = x<br>        self._y = y<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_pos</span>(<span class="hljs-params">self, x, y</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;set (%d,%d) to (%d, %d)&quot;</span> % (self._x, self._y, x, y))<br>        self._x = x<br>        self._y = y<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_pos</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;pos(%d,%d)&#x27;</span> %(self._x, self._y))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calc_distance</span>(<span class="hljs-params">self, point: <span class="hljs-built_in">object</span></span>):<br>        <span class="hljs-keyword">return</span> sqrt((self._x - point._x) ** <span class="hljs-number">2</span> + (self._y - point._y)**<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;(%s, %s)&#x27;</span> % (<span class="hljs-built_in">str</span>(self._x), <span class="hljs-built_in">str</span>(self._y))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pos0 = Point(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    pos1 = Point()<br>    pos1.set_pos(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>)<br>    pos0.get_pos()<br>    distance = pos0.calc_distance(pos1)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;距离:%f&quot;</span> % (distance))<br>    <span class="hljs-built_in">print</span>(pos1)<br></code></pre></td></tr></table></figure><h3 id="闭包"><a class="markdownIt-Anchor" href="#闭包"></a> 闭包</h3><blockquote><p>闭包（<code>Closure</code>），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。</p></blockquote><p><strong>说明</strong></p><ol><li>如果在一个函数的内部定义了另一个函数，外部的我们叫他<mark>外函数</mark>，内部的我们叫他<mark>内函数</mark>。</li><li>在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用【即外函数的返回值是内函数的内存地址】。这样就构成了一个闭包。</li><li>一般情况下，在我们认知当中，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。<mark>但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。</mark></li></ol><p><strong>闭包示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">install_func</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">local_func</span>(<span class="hljs-params">*arg</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;i&#x27;m happy in local function&quot;</span>)<br>        func()<br>    <span class="hljs-keyword">return</span> local_func<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;test fuc&#x27;</span>)<br><br>ptest_func = install_func(test_func) <span class="hljs-comment">#intsall_func和local_func组成一个闭包</span><br>ptest_func()<br></code></pre></td></tr></table></figure><p>闭包包含两个重要特性：</p><ul><li>外函数返回了内函数的引用：</li></ul><blockquote><p><strong>引用</strong> 是什么？在<code>python</code>中一切都是对象，包括整型数据1，函数，其实是对象。<br>　　当我们进行a=1的时候，实际上在内存当中有一个地方存了值1，然后用a这个变量名存了1所在内存位置的引用。引用就好像c语言里的指针，大家可以把引用理解成地址。a只不过是一个变量名字，a里面存的是1这个数值所在的地址，就是a里面存了数值1的引用。<br>　　相同的道理，当我们在<code>python</code>中定义一个函数<code>def demo()</code>: 的时候，内存当中会开辟一些空间，存下这个函数的<mark>代码、内部的局部变量</mark>等等。这个<code>demo</code>只不过是一个变量名字，它里面存了这个函数所在位置的引用而已【即函数名’变量’存储了该函数的内存地址】。我们还可以进行<code>x = demo， y = demo</code>， 这样的操作就相当于，把<code>demo</code>里存的东西赋值给x和y，这样x 和y 都指向了<code>demo</code>函数所在的引用，在这之后我们可以用<code>x()</code>或者 <code>y()</code> 来调用我们自己创建的<code>demo()</code> ，调用的实际上根本就是一个函数，<code>x、y</code>和<code>demo</code>三个变量名存了同一个函数的引用。<br>　　对于闭包，在外函数<code>outer</code>中 最后<code>return inner</code>，我们在调用外函数 <code>demo = outer()</code> 的时候，<code>outer</code>返回了<code>inner</code>，<code>inner</code>是一个函数的引用，这个引用被存入了<code>demo</code>中。所以接下来我们再进行<code>demo()</code> 的时候，相当于运行了inner函数。<br>　　一个函数，如果函数名后紧跟一对括号，相当于现在我就要调用这个函数，如果不跟括号，相当于只是一个函数的名字，里面存了函数所在位置的引用。</p></blockquote><ul><li>外函数把临时变量绑定给内函数：</li></ul><blockquote><p>按照我们正常的认知，一个函数结束的时候，会把自己的临时变量都释放还给内存，之后变量都不存在了。一般情况下，确实是这样的。但是闭包是一个特别的情况。外部函数发现，自己的临时变量会在将来的内部函数中用到，自己在结束的时候，返回内函数的同时，会把外函数的临时变量送给内函数绑定在一起。所以外函数已经结束了，调用内函数的时候仍然能够使用外函数的临时变量。<br>　　在上面实例中，两次调用外部函数outer,分别传入的值是5和7。内部函数只定义了一次，我们发现调用的时候，内部函数是能识别外函数的临时变量是不一样的。python中一切都是对象，虽然函数我们只定义了一次，但是外函数在运行的时候，实际上是按照里面代码执行的，外函数里创建了一个函数，我们每次调用外函数，它都创建一个内函数，虽然代码一样，但是却创建了不同的对象，并且把每次传入的临时变量数值绑定给内函数，再把内函数引用返回。虽然内函数代码是一样的，但其实，我们每次调用外函数，都返回不同的实例对象的引用【返回的内函数的内存地址不同】，他们的功能是一样的，但是它们实际上不是同一个函数对象。</p></blockquote><p><strong>Note</strong>:<br>   <code>python</code>中一切皆对象, 并且<code>python</code>中内存碎片管理机制采用 <strong>引用计数</strong> 和 <strong>循环计数</strong> 来管理, 及某一个对象如果引用为0， 那么这个对象在接下来会被释放。类似<code>linux</code>中的硬连接。只要硬连接数不为0, 文件就不会被释放。</p><h4 id="闭包的作用"><a class="markdownIt-Anchor" href="#闭包的作用"></a> 闭包的作用</h4><blockquote><p>装饰器！！！装饰器是做什么的？？其中一个应用就是，我们工作中写了一个登录功能，我们想统计这个功能执行花了多长时间，我们可以用装饰器装饰这个登录模块，装饰器帮我们完成登录函数执行之前和之后取时间。<br>　　 　 面向对象！！！经历了上面的分析，我们发现外函数的临时变量送给了内函数。大家回想一下类对象的情况，对象有好多类似的属性和方法，所以我们创建类，用类创建出来的对象都具有相同的属性方法。闭包也是实现面向对象的方法之一。在python当中虽然我们不这样用，在其他编程语言入比如avaScript中，经常用闭包来实现面向对象编程<br>　　 实现单例模式！！ 其实这也是装饰器的应用。单利模式毕竟比较高大，，需要有一定项目经验才能理解单利模式到底是干啥用的，我们就不探讨了。</p></blockquote><h3 id="装饰器"><a class="markdownIt-Anchor" href="#装饰器"></a> 装饰器</h3><blockquote><p>装饰器(Decorators)是 Python 的一个重要部分。简单地说：他们是修改其他函数的功能的函数。他们有助于让我们的代码更简短，也更Pythonic（Python范儿）。</p></blockquote><p><strong>自己DIY装饰器：</strong>(装饰器其实就是对闭包的一种使用)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">install_func</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">local_func</span>(<span class="hljs-params">*arg</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;i&#x27;m happy in local function&quot;</span>)<br>        func()<br>    <span class="hljs-keyword">return</span> local_func<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;test fuc&#x27;</span>)<br><br>ptest_func = install_func(test_func) <span class="hljs-comment"># install_func就是一个装饰器</span><br>ptest_func()<br></code></pre></td></tr></table></figure><p>修改的更加简练如下: 利用了<code>python</code>的 <strong>语法糖</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">install_func</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">local_func</span>(<span class="hljs-params">*arg</span>):<br>        log.write(<span class="hljs-string">&quot;function is running&quot;</span>)<br>        <span class="hljs-keyword">return</span> func(*arg)<br>    <span class="hljs-keyword">return</span> local_func<br><br><span class="hljs-meta">@install_func</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;test fuc&#x27;</span>)<br><br>test_func() <span class="hljs-comment"># install_func就是一个装饰器</span><br></code></pre></td></tr></table></figure><p>效果和上面的示例一样, 但是我们并没有修改<code>test_func</code>函数, 却为他新增了日志功能。这就是装饰器最大的优点, 可以在不修改函数源代码的情况下新增功能。</p><p>那装饰器如何传入参数呢？我们只需要在内部定义一个和外部相同函数原型的内函数即可，如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">install_func</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">local_func</span>(<span class="hljs-params">_name, _age</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;i&#x27;m happy in local function&quot;</span>)<br>        <span class="hljs-keyword">return</span> func(_name, _age)<br>    <span class="hljs-keyword">return</span> local_func<br><br><span class="hljs-meta">@install_func</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_func</span>(<span class="hljs-params">name, age</span>):<br>    <span class="hljs-built_in">print</span>(name, age)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;test fuc&#x27;</span>)<br><br>test_func(<span class="hljs-string">&quot;marty&quot;</span>, <span class="hljs-number">14</span>)<br></code></pre></td></tr></table></figure><p>但是这有一个问题, 假设用户<code>test_func</code>修改了函数参数, 那么装饰器也要修改吗？这样代码维护起来将会异常繁琐, 辛运的是, <code>Python</code>提供了可变参数<code>*args</code>, 那么我可以修改装饰器如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">install_func</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">local_func</span>(<span class="hljs-params">*args</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;i&#x27;m happy in local function&quot;</span>)<br>        <span class="hljs-keyword">return</span> func(*args)<br>    <span class="hljs-keyword">return</span> local_func<br><br><span class="hljs-meta">@install_func</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_func</span>(<span class="hljs-params">name, info</span>):<br>    <span class="hljs-built_in">print</span>(name, info)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;test fuc&#x27;</span>)<br><br><span class="hljs-meta">@install_func</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_age</span>(<span class="hljs-params">name, age, love</span>):<br>    <span class="hljs-built_in">print</span>(name, age)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;test fuc&#x27;</span>)<br><br>test_func(<span class="hljs-string">&quot;marty&quot;</span>, <span class="hljs-number">14</span>)<br>get_age(<span class="hljs-string">&quot;json&quot;</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&quot;serty&quot;</span>)<br></code></pre></td></tr></table></figure><p>那如果get_age函数还定义了关键字参数呢？比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_age</span>(<span class="hljs-params">name, age=<span class="hljs-number">12</span>, love=<span class="hljs-string">&#x27;marty&#x27;</span></span>):<br>    <span class="hljs-built_in">print</span>(name, age)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;test fuc&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这时候, 可以将<code>local_func</code>指定为关键字函数<code>**kwargs</code>, 如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">install_func</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">local_func</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;i&#x27;m happy in local function&quot;</span>)<br>        <span class="hljs-keyword">return</span> func(*args, **kwargs)<br>    <span class="hljs-keyword">return</span> local_func<br><br><span class="hljs-meta">@install_func</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_func</span>(<span class="hljs-params">name, info</span>):<br>    <span class="hljs-built_in">print</span>(name, info)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;test fuc&#x27;</span>)<br><br><span class="hljs-meta">@install_func</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_age</span>(<span class="hljs-params">name, age, love</span>):<br>    <span class="hljs-built_in">print</span>(name, age)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;test fuc&#x27;</span>)<br><br>test_func(<span class="hljs-string">&quot;marty&quot;</span>, <span class="hljs-number">14</span>)<br>get_age(<span class="hljs-string">&quot;json&quot;</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&quot;serty&quot;</span>)<br></code></pre></td></tr></table></figure><p>貌似现在问题已经解决的很完美, 那我们来做个测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_func</span>():<br>    <span class="hljs-built_in">print</span>(test_func.__name__)<br><br>test_func() <span class="hljs-comment">#测试结果为:test_func</span><br></code></pre></td></tr></table></figure><p>也就是说通过<code>func.__name__</code>可以打印函数名称, 好了, 那我们在装饰器上使用试试, 测试如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">install_func</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">local_func</span>(<span class="hljs-params">*arg</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;i&#x27;m happy in local function&quot;</span>)<br>        <span class="hljs-keyword">return</span> func(*arg)<br>    <span class="hljs-keyword">return</span> local_func<br><br><span class="hljs-meta">@install_func</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_func</span>(<span class="hljs-params">name, info</span>):<br>    <span class="hljs-built_in">print</span>(name, info)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;test fuction&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(test_func.__name__)<br><br>test_func(<span class="hljs-string">&quot;marty&quot;</span>, <span class="hljs-number">14</span>)<br><br>结果如下:<br>i<span class="hljs-string">&#x27;m happy in local function</span><br><span class="hljs-string">marty 14</span><br><span class="hljs-string">test fuction</span><br><span class="hljs-string">local_func</span><br></code></pre></td></tr></table></figure><p>从结果我们可以看出, <code>test_func</code>函数中, 我们打印<code>test_func.__name__</code>, 结果显示为<code>local_func</code>, 是上一级调用函数的名称。这是有问题的。这里的函数被<code>local_func</code>替代了。它重写了我们函数的名字和注释文档(<code>docstring</code>)。幸运的是<code>Python</code>提供给我们一个简单的函数来解决这个问题，那就是<code>functools.wraps</code>。修改如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">install_func</span>(<span class="hljs-params">func</span>):<br><span class="hljs-meta">    @wraps(<span class="hljs-params">func</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">local_func</span>(<span class="hljs-params">*arg</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;i&#x27;m happy in local function&quot;</span>)<br>        <span class="hljs-keyword">return</span> func(*arg)<br>    <span class="hljs-keyword">return</span> local_func<br><br><span class="hljs-meta">@install_func</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_func</span>(<span class="hljs-params">name, info</span>):<br>    <span class="hljs-built_in">print</span>(name, info)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;test fuction&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(test_func.__name__)<br><br>test_func(<span class="hljs-string">&quot;marty&quot;</span>, <span class="hljs-number">14</span>)<br>结果为:<br>i<span class="hljs-string">&#x27;m happy in local function</span><br><span class="hljs-string">marty 14</span><br><span class="hljs-string">test fuction</span><br><span class="hljs-string">test_func</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>:<br><code>@wraps</code>接受一个函数来进行装饰，并加入了复制函数名称、注释文档、参数列表等等的功能。这可以让我们在装饰器里面访问在装饰之前的函数的属性。</p><hr><h4 id="带参数的装饰器"><a class="markdownIt-Anchor" href="#带参数的装饰器"></a> 带参数的装饰器</h4><p>来想想这个问题，难道<code>@wraps</code>不也是个装饰器吗？但是，它接收一个参数，就像任何普通的函数能做的那样。那么，为什么我们不也那样做呢？ 这是因为，当你使用<code>@my_decorator</code>语法时，你是在应用一个以单个函数作为参数的一个包裹函数。记住，<code>Python</code>里每个东西都是一个对象，而且这包括函数！记住了这些，我们可以编写一下能返回一个包裹函数的函数。如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">file_name = <span class="hljs-string">&#x27;log.txt&#x27;</span></span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">log_decode</span>(<span class="hljs-params">func</span>):<br><span class="hljs-meta">        @wraps(<span class="hljs-params">func</span>)</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">local_func</span>(<span class="hljs-params">*arg</span>):<br>            <span class="hljs-built_in">print</span>(func.__name__ + <span class="hljs-string">&#x27; is called, and wirte to &#x27;</span>, file_name)<br>            <span class="hljs-keyword">return</span> func(*arg)<br>        <span class="hljs-keyword">return</span> local_func<br>    <span class="hljs-keyword">return</span> log_decode<br><br><span class="hljs-meta">@log(<span class="hljs-params"><span class="hljs-string">&#x27;log123.txt&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_func</span>(<span class="hljs-params">name, info</span>):<br>    <span class="hljs-built_in">print</span>(name, info)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;test fuction&#x27;</span>)<br><br>test_func(<span class="hljs-string">&quot;marty&quot;</span>, <span class="hljs-number">14</span>)<br><br>输出结果为:<br>test_func <span class="hljs-keyword">is</span> called, <span class="hljs-keyword">and</span> wirte to  log123.txt<br>marty <span class="hljs-number">14</span><br>test fuction<br></code></pre></td></tr></table></figure><p>上面这种写法有点抽象, 其等价如下写法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">file_name = <span class="hljs-string">&#x27;log.txt&#x27;</span></span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">log_decode</span>(<span class="hljs-params">func</span>):<br><span class="hljs-meta">        @wraps(<span class="hljs-params">func</span>)</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">local_func</span>(<span class="hljs-params">*arg</span>):<br>            <span class="hljs-built_in">print</span>(func.__name__ + <span class="hljs-string">&#x27; is called, and wirte to &#x27;</span>, file_name)<br>            <span class="hljs-keyword">return</span> func(*arg)<br>        <span class="hljs-keyword">return</span> local_func<br>    <span class="hljs-keyword">return</span> log_decode<br><br><span class="hljs-comment">#@log(&#x27;log123.txt&#x27;)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_func</span>(<span class="hljs-params">name, info</span>):<br>    <span class="hljs-built_in">print</span>(name, info)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;test fuction&#x27;</span>)<br><br>tmp = log(<span class="hljs-string">&#x27;log123.txt&#x27;</span>)<br>test_func = tmp(test_func)<br>test_func(<span class="hljs-string">&quot;marty&quot;</span>, <span class="hljs-number">14</span>)<br></code></pre></td></tr></table></figure><hr><h4 id="类装饰器"><a class="markdownIt-Anchor" href="#类装饰器"></a> 类装饰器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">log</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, func</span>):<br><span class="hljs-meta">        @wraps(<span class="hljs-params">func</span>)</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">log_dect</span>(<span class="hljs-params">*args, **key_args</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;this is &#x27;</span>, func.__name__)<br>            <span class="hljs-keyword">return</span> func(*args, **key_args)<br>        <span class="hljs-keyword">return</span> log_dect<br><br><span class="hljs-meta">@log()</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_func</span>(<span class="hljs-params">name, info</span>):<br>    <span class="hljs-built_in">print</span>(name, info)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;test fuction&#x27;</span>)<br><br>test_func(<span class="hljs-string">&quot;marty&quot;</span>, <span class="hljs-number">14</span>)<br><br>输出结果为:<br>this <span class="hljs-keyword">is</span>  test_func<br>marty <span class="hljs-number">14</span><br>test fuction<br></code></pre></td></tr></table></figure><p>这里使用了<code>__call__</code>方法, 该方法主要是将类可以转换为可以直接通过 <strong>类名()</strong> 调用的形式。所以如上装饰器可以简化为如下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">tmp = log()<br>test_func = tmp(test_func)<br>test_func()<br></code></pre></td></tr></table></figure><p>本质上和函数没有任何区别。但是通过类封装有一个最大优点是功能可以被子类进行继承和扩展了。封装在函数中的装饰器就没有这一优势。</p><hr><p><code>python</code>内置了三种装饰器:</p><ul><li><code>@staticmethod</code>: 静态方法使用<ul><li>类的方法需要<code>self</code>来修饰, 否则表示方法为静态方法。</li><li>该方法不需要类实例化即可调用, 通过类名.方法 如下:</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">qtest</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func_test</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-built_in">print</span>(x)<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_func</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-built_in">print</span>(x)<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    qtest.test_func(<span class="hljs-string">&#x27;i love you baby!&#x27;</span>)<br>    qtest.func_test(<span class="hljs-string">&#x27;do you love me&#x27;</span>) <span class="hljs-comment">#TypeError: func_test() missing 1 required positional argument: &#x27;x&#x27;</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><ul><li>@classmethod: 类方法使用<ul><li>类的静态方法</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">qtest</span>:<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func_test</span>(<span class="hljs-params">cls, x</span>):<br>        <span class="hljs-built_in">print</span>(x)<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_func</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-built_in">print</span>(x)<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    qtest.test_func(<span class="hljs-string">&#x27;i love you baby!&#x27;</span>)<br>    qtest.func_test(<span class="hljs-string">&#x27;do you love me&#x27;</span>)<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p><strong>Note</strong><br>   classmethod 和 staticmethod 方法的区别在于, <code>classmethod</code> 需要包含参数 <code>cls</code>, 其和类的类型绑定, <code>staticmethod</code> 则不需要<code>cls</code>, 也不需要 <code>self</code>, 即静态函数是不与类以及实例化对象绑定的。其次, 静态方法和类方法有利于命名空间的干净。</p><ul><li>@property: 把类的方法伪装成属性, 只读属性<ul><li>属性.setter</li><li>属性.getter</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">test_function</span>(<span class="hljs-title class_ inherited__">object</span>):<br><span class="hljs-meta">    @property </span><span class="hljs-comment">#getter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">age</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;get curr age:&#x27;</span>, self._age)<br>        <span class="hljs-keyword">return</span> self._age<br><span class="hljs-meta">    @age.setter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">age</span>(<span class="hljs-params">self, age</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;set curr age:&#x27;</span>, age)<br>        self._age = age<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, age=<span class="hljs-number">10</span></span>):<br>        self._age = age<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    test_obj = test_function(<span class="hljs-number">990</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;age:&#x27;</span>, test_obj.age)<br>    test_obj.age = <span class="hljs-number">22</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;age:&#x27;</span>, test_obj.age)<br></code></pre></td></tr></table></figure><p>  上述的<code>@property</code>其实就是<code>属性.getter</code> 装饰器, 如果重复定义 <code>age.getter</code> 装饰器, 那么后面一个会覆盖前面一个。其次, 不管是<code>setter</code> 还是 <code>getter</code> 装饰器, 他们装饰的函数名都是一样的(上述代码都是<code>age</code>)</p><hr><h3 id="__slots__魔法"><a class="markdownIt-Anchor" href="#__slots__魔法"></a> __slots__魔法</h3><hr><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><ol><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hls-code/p/15268533.html">python详解闭包</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/bing_xin_ran_huo/article/details/107664454?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_paycolumn_v3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_paycolumn_v3&amp;utm_relevant_index=2">什么是闭包,一次搞懂(详解)</a></li><li><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/python-func-decorators.html">Python 函数装饰器</a></li><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hls-code/p/15318801.html">详解python装饰器</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/C1054158790/article/details/118711752">python内置装饰器</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/chehec2010/article/details/122072797">python内置装饰器2</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35462323/article/details/89307534">__call__特殊函数说明</a></li></ol></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Python%E5%85%A5%E9%97%A8/" class="category-chain-item">Python入门</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%8E%9F%E5%88%9B/">#原创</a> <a href="/tags/python/">#python</a> <a href="/tags/%E8%AF%AD%E8%A8%80/">#语言</a></div></div><div class="license-box my-3"><div class="license-title"><div>python之面向对象编程</div><div>http://example.com/2022/07/17/python/class165335/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>EtcFly</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年7月17日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2024年3月5日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/07/17/python/fileerror/165554/" title="python之文件和异常"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">python之文件和异常</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/07/17/python/basedata/practive/164823/" title="python之基础数据结构练习"><span class="hidden-mobile">python之基础数据结构练习</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="waline"></div><script type="text/javascript">Fluid.utils.loadComments("#waline",(function(){Fluid.utils.createCssLink("https://lib.baomitu.com/waline/2.14.1/waline.min.css"),Fluid.utils.createScript("https://lib.baomitu.com/waline/2.14.1/waline.min.js",(function(){var i=Object.assign({serverURL:"https://etcfly.top:14000/",path:"window.location.pathname",meta:["nick","mail","link"],requiredMeta:["nick"],lang:"zh-CN",emoji:["https://unpkg.com/@waline/emojis@1.1.0/qq"],dark:'html[data-user-color-scheme="dark"]',wordLimit:0,pageSize:10},{el:"#waline",path:window.location.pathname});Waline.init(i),Fluid.utils.waitElementVisible("#waline .vcontent",()=>{var i="#waline .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://github.com/EtcFly" target="_blank" rel="nofollow noopener"><span>Copyright</span></a> <i class="iconfont icon-copyright"></i> <a href="https://etcfly.top:14100/share/yqTLFDlP/%E4%BB%97%E5%89%91%E8%B5%B0%E5%A4%A9%E6%B6%AF" target="_blank" rel="nofollow noopener"><span>2018-2024 EtcFly</span></a><div style="font-size:.85rem"><span>总访问量 <span style="color:#000" id="PVstatic">0</span> 次&nbsp</span> <span>总访客数 <span style="color:#000" id="UVstatic">0</span> 人&nbsp</span> <span>当前在线 <span style="color:#000" id="ACTstatic">0</span> 人&nbsp</span><script src="https://etcfly.top:14200/statistics" defer></script></div><div style="font-size:.85rem"><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="js/duration.js"></script></div></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener"></a> </span><span><a href="http://beian.miit.gov.cn/2023000858" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" alt="police-icon"> <span>浙ICP备2023000858号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/jquery.min.js"></script><script src="/live2d-widget/autoload.js"></script><script src="/js/star.js"></script><script src="/js/ribbon.min.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>